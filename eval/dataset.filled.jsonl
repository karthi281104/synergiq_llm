{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the main topic of these notes?", "gold_answer": "Asymptotic Notations.", "gold_evidence": "[p2:c1] Asymptotic Notations\nŒ∏-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = Œ∏ (g(n)) if and only if\nf(n) ‚â§ c1 . g(n) and f(n) ‚â• c2 . g(n)  ‚àÄ n ‚â•  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ‚â• 1\nO-Notation [Pronounced ‚Äúbig -oh‚Äù]\nLet f(n) and g(n) be two positive functions\nf(n) = O(g(n)), if and only iff(n) ‚â§ c . g(‚Ä¶\n[p3:c3] Asymptotic notation does not satisfy trichotomy\nproperty\nex: f(n) = n, g(n) = n * |sin(n)|, n > 0\n‚à¥ These two functions cannot converge\nExample\n1.Loop\nfor ( i = 1; i <= n; i++) {\nx=y+z;\n}\nT(n) = O(n)\n2.Nested loop\nfor(i=1; i<=n; i++){\nfor(j=1; j<=n; j++){\nk= k+1;\n}\nT(n) = O(n2)\n3.Logarithm\nfor(i=1; i<=n ; i *= 2){\nk=k+1;\n}\nfor (int i = 1; i <= n; i‚Ä¶\n[p5:c9] Discrete Properties of Asymptotic Notation\nAnalogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower than so me\nmultiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than so me\nmultiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of g)\n‚óèIf f(n)‚Ä¶\n[p4:c7] Analogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower tha n\nsome multiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than\nsome multiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of\ng)\n‚óèIf f(n) is o(g(n)) : a < b  (f grows slower than a‚Ä¶", "draft_gold_evidence": "[p2:c1] Asymptotic Notations\nŒ∏-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = Œ∏ (g(n)) if and only if\nf(n) ‚â§ c1 . g(n) and f(n) ‚â• c2 . g(n)  ‚àÄ n ‚â•  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ‚â• 1\nO-Notation [Pronounced ‚Äúbig -oh‚Äù]\nLet f(n) and g(n) be two positive functions\nf(n) = O(g(n)), if and only iff(n) ‚â§ c . g(‚Ä¶\n[p3:c3] Asymptotic notation does not satisfy trichotomy\nproperty\nex: f(n) = n, g(n) = n * |sin(n)|, n > 0\n‚à¥ These two functions cannot converge\nExample\n1.Loop\nfor ( i = 1; i <= n; i++) {\nx=y+z;\n}\nT(n) = O(n)\n2.Nested loop\nfor(i=1; i<=n; i++){\nfor(j=1; j<=n; j++){\nk= k+1;\n}\nT(n) = O(n2)\n3.Logarithm\nfor(i=1; i<=n ; i *= 2){\nk=k+1;\n}\nfor (int i = 1; i <= n; i‚Ä¶\n[p5:c9] Discrete Properties of Asymptotic Notation\nAnalogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower than so me\nmultiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than so me\nmultiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of g)\n‚óèIf f(n)‚Ä¶\n[p4:c7] Analogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower tha n\nsome multiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than\nsome multiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of\ng)\n‚óèIf f(n) is o(g(n)) : a < b  (f grows slower than a‚Ä¶", "draft_gold_answer": "Asymptotic Notations."}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 5 key concepts covered.", "gold_answer": "1. Array and its properties\n2. Asymptotic notation and loop complexities\n3. Graph traversal techniques\n4. Knapsack problem\n5. Activity selection problem", "gold_evidence": "[p8:c16] array is a pair(i, j) such that i<j and arr[i] > arr[j])\nTime complexity : O(nlogn)\nSpace complexity : O(n)(due to merges)\n9.Closest pair of points (Find the minimum Euclidea n\ndistance between any two points in a 2D plane.)\nRecurrence relation => T(n) = 2T(n/2)  + O(n)\nTime complexity  = O(nlogn)\nSorting copies (x -sorted, y- sorted): O(n)\nAuxilia‚Ä¶\n[p3:c3] Asymptotic notation does not satisfy trichotomy\nproperty\nex: f(n) = n, g(n) = n * |sin(n)|, n > 0\n‚à¥ These two functions cannot converge\nExample\n1.Loop\nfor ( i = 1; i <= n; i++) {\nx=y+z;\n}\nT(n) = O(n)\n2.Nested loop\nfor(i=1; i<=n; i++){\nfor(j=1; j<=n; j++){\nk= k+1;\n}\nT(n) = O(n2)\n3.Logarithm\nfor(i=1; i<=n ; i *= 2){\nk=k+1;\n}\nfor (int i = 1; i <= n; i‚Ä¶\n[p16:c34] Module 5 : Graph traversal Techniques\nVisiting all nodes of the tree/Graph in a specified\norder and processing the information only once.\nDFS in Undirected graph:\na.Connected graph\nStructure of nodeE-node : Exploring node\nLive node: Node which is not fully exploredDead node: Node which is fully explored\nTime associated with the node, during travers‚Ä¶\n[p11:c21] knapsack until knapsack becomes full arrange arra y\na in ascending order\nTime complexity : O(n log n)\n4.Activity  selection problem  (You are given n\nactivities , each with a start time  and finish time .\nThe goal is to select the maximum number of\nactivities  that can be performed by a single\nperson, under the constraint that the person ca n\nwork‚Ä¶", "draft_gold_evidence": "[p8:c16] array is a pair(i, j) such that i<j and arr[i] > arr[j])\nTime complexity : O(nlogn)\nSpace complexity : O(n)(due to merges)\n9.Closest pair of points (Find the minimum Euclidea n\ndistance between any two points in a 2D plane.)\nRecurrence relation => T(n) = 2T(n/2)  + O(n)\nTime complexity  = O(nlogn)\nSorting copies (x -sorted, y- sorted): O(n)\nAuxilia‚Ä¶\n[p3:c3] Asymptotic notation does not satisfy trichotomy\nproperty\nex: f(n) = n, g(n) = n * |sin(n)|, n > 0\n‚à¥ These two functions cannot converge\nExample\n1.Loop\nfor ( i = 1; i <= n; i++) {\nx=y+z;\n}\nT(n) = O(n)\n2.Nested loop\nfor(i=1; i<=n; i++){\nfor(j=1; j<=n; j++){\nk= k+1;\n}\nT(n) = O(n2)\n3.Logarithm\nfor(i=1; i<=n ; i *= 2){\nk=k+1;\n}\nfor (int i = 1; i <= n; i‚Ä¶\n[p16:c34] Module 5 : Graph traversal Techniques\nVisiting all nodes of the tree/Graph in a specified\norder and processing the information only once.\nDFS in Undirected graph:\na.Connected graph\nStructure of nodeE-node : Exploring node\nLive node: Node which is not fully exploredDead node: Node which is fully explored\nTime associated with the node, during travers‚Ä¶\n[p11:c21] knapsack until knapsack becomes full arrange arra y\na in ascending order\nTime complexity : O(n log n)\n4.Activity  selection problem  (You are given n\nactivities , each with a start time  and finish time .\nThe goal is to select the maximum number of\nactivities  that can be performed by a single\nperson, under the constraint that the person ca n\nwork‚Ä¶", "draft_gold_answer": "1. Array and its properties\n2. Asymptotic notation and loop complexities\n3. Graph traversal techniques\n4. Knapsack problem\n5. Activity selection problem"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Define two important terms exactly as stated in the notes.", "gold_answer": "Œ∏-Notation: f(n) = Œ∏ (g(n)) if f(n) grows at the same rate as g(n), with f(n) ‚â§ c1 . g(n) and f(n) ‚â• c2 . g(n) for positive constants c1, c2 and n0.\n\nO-Notation: f(n) = O(g(n)) if f(n) grows slower than some multiple of g(n), i.e., f(n) ‚â§ c . g(n) for a positive constant c.", "gold_evidence": "[p2:c1] Asymptotic Notations\nŒ∏-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = Œ∏ (g(n)) if and only if\nf(n) ‚â§ c1 . g(n) and f(n) ‚â• c2 . g(n)  ‚àÄ n ‚â•  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ‚â• 1\nO-Notation [Pronounced ‚Äúbig -oh‚Äù]\nLet f(n) and g(n) be two positive functions\nf(n) = O(g(n)), if and only iff(n) ‚â§ c . g(‚Ä¶\n[p5:c9] Discrete Properties of Asymptotic Notation\nAnalogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower than so me\nmultiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than so me\nmultiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of g)\n‚óèIf f(n)‚Ä¶\n[p4:c7] Analogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower tha n\nsome multiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than\nsome multiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of\ng)\n‚óèIf f(n) is o(g(n)) : a < b  (f grows slower than a‚Ä¶\n[p17:c37] pair of vertices u and v in the set, there is a path from\nu to v and a path from v to u.\nProperties of Str ongly Connected Components\n1.Every directed graph is a D.A.G. of strongly\nconnected components.\n2.Let C and C‚Ä≤ b e distinct strongly connected\ncomponents in directed graph G = (V, E). Let u,\nv ‚àà C and u‚Ä≤, v‚Ä≤  ‚àà C‚Ä≤. Suppose that there is a\npath‚Ä¶", "draft_gold_evidence": "[p2:c1] Asymptotic Notations\nŒ∏-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = Œ∏ (g(n)) if and only if\nf(n) ‚â§ c1 . g(n) and f(n) ‚â• c2 . g(n)  ‚àÄ n ‚â•  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ‚â• 1\nO-Notation [Pronounced ‚Äúbig -oh‚Äù]\nLet f(n) and g(n) be two positive functions\nf(n) = O(g(n)), if and only iff(n) ‚â§ c . g(‚Ä¶\n[p5:c9] Discrete Properties of Asymptotic Notation\nAnalogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower than so me\nmultiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than so me\nmultiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of g)\n‚óèIf f(n)‚Ä¶\n[p4:c7] Analogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower tha n\nsome multiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than\nsome multiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of\ng)\n‚óèIf f(n) is o(g(n)) : a < b  (f grows slower than a‚Ä¶\n[p17:c37] pair of vertices u and v in the set, there is a path from\nu to v and a path from v to u.\nProperties of Str ongly Connected Components\n1.Every directed graph is a D.A.G. of strongly\nconnected components.\n2.Let C and C‚Ä≤ b e distinct strongly connected\ncomponents in directed graph G = (V, E). Let u,\nv ‚àà C and u‚Ä≤, v‚Ä≤  ‚àà C‚Ä≤. Suppose that there is a\npath‚Ä¶", "draft_gold_answer": "Œ∏-Notation: f(n) = Œ∏ (g(n)) if f(n) grows at the same rate as g(n), with f(n) ‚â§ c1 . g(n) and f(n) ‚â• c2 . g(n) for positive constants c1, c2 and n0.\n\nO-Notation: f(n) = O(g(n)) if f(n) grows slower than some multiple of g(n), i.e., f(n) ‚â§ c . g(n) for a positive constant c."}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Write one formula/equation mentioned in the notes (as written).", "gold_answer": "f(n) = Œ∏ (g(n)) if and only if f(n) ‚â§ c1 . g(n) and f(n) ‚â• c2 . g(n)  ‚àÄ n ‚â•  n0 such that there exists three positive constant c1 > 0, c2 > 0 and n0 ‚â• 1", "gold_evidence": "[p2:c1] Asymptotic Notations\nŒ∏-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = Œ∏ (g(n)) if and only if\nf(n) ‚â§ c1 . g(n) and f(n) ‚â• c2 . g(n)  ‚àÄ n ‚â•  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ‚â• 1\nO-Notation [Pronounced ‚Äúbig -oh‚Äù]\nLet f(n) and g(n) be two positive functions\nf(n) = O(g(n)), if and only iff(n) ‚â§ c . g(‚Ä¶\n[p4:c7] Analogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower tha n\nsome multiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than\nsome multiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of\ng)\n‚óèIf f(n) is o(g(n)) : a < b  (f grows slower than a‚Ä¶\n[p5:c9] Discrete Properties of Asymptotic Notation\nAnalogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower than so me\nmultiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than so me\nmultiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of g)\n‚óèIf f(n)‚Ä¶\n[p3:c5] 10.for (i = 2; i <= n; i++) { // log logn\nfor (j = 1; j <= i; j++) {\nfor (k = 1; k <= n; k +=j) { // n/j ,  where j = 1,2,3,..n\nx = y  + z;\n...\n}\n} T(m) = O(log logn (n logn))\nALGORITHMS\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 02", "draft_gold_evidence": "[p2:c1] Asymptotic Notations\nŒ∏-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = Œ∏ (g(n)) if and only if\nf(n) ‚â§ c1 . g(n) and f(n) ‚â• c2 . g(n)  ‚àÄ n ‚â•  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ‚â• 1\nO-Notation [Pronounced ‚Äúbig -oh‚Äù]\nLet f(n) and g(n) be two positive functions\nf(n) = O(g(n)), if and only iff(n) ‚â§ c . g(‚Ä¶\n[p4:c7] Analogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower tha n\nsome multiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than\nsome multiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of\ng)\n‚óèIf f(n) is o(g(n)) : a < b  (f grows slower than a‚Ä¶\n[p5:c9] Discrete Properties of Asymptotic Notation\nAnalogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower than so me\nmultiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than so me\nmultiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of g)\n‚óèIf f(n)‚Ä¶\n[p3:c5] 10.for (i = 2; i <= n; i++) { // log logn\nfor (j = 1; j <= i; j++) {\nfor (k = 1; k <= n; k +=j) { // n/j ,  where j = 1,2,3,..n\nx = y  + z;\n...\n}\n} T(m) = O(log logn (n logn))\nALGORITHMS\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 02", "draft_gold_answer": "f(n) = Œ∏ (g(n)) if and only if f(n) ‚â§ c1 . g(n) and f(n) ‚â• c2 . g(n)  ‚àÄ n ‚â•  n0 such that there exists three positive constant c1 > 0, c2 > 0 and n0 ‚â• 1"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List the steps of one algorithm/procedure described in the notes.", "gold_answer": "- Determine resource consumption (space, time, cost, register).\n- Divide and conquer: divide the problem, conquer the subproblems, and combine the solutions.\n- For loops: i = 2 to n, j = 1 to i, k = 1 to n with an increment of j.\n- Quick Sort algorithm: best and average case time complexity is O(n log n), worst case is O(n^2).\n- Matrix Multiplication using DAC: T(n) = 8T(n/2) + O(n^2) for n > 1.", "gold_evidence": "[p2:c0] Module 1: Analysis of Algorithm\nAim : The goal of analysis of algorithms is to\ncompare algorithms mainly in terms of running time\nbut also in terms of other factors like memory, developer effort.\nNeed  for Analysis (Why to analyze || What to\nanalyze || How to analyze)\n1.To determine resource consumption\n<resource such that\nspace+time+cost+register>‚Ä¶\n[p3:c5] 10.for (i = 2; i <= n; i++) { // log logn\nfor (j = 1; j <= i; j++) {\nfor (k = 1; k <= n; k +=j) { // n/j ,  where j = 1,2,3,..n\nx = y  + z;\n...\n}\n} T(m) = O(log logn (n logn))\nALGORITHMS\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 02\n[p8:c15] 5.Quick Sort Algorithm\nBest Case / Average CaseT(n) = 1 ; if n = 1.T(n) = 2T(n/2) + n + C, if n>1Time complexity : O(n logn)\nWorst case :  T(n) = n + T(n -1) + C ; if n > 1\nNote: Quick sort behaves in worst case w hen\nelement are already sorted\nTime complexity : O(n^2)6.Matrix Multiplication\nI. Using DAC: T(n) = 8T(n/2)+O(n^2), for n>1\nT(n) = O(n^3‚Ä¶\n[p7:c13] Module 2 : Divide and Conquer (DAC)\nNote : In DAC, divide and conquer is mandatory\nbut combine is optional.\n‚óèAlgorithm DAC(A, 1, n)\n‚óèif(small(1, n)\n‚óèreturn (S(A, 1, n);\n‚óèElse\n‚óèm ‚Üê‚Äì Divide(1, n)\n‚óèS1 ‚Üê‚Äì DAC(A, 1, m)\n‚óèS2 ‚Üê‚Äì DAC(A, m+1, n)\n‚óèCombine (S1, S2);\nTime Complexity for DAC Problem\nT(n) = F(n), if n is small, T(n) = 2T(n/2) + g(n) : if n is lar‚Ä¶", "draft_gold_evidence": "[p2:c0] Module 1: Analysis of Algorithm\nAim : The goal of analysis of algorithms is to\ncompare algorithms mainly in terms of running time\nbut also in terms of other factors like memory, developer effort.\nNeed  for Analysis (Why to analyze || What to\nanalyze || How to analyze)\n1.To determine resource consumption\n<resource such that\nspace+time+cost+register>‚Ä¶\n[p3:c5] 10.for (i = 2; i <= n; i++) { // log logn\nfor (j = 1; j <= i; j++) {\nfor (k = 1; k <= n; k +=j) { // n/j ,  where j = 1,2,3,..n\nx = y  + z;\n...\n}\n} T(m) = O(log logn (n logn))\nALGORITHMS\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 02\n[p8:c15] 5.Quick Sort Algorithm\nBest Case / Average CaseT(n) = 1 ; if n = 1.T(n) = 2T(n/2) + n + C, if n>1Time complexity : O(n logn)\nWorst case :  T(n) = n + T(n -1) + C ; if n > 1\nNote: Quick sort behaves in worst case w hen\nelement are already sorted\nTime complexity : O(n^2)6.Matrix Multiplication\nI. Using DAC: T(n) = 8T(n/2)+O(n^2), for n>1\nT(n) = O(n^3‚Ä¶\n[p7:c13] Module 2 : Divide and Conquer (DAC)\nNote : In DAC, divide and conquer is mandatory\nbut combine is optional.\n‚óèAlgorithm DAC(A, 1, n)\n‚óèif(small(1, n)\n‚óèreturn (S(A, 1, n);\n‚óèElse\n‚óèm ‚Üê‚Äì Divide(1, n)\n‚óèS1 ‚Üê‚Äì DAC(A, 1, m)\n‚óèS2 ‚Üê‚Äì DAC(A, m+1, n)\n‚óèCombine (S1, S2);\nTime Complexity for DAC Problem\nT(n) = F(n), if n is small, T(n) = 2T(n/2) + g(n) : if n is lar‚Ä¶", "draft_gold_answer": "- Determine resource consumption (space, time, cost, register).\n- Divide and conquer: divide the problem, conquer the subproblems, and combine the solutions.\n- For loops: i = 2 to n, j = 1 to i, k = 1 to n with an increment of j.\n- Quick Sort algorithm: best and average case time complexity is O(n log n), worst case is O(n^2).\n- Matrix Multiplication using DAC: T(n) = 8T(n/2) + O(n^2) for n > 1."}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Compare two related concepts/methods mentioned (give at least one difference).", "gold_answer": "Internal sorting and external sorting differ in their memory requirements: internal sorting fits all data into main memory (RAM), while external sorting is used when the data is too large for memory and requires external storage.", "gold_evidence": "[p18:c38] Searching and Sorting\nClassification  Explanation\nInternal vs\nExternal\nsorting  Internal: All data fits into main\nmemory (RAM).\nExternal: Used when data is too large to fit into memory and uses external\nstorage\nComparison\nvs Non -\ncomparison\nBased  Comparison: Sorting is done using\ncomparisons between elements\nNon-comparison: Uses digit -based\nor c‚Ä¶\n[p8:c16] array is a pair(i, j) such that i<j and arr[i] > arr[j])\nTime complexity : O(nlogn)\nSpace complexity : O(n)(due to merges)\n9.Closest pair of points (Find the minimum Euclidea n\ndistance between any two points in a 2D plane.)\nRecurrence relation => T(n) = 2T(n/2)  + O(n)\nTime complexity  = O(nlogn)\nSorting copies (x -sorted, y- sorted): O(n)\nAuxilia‚Ä¶\n[p4:c7] Analogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower tha n\nsome multiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than\nsome multiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of\ng)\n‚óèIf f(n) is o(g(n)) : a < b  (f grows slower than a‚Ä¶\n[p19:c40] 2.N on Comparison based sorting:\nAlgorithm  Time complexity  Stable\nsorting  In\nplace\nsorting  Best Averag\ne Worst\nRadix sort  Œ©(d * (n\n+ k))Œò(d * (n\n+k))O(d * (n\n+ k))Yes  No\nCounting\nsort Œ©(n + k)  Œò(n + k)  O(n +\nk) Yes No\nBucket sort  Œ©(n + k)  Œò(n + k)  O(n¬≤)  Yes(if\nstable\nsort\nused\ninside\nbuckets\n) No\nALGORITHMS\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 17", "draft_gold_evidence": "[p18:c38] Searching and Sorting\nClassification  Explanation\nInternal vs\nExternal\nsorting  Internal: All data fits into main\nmemory (RAM).\nExternal: Used when data is too large to fit into memory and uses external\nstorage\nComparison\nvs Non -\ncomparison\nBased  Comparison: Sorting is done using\ncomparisons between elements\nNon-comparison: Uses digit -based\nor c‚Ä¶\n[p8:c16] array is a pair(i, j) such that i<j and arr[i] > arr[j])\nTime complexity : O(nlogn)\nSpace complexity : O(n)(due to merges)\n9.Closest pair of points (Find the minimum Euclidea n\ndistance between any two points in a 2D plane.)\nRecurrence relation => T(n) = 2T(n/2)  + O(n)\nTime complexity  = O(nlogn)\nSorting copies (x -sorted, y- sorted): O(n)\nAuxilia‚Ä¶\n[p4:c7] Analogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower tha n\nsome multiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than\nsome multiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of\ng)\n‚óèIf f(n) is o(g(n)) : a < b  (f grows slower than a‚Ä¶\n[p19:c40] 2.N on Comparison based sorting:\nAlgorithm  Time complexity  Stable\nsorting  In\nplace\nsorting  Best Averag\ne Worst\nRadix sort  Œ©(d * (n\n+ k))Œò(d * (n\n+k))O(d * (n\n+ k))Yes  No\nCounting\nsort Œ©(n + k)  Œò(n + k)  O(n +\nk) Yes No\nBucket sort  Œ©(n + k)  Œò(n + k)  O(n¬≤)  Yes(if\nstable\nsort\nused\ninside\nbuckets\n) No\nALGORITHMS\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 17", "draft_gold_answer": "Internal sorting and external sorting differ in their memory requirements: internal sorting fits all data into main memory (RAM), while external sorting is used when the data is too large for memory and requires external storage."}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List any assumptions, prerequisites, or constraints mentioned.", "gold_answer": "Not found in the document.", "gold_evidence": "[p3:c5] 10.for (i = 2; i <= n; i++) { // log logn\nfor (j = 1; j <= i; j++) {\nfor (k = 1; k <= n; k +=j) { // n/j ,  where j = 1,2,3,..n\nx = y  + z;\n...\n}\n} T(m) = O(log logn (n logn))\nALGORITHMS\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 02\n[p13:c27] Output : 2 <BC>\nLet, i & j denote indices of x & y. L(i, j) denote th e\nLCS of string x & y , n & m are length respectively.\nL(i, j) = 1 + L(i- 1, j-1) ; if x[i] = y[j]\nL(i, j) = max( L(i -1, j) , L(i , j- 1) ; if x[i] != y[j]\nL(-i, j) = 0\nL(i, -j) = 0\nTime complexity : O(n * m)Space complexity : O(n * m)\n2.0/1 Knapsack problem\nInput  : N items, ea‚Ä¶\n[p11:c21] knapsack until knapsack becomes full arrange arra y\na in ascending order\nTime complexity : O(n log n)\n4.Activity  selection problem  (You are given n\nactivities , each with a start time  and finish time .\nThe goal is to select the maximum number of\nactivities  that can be performed by a single\nperson, under the constraint that the person ca n\nwork‚Ä¶\n[p14:c32] the total expected cost of searches.\nRecurrence relation\ncost(i, j) =\nif j < i ‚Üí return 0\nelse ‚Üí min over k ‚àà [i..j] of:\ncost(i, k -1) + cost(k+1, j) + w(i, j)\nWhere: w(i, j) = sum of p[i..j] + sum of q[i -1..j]\nTime complexity : O(n^3)\nSpace complexity : O(n^2)\n8.Multistage graph\nA multistage graph  is a directed acyclic graph\n(DAG) in which the s‚Ä¶", "draft_gold_evidence": "[p3:c5] 10.for (i = 2; i <= n; i++) { // log logn\nfor (j = 1; j <= i; j++) {\nfor (k = 1; k <= n; k +=j) { // n/j ,  where j = 1,2,3,..n\nx = y  + z;\n...\n}\n} T(m) = O(log logn (n logn))\nALGORITHMS\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 02\n[p13:c27] Output : 2 <BC>\nLet, i & j denote indices of x & y. L(i, j) denote th e\nLCS of string x & y , n & m are length respectively.\nL(i, j) = 1 + L(i- 1, j-1) ; if x[i] = y[j]\nL(i, j) = max( L(i -1, j) , L(i , j- 1) ; if x[i] != y[j]\nL(-i, j) = 0\nL(i, -j) = 0\nTime complexity : O(n * m)Space complexity : O(n * m)\n2.0/1 Knapsack problem\nInput  : N items, ea‚Ä¶\n[p11:c21] knapsack until knapsack becomes full arrange arra y\na in ascending order\nTime complexity : O(n log n)\n4.Activity  selection problem  (You are given n\nactivities , each with a start time  and finish time .\nThe goal is to select the maximum number of\nactivities  that can be performed by a single\nperson, under the constraint that the person ca n\nwork‚Ä¶\n[p14:c32] the total expected cost of searches.\nRecurrence relation\ncost(i, j) =\nif j < i ‚Üí return 0\nelse ‚Üí min over k ‚àà [i..j] of:\ncost(i, k -1) + cost(k+1, j) + w(i, j)\nWhere: w(i, j) = sum of p[i..j] + sum of q[i -1..j]\nTime complexity : O(n^3)\nSpace complexity : O(n^2)\n8.Multistage graph\nA multistage graph  is a directed acyclic graph\n(DAG) in which the s‚Ä¶", "draft_gold_answer": "Not found in the document."}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Give one example mentioned in the notes.", "gold_answer": "Loop for (i = 1; i <= n; i++) {x=y+z;} T(n) = O(n)", "gold_evidence": "[p3:c3] Asymptotic notation does not satisfy trichotomy\nproperty\nex: f(n) = n, g(n) = n * |sin(n)|, n > 0\n‚à¥ These two functions cannot converge\nExample\n1.Loop\nfor ( i = 1; i <= n; i++) {\nx=y+z;\n}\nT(n) = O(n)\n2.Nested loop\nfor(i=1; i<=n; i++){\nfor(j=1; j<=n; j++){\nk= k+1;\n}\nT(n) = O(n2)\n3.Logarithm\nfor(i=1; i<=n ; i *= 2){\nk=k+1;\n}\nfor (int i = 1; i <= n; i‚Ä¶\n[p4:c7] Analogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower tha n\nsome multiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than\nsome multiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of\ng)\n‚óèIf f(n) is o(g(n)) : a < b  (f grows slower than a‚Ä¶\n[p5:c9] Discrete Properties of Asymptotic Notation\nAnalogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower than so me\nmultiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than so me\nmultiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of g)\n‚óèIf f(n)‚Ä¶\n[p2:c1] Asymptotic Notations\nŒ∏-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = Œ∏ (g(n)) if and only if\nf(n) ‚â§ c1 . g(n) and f(n) ‚â• c2 . g(n)  ‚àÄ n ‚â•  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ‚â• 1\nO-Notation [Pronounced ‚Äúbig -oh‚Äù]\nLet f(n) and g(n) be two positive functions\nf(n) = O(g(n)), if and only iff(n) ‚â§ c . g(‚Ä¶", "draft_gold_evidence": "[p3:c3] Asymptotic notation does not satisfy trichotomy\nproperty\nex: f(n) = n, g(n) = n * |sin(n)|, n > 0\n‚à¥ These two functions cannot converge\nExample\n1.Loop\nfor ( i = 1; i <= n; i++) {\nx=y+z;\n}\nT(n) = O(n)\n2.Nested loop\nfor(i=1; i<=n; i++){\nfor(j=1; j<=n; j++){\nk= k+1;\n}\nT(n) = O(n2)\n3.Logarithm\nfor(i=1; i<=n ; i *= 2){\nk=k+1;\n}\nfor (int i = 1; i <= n; i‚Ä¶\n[p4:c7] Analogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower tha n\nsome multiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than\nsome multiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of\ng)\n‚óèIf f(n) is o(g(n)) : a < b  (f grows slower than a‚Ä¶\n[p5:c9] Discrete Properties of Asymptotic Notation\nAnalogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n‚óèIf f(n) is O(g(n)) : a ‚â§ b (f grows slower than so me\nmultiple of g)\n‚óèIf f(n) is Œ© (g(n)) : a ‚â• b (f grows faster than so me\nmultiple of g)\n‚óèIf f(n) is Œò (g(n)) : a = b (f grows at same rate of g)\n‚óèIf f(n)‚Ä¶\n[p2:c1] Asymptotic Notations\nŒ∏-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = Œ∏ (g(n)) if and only if\nf(n) ‚â§ c1 . g(n) and f(n) ‚â• c2 . g(n)  ‚àÄ n ‚â•  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ‚â• 1\nO-Notation [Pronounced ‚Äúbig -oh‚Äù]\nLet f(n) and g(n) be two positive functions\nf(n) = O(g(n)), if and only iff(n) ‚â§ c . g(‚Ä¶", "draft_gold_answer": "Loop for (i = 1; i <= n; i++) {x=y+z;} T(n) = O(n)"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the main topic of these notes?", "gold_answer": "Variable types and memory management in C programming.", "gold_evidence": "[p12:c21] and memory location of variables.\nauto\n‚Ä¢Default for local variables.\n‚Ä¢Scope: Inside block/function.\n‚Ä¢Lifetime: Till the block ends.\nauto int a = 10; // usually just written as int a = 10;\nregister\n1.Stored in CPU registers (if available) for fast er\naccess.\n2.Cannot get the address using & register int\ncounter;register int counter;\nstatic\n‚Ä¢Retains‚Ä¶\n[p11:c19] receives (can be empty)\n4.Function Body ‚Äì The block of code that\nperforms the task\n5.Return Statement ‚Äì (if not void) To send t he\nresul t back to the caller\nC-PROGRAMMING\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 09\n[p19:c34] Feature  Explanation\nUser-defined  Unlike int, char, etc., created\nby the programmer\nHolds multiple\ndata types e.g., int, float,  char [], all\ntogether\nMemory layout  All members stored\ncontiguously in memory\nStruct name is not\nan address Unlike arrays, structure\nnames are not pointers\nCan contain\nnested structures  Yes\ntypedef struct Student {\nint‚Ä¶\n[p17:c30] Summa ry of Key Points\n‚Ä¢Arrays allow changing individual characters ,\ne.g., str [0] = 'H';\n‚Ä¢Pointers may point to string literals, which are\noften read-only\n‚Ä¢You cannot assign a new string to an array\nlike: str = \"new\"; ‚Üí  invalid\n‚Ä¢But with pointers: str = \"new\"; ‚Üí valid\nMemory Behaviour for Strings in C\nRead-Only Memory (String Literals)\n‚Ä¢Strings‚Ä¶", "draft_gold_evidence": "[p12:c21] and memory location of variables.\nauto\n‚Ä¢Default for local variables.\n‚Ä¢Scope: Inside block/function.\n‚Ä¢Lifetime: Till the block ends.\nauto int a = 10; // usually just written as int a = 10;\nregister\n1.Stored in CPU registers (if available) for fast er\naccess.\n2.Cannot get the address using & register int\ncounter;register int counter;\nstatic\n‚Ä¢Retains‚Ä¶\n[p11:c19] receives (can be empty)\n4.Function Body ‚Äì The block of code that\nperforms the task\n5.Return Statement ‚Äì (if not void) To send t he\nresul t back to the caller\nC-PROGRAMMING\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 09\n[p19:c34] Feature  Explanation\nUser-defined  Unlike int, char, etc., created\nby the programmer\nHolds multiple\ndata types e.g., int, float,  char [], all\ntogether\nMemory layout  All members stored\ncontiguously in memory\nStruct name is not\nan address Unlike arrays, structure\nnames are not pointers\nCan contain\nnested structures  Yes\ntypedef struct Student {\nint‚Ä¶\n[p17:c30] Summa ry of Key Points\n‚Ä¢Arrays allow changing individual characters ,\ne.g., str [0] = 'H';\n‚Ä¢Pointers may point to string literals, which are\noften read-only\n‚Ä¢You cannot assign a new string to an array\nlike: str = \"new\"; ‚Üí  invalid\n‚Ä¢But with pointers: str = \"new\"; ‚Üí valid\nMemory Behaviour for Strings in C\nRead-Only Memory (String Literals)\n‚Ä¢Strings‚Ä¶", "draft_gold_answer": "Variable types and memory management in C programming."}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 5 key concepts covered.", "gold_answer": "1. Function Body\n2. Return Statement\n3. Prototype\n4. User-defined\n5. Memory layout", "gold_evidence": "[p11:c19] receives (can be empty)\n4.Function Body ‚Äì The block of code that\nperforms the task\n5.Return Statement ‚Äì (if not void) To send t he\nresul t back to the caller\nC-PROGRAMMING\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 09\n[p11:c18] }\nPrototype:  A function prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n‚Ä¢If you do not specify a return type, the\ndefault return type is considered as int.\n‚Ä¢If the definition or call mismatches‚Ä¶\n[p19:c34] Feature  Explanation\nUser-defined  Unlike int, char, etc., created\nby the programmer\nHolds multiple\ndata types e.g., int, float,  char [], all\ntogether\nMemory layout  All members stored\ncontiguously in memory\nStruct name is not\nan address Unlike arrays, structure\nnames are not pointers\nCan contain\nnested structures  Yes\ntypedef struct Student {\nint‚Ä¶\n[p16:c29] bytes). It does not initialize the memory‚Äîit contains garbage values.\nint *ptr = (int*) malloc (5 * sizeof(int));\ncalloc () ‚Äì Contiguous Allocation\ncalloc (contiguous allocation) allocates memory for an array of elements , initializes all bytes to zero .\nvoid* calloc (size_t num_elements, size_t element_size);\nrealloc () ‚Äì Reallocation\nis used  to‚Ä¶", "draft_gold_evidence": "[p11:c19] receives (can be empty)\n4.Function Body ‚Äì The block of code that\nperforms the task\n5.Return Statement ‚Äì (if not void) To send t he\nresul t back to the caller\nC-PROGRAMMING\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 09\n[p11:c18] }\nPrototype:  A function prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n‚Ä¢If you do not specify a return type, the\ndefault return type is considered as int.\n‚Ä¢If the definition or call mismatches‚Ä¶\n[p19:c34] Feature  Explanation\nUser-defined  Unlike int, char, etc., created\nby the programmer\nHolds multiple\ndata types e.g., int, float,  char [], all\ntogether\nMemory layout  All members stored\ncontiguously in memory\nStruct name is not\nan address Unlike arrays, structure\nnames are not pointers\nCan contain\nnested structures  Yes\ntypedef struct Student {\nint‚Ä¶\n[p16:c29] bytes). It does not initialize the memory‚Äîit contains garbage values.\nint *ptr = (int*) malloc (5 * sizeof(int));\ncalloc () ‚Äì Contiguous Allocation\ncalloc (contiguous allocation) allocates memory for an array of elements , initializes all bytes to zero .\nvoid* calloc (size_t num_elements, size_t element_size);\nrealloc () ‚Äì Reallocation\nis used  to‚Ä¶", "draft_gold_answer": "1. Function Body\n2. Return Statement\n3. Prototype\n4. User-defined\n5. Memory layout"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Define two important terms exactly as stated in the notes.", "gold_answer": "User-defined: Unlike int, char, etc., created by the programmer, holds multiple data types.\nRight Shift Operator (>>): Operates bit-by-bit, converting each 1 to 0 and each 0 to 1.", "gold_evidence": "[p19:c34] Feature  Explanation\nUser-defined  Unlike int, char, etc., created\nby the programmer\nHolds multiple\ndata types e.g., int, float,  char [], all\ntogether\nMemory layout  All members stored\ncontiguously in memory\nStruct name is not\nan address Unlike arrays, structure\nnames are not pointers\nCan contain\nnested structures  Yes\ntypedef struct Student {\nint‚Ä¶\n[p5:c7] Right Shift Operator (>>)\nBitwise NOT Operator ( ~)\nLogical Not (!)  Comma Operator (,)\nIncrement (++) and Decrement ( -)\nPre-Increment / Pre -Increment\nSyntax: x >> n  = x / ( 2ùëõùëõ)\nExample: 8 >> 3\n‚Ä¢8 in binary: 0000 1000\n‚Ä¢8 >> 3 ‚Üí  0000 0001 = 1\nAnother\nmethod:\n8 / 23 = 8 / 8\n= 1\nOperates bit -by-bit.\nConverts each 1 to 0 and\neach 0 to 1.\n~x = -(x‚Ä¶\n[p4:c5] Bitwise Operators\nLogical AND (&&)\n(Expression 1 && expression 2)\nReturns:\n‚Ä¢true (1) if both conditions are true\n‚Ä¢false (0) if either condition is false\nIt has the short circuiting, means if the first operand\noutput is 0 or false then second expression will not be\nevaluated.\nLogical OR ( | | )\n(Expression 1 || expression 2)\nReturns:\n‚Ä¢false (0) if b‚Ä¶\n[p11:c19] receives (can be empty)\n4.Function Body ‚Äì The block of code that\nperforms the task\n5.Return Statement ‚Äì (if not void) To send t he\nresul t back to the caller\nC-PROGRAMMING\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 09", "draft_gold_evidence": "[p19:c34] Feature  Explanation\nUser-defined  Unlike int, char, etc., created\nby the programmer\nHolds multiple\ndata types e.g., int, float,  char [], all\ntogether\nMemory layout  All members stored\ncontiguously in memory\nStruct name is not\nan address Unlike arrays, structure\nnames are not pointers\nCan contain\nnested structures  Yes\ntypedef struct Student {\nint‚Ä¶\n[p5:c7] Right Shift Operator (>>)\nBitwise NOT Operator ( ~)\nLogical Not (!)  Comma Operator (,)\nIncrement (++) and Decrement ( -)\nPre-Increment / Pre -Increment\nSyntax: x >> n  = x / ( 2ùëõùëõ)\nExample: 8 >> 3\n‚Ä¢8 in binary: 0000 1000\n‚Ä¢8 >> 3 ‚Üí  0000 0001 = 1\nAnother\nmethod:\n8 / 23 = 8 / 8\n= 1\nOperates bit -by-bit.\nConverts each 1 to 0 and\neach 0 to 1.\n~x = -(x‚Ä¶\n[p4:c5] Bitwise Operators\nLogical AND (&&)\n(Expression 1 && expression 2)\nReturns:\n‚Ä¢true (1) if both conditions are true\n‚Ä¢false (0) if either condition is false\nIt has the short circuiting, means if the first operand\noutput is 0 or false then second expression will not be\nevaluated.\nLogical OR ( | | )\n(Expression 1 || expression 2)\nReturns:\n‚Ä¢false (0) if b‚Ä¶\n[p11:c19] receives (can be empty)\n4.Function Body ‚Äì The block of code that\nperforms the task\n5.Return Statement ‚Äì (if not void) To send t he\nresul t back to the caller\nC-PROGRAMMING\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 09", "draft_gold_answer": "User-defined: Unlike int, char, etc., created by the programmer, holds multiple data types.\nRight Shift Operator (>>): Operates bit-by-bit, converting each 1 to 0 and each 0 to 1."}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Write one formula/equation mentioned in the notes (as written).", "gold_answer": "x << n = x * (2^n)", "gold_evidence": "[p4:c6] Syntax: x << n  = x * ( 2ùëõùëõ)\nHow It Works\n‚Ä¢Each bit shift to the left multiplies th e\nnumber b y 2.\n‚Ä¢Zeros are added on the right side.\n‚Ä¢Leftmost bits are discarded if overflow\noccurs.\nUse Cases\nNow we have the example: 1 << 3\n‚Ä¢1 = 0000 0001\n‚Ä¢1 << 3 ‚Üí  0000 1000 = 8\nAnother method: 1* 23 = 8.\nC-PROGRAMMING\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 03\n[p5:c8] operator.\n// so, the final value of a=9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increm‚Ä¶\n[p5:c7] Right Shift Operator (>>)\nBitwise NOT Operator ( ~)\nLogical Not (!)  Comma Operator (,)\nIncrement (++) and Decrement ( -)\nPre-Increment / Pre -Increment\nSyntax: x >> n  = x / ( 2ùëõùëõ)\nExample: 8 >> 3\n‚Ä¢8 in binary: 0000 1000\n‚Ä¢8 >> 3 ‚Üí  0000 0001 = 1\nAnother\nmethod:\n8 / 23 = 8 / 8\n= 1\nOperates bit -by-bit.\nConverts each 1 to 0 and\neach 0 to 1.\n~x = -(x‚Ä¶\n[p3:c3] These are floating -point numbers, and they a re\nstored in memory using the IEEE 754 format.\nBecause of this, overflow in floating -point type s\nbehaves differently and does not wrap around.\nHence, avoid relying on cyclic behaviour for float o r\ndouble.\nNegative number will be stored in the 2‚Äôs\ncomplement from in the memory.\nIf the msb is 1 it mean‚Ä¶", "draft_gold_evidence": "[p4:c6] Syntax: x << n  = x * ( 2ùëõùëõ)\nHow It Works\n‚Ä¢Each bit shift to the left multiplies th e\nnumber b y 2.\n‚Ä¢Zeros are added on the right side.\n‚Ä¢Leftmost bits are discarded if overflow\noccurs.\nUse Cases\nNow we have the example: 1 << 3\n‚Ä¢1 = 0000 0001\n‚Ä¢1 << 3 ‚Üí  0000 1000 = 8\nAnother method: 1* 23 = 8.\nC-PROGRAMMING\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 03\n[p5:c8] operator.\n// so, the final value of a=9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increm‚Ä¶\n[p5:c7] Right Shift Operator (>>)\nBitwise NOT Operator ( ~)\nLogical Not (!)  Comma Operator (,)\nIncrement (++) and Decrement ( -)\nPre-Increment / Pre -Increment\nSyntax: x >> n  = x / ( 2ùëõùëõ)\nExample: 8 >> 3\n‚Ä¢8 in binary: 0000 1000\n‚Ä¢8 >> 3 ‚Üí  0000 0001 = 1\nAnother\nmethod:\n8 / 23 = 8 / 8\n= 1\nOperates bit -by-bit.\nConverts each 1 to 0 and\neach 0 to 1.\n~x = -(x‚Ä¶\n[p3:c3] These are floating -point numbers, and they a re\nstored in memory using the IEEE 754 format.\nBecause of this, overflow in floating -point type s\nbehaves differently and does not wrap around.\nHence, avoid relying on cyclic behaviour for float o r\ndouble.\nNegative number will be stored in the 2‚Äôs\ncomplement from in the memory.\nIf the msb is 1 it mean‚Ä¶", "draft_gold_answer": "x << n = x * (2^n)"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List the steps of one algorithm/procedure described in the notes.", "gold_answer": "- Left bit shift: x << n = x * (2^n)\n- Right bit shift: x >> n = x / (2^n)\n- Bitwise NOT: ~x = -(x)", "gold_evidence": "[p4:c6] Syntax: x << n  = x * ( 2ùëõùëõ)\nHow It Works\n‚Ä¢Each bit shift to the left multiplies th e\nnumber b y 2.\n‚Ä¢Zeros are added on the right side.\n‚Ä¢Leftmost bits are discarded if overflow\noccurs.\nUse Cases\nNow we have the example: 1 << 3\n‚Ä¢1 = 0000 0001\n‚Ä¢1 << 3 ‚Üí  0000 1000 = 8\nAnother method: 1* 23 = 8.\nC-PROGRAMMING\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 03\n[p11:c19] receives (can be empty)\n4.Function Body ‚Äì The block of code that\nperforms the task\n5.Return Statement ‚Äì (if not void) To send t he\nresul t back to the caller\nC-PROGRAMMING\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 09\n[p5:c8] operator.\n// so, the final value of a=9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increm‚Ä¶\n[p5:c7] Right Shift Operator (>>)\nBitwise NOT Operator ( ~)\nLogical Not (!)  Comma Operator (,)\nIncrement (++) and Decrement ( -)\nPre-Increment / Pre -Increment\nSyntax: x >> n  = x / ( 2ùëõùëõ)\nExample: 8 >> 3\n‚Ä¢8 in binary: 0000 1000\n‚Ä¢8 >> 3 ‚Üí  0000 0001 = 1\nAnother\nmethod:\n8 / 23 = 8 / 8\n= 1\nOperates bit -by-bit.\nConverts each 1 to 0 and\neach 0 to 1.\n~x = -(x‚Ä¶", "draft_gold_evidence": "[p4:c6] Syntax: x << n  = x * ( 2ùëõùëõ)\nHow It Works\n‚Ä¢Each bit shift to the left multiplies th e\nnumber b y 2.\n‚Ä¢Zeros are added on the right side.\n‚Ä¢Leftmost bits are discarded if overflow\noccurs.\nUse Cases\nNow we have the example: 1 << 3\n‚Ä¢1 = 0000 0001\n‚Ä¢1 << 3 ‚Üí  0000 1000 = 8\nAnother method: 1* 23 = 8.\nC-PROGRAMMING\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 03\n[p11:c19] receives (can be empty)\n4.Function Body ‚Äì The block of code that\nperforms the task\n5.Return Statement ‚Äì (if not void) To send t he\nresul t back to the caller\nC-PROGRAMMING\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 09\n[p5:c8] operator.\n// so, the final value of a=9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increm‚Ä¶\n[p5:c7] Right Shift Operator (>>)\nBitwise NOT Operator ( ~)\nLogical Not (!)  Comma Operator (,)\nIncrement (++) and Decrement ( -)\nPre-Increment / Pre -Increment\nSyntax: x >> n  = x / ( 2ùëõùëõ)\nExample: 8 >> 3\n‚Ä¢8 in binary: 0000 1000\n‚Ä¢8 >> 3 ‚Üí  0000 0001 = 1\nAnother\nmethod:\n8 / 23 = 8 / 8\n= 1\nOperates bit -by-bit.\nConverts each 1 to 0 and\neach 0 to 1.\n~x = -(x‚Ä¶", "draft_gold_answer": "- Left bit shift: x << n = x * (2^n)\n- Right bit shift: x >> n = x / (2^n)\n- Bitwise NOT: ~x = -(x)"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Compare two related concepts/methods mentioned (give at least one difference).", "gold_answer": "Right Shift Operator (>>) and Bitwise NOT Operator (~) differ in their operations: the former shifts bits right, dividing by a power of 2, while the latter inverts each bit, converting 1s to 0s and vice versa.", "gold_evidence": "[p5:c7] Right Shift Operator (>>)\nBitwise NOT Operator ( ~)\nLogical Not (!)  Comma Operator (,)\nIncrement (++) and Decrement ( -)\nPre-Increment / Pre -Increment\nSyntax: x >> n  = x / ( 2ùëõùëõ)\nExample: 8 >> 3\n‚Ä¢8 in binary: 0000 1000\n‚Ä¢8 >> 3 ‚Üí  0000 0001 = 1\nAnother\nmethod:\n8 / 23 = 8 / 8\n= 1\nOperates bit -by-bit.\nConverts each 1 to 0 and\neach 0 to 1.\n~x = -(x‚Ä¶\n[p19:c34] Feature  Explanation\nUser-defined  Unlike int, char, etc., created\nby the programmer\nHolds multiple\ndata types e.g., int, float,  char [], all\ntogether\nMemory layout  All members stored\ncontiguously in memory\nStruct name is not\nan address Unlike arrays, structure\nnames are not pointers\nCan contain\nnested structures  Yes\ntypedef struct Student {\nint‚Ä¶\n[p16:c27] We cannot perform arbitrary pointer arithmetic\nbetween unrelated pointers, but pointer - pointer  is\nvalid when both pointers point to elements of the\nsame array.\nIn this case, the result is the difference in element positions , not in bytes, because the compiler\nautomatically divides the address difference by the size of the data type. int a[10];‚Ä¶\n[p11:c19] receives (can be empty)\n4.Function Body ‚Äì The block of code that\nperforms the task\n5.Return Statement ‚Äì (if not void) To send t he\nresul t back to the caller\nC-PROGRAMMING\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 09", "draft_gold_evidence": "[p5:c7] Right Shift Operator (>>)\nBitwise NOT Operator ( ~)\nLogical Not (!)  Comma Operator (,)\nIncrement (++) and Decrement ( -)\nPre-Increment / Pre -Increment\nSyntax: x >> n  = x / ( 2ùëõùëõ)\nExample: 8 >> 3\n‚Ä¢8 in binary: 0000 1000\n‚Ä¢8 >> 3 ‚Üí  0000 0001 = 1\nAnother\nmethod:\n8 / 23 = 8 / 8\n= 1\nOperates bit -by-bit.\nConverts each 1 to 0 and\neach 0 to 1.\n~x = -(x‚Ä¶\n[p19:c34] Feature  Explanation\nUser-defined  Unlike int, char, etc., created\nby the programmer\nHolds multiple\ndata types e.g., int, float,  char [], all\ntogether\nMemory layout  All members stored\ncontiguously in memory\nStruct name is not\nan address Unlike arrays, structure\nnames are not pointers\nCan contain\nnested structures  Yes\ntypedef struct Student {\nint‚Ä¶\n[p16:c27] We cannot perform arbitrary pointer arithmetic\nbetween unrelated pointers, but pointer - pointer  is\nvalid when both pointers point to elements of the\nsame array.\nIn this case, the result is the difference in element positions , not in bytes, because the compiler\nautomatically divides the address difference by the size of the data type. int a[10];‚Ä¶\n[p11:c19] receives (can be empty)\n4.Function Body ‚Äì The block of code that\nperforms the task\n5.Return Statement ‚Äì (if not void) To send t he\nresul t back to the caller\nC-PROGRAMMING\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 09", "draft_gold_answer": "Right Shift Operator (>>) and Bitwise NOT Operator (~) differ in their operations: the former shifts bits right, dividing by a power of 2, while the latter inverts each bit, converting 1s to 0s and vice versa."}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List any assumptions, prerequisites, or constraints mentioned.", "gold_answer": "- The first condition must be true for the subsequent blocks to be executed.\n- The first dimension's size can be omitted for array initialization.\n- An 'else' statement must be preceded by an 'if' statement.\n- User-defined structures can hold multiple data types and contain nested structures.", "gold_evidence": "[p8:c12] else\nprintf(\"Condition 4: x <= 0\\n\");\nThere is all the blocks condition are true. But we\ncheck first condition which is if(x > 10) and it comes\ntrue then we will not execute to the next level, even\nif the next blocks like else if(x>5), else(x>0) are true.\nValid syntax:\nfor (exp1; exp2; exp3) {\nStatements;\n}\nFlow:  exp1 ‚Üí  exp2? ‚Üí statements ‚Üí exp3‚Ä¶\n[p15:c25] If you initialize the array during declaration, the first\ndimension‚Äôs size can be omitted ‚Äî the compiler\nwill count it automatically.\nint arr [] = {1, 2, 3}; // Size = 3 (automatically)\nint arr [3] = {1, 2, 3}; // Also OK\n‚Ä¢Multidimensional Arrays ‚Üí Only First Dimensio n\nCan Be Omitted\nIn multi -dimensional arrays:\n‚Ä¢You can omit the first dimension‚Ä¶\n[p6:c10] for else.\nYou cannot  write else without if.\nelse {\n// statement;\n} // invalid, compiler give the error of wrong\nsyntax\nIf( )\nStatement;  // expression is mandatory in the if block\nIf(1)    ‚Äì> this is perfect statements\nNote:  In C, if you do not use curly braces {} after an if\nstatement, only the very next single statement is\nconsidered part of th‚Ä¶\n[p19:c34] Feature  Explanation\nUser-defined  Unlike int, char, etc., created\nby the programmer\nHolds multiple\ndata types e.g., int, float,  char [], all\ntogether\nMemory layout  All members stored\ncontiguously in memory\nStruct name is not\nan address Unlike arrays, structure\nnames are not pointers\nCan contain\nnested structures  Yes\ntypedef struct Student {\nint‚Ä¶", "draft_gold_evidence": "[p8:c12] else\nprintf(\"Condition 4: x <= 0\\n\");\nThere is all the blocks condition are true. But we\ncheck first condition which is if(x > 10) and it comes\ntrue then we will not execute to the next level, even\nif the next blocks like else if(x>5), else(x>0) are true.\nValid syntax:\nfor (exp1; exp2; exp3) {\nStatements;\n}\nFlow:  exp1 ‚Üí  exp2? ‚Üí statements ‚Üí exp3‚Ä¶\n[p15:c25] If you initialize the array during declaration, the first\ndimension‚Äôs size can be omitted ‚Äî the compiler\nwill count it automatically.\nint arr [] = {1, 2, 3}; // Size = 3 (automatically)\nint arr [3] = {1, 2, 3}; // Also OK\n‚Ä¢Multidimensional Arrays ‚Üí Only First Dimensio n\nCan Be Omitted\nIn multi -dimensional arrays:\n‚Ä¢You can omit the first dimension‚Ä¶\n[p6:c10] for else.\nYou cannot  write else without if.\nelse {\n// statement;\n} // invalid, compiler give the error of wrong\nsyntax\nIf( )\nStatement;  // expression is mandatory in the if block\nIf(1)    ‚Äì> this is perfect statements\nNote:  In C, if you do not use curly braces {} after an if\nstatement, only the very next single statement is\nconsidered part of th‚Ä¶\n[p19:c34] Feature  Explanation\nUser-defined  Unlike int, char, etc., created\nby the programmer\nHolds multiple\ndata types e.g., int, float,  char [], all\ntogether\nMemory layout  All members stored\ncontiguously in memory\nStruct name is not\nan address Unlike arrays, structure\nnames are not pointers\nCan contain\nnested structures  Yes\ntypedef struct Student {\nint‚Ä¶", "draft_gold_answer": "- The first condition must be true for the subsequent blocks to be executed.\n- The first dimension's size can be omitted for array initialization.\n- An 'else' statement must be preceded by an 'if' statement.\n- User-defined structures can hold multiple data types and contain nested structures."}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Give one example mentioned in the notes.", "gold_answer": "User-defined feature explanation.", "gold_evidence": "[p19:c34] Feature  Explanation\nUser-defined  Unlike int, char, etc., created\nby the programmer\nHolds multiple\ndata types e.g., int, float,  char [], all\ntogether\nMemory layout  All members stored\ncontiguously in memory\nStruct name is not\nan address Unlike arrays, structure\nnames are not pointers\nCan contain\nnested structures  Yes\ntypedef struct Student {\nint‚Ä¶\n[p4:c6] Syntax: x << n  = x * ( 2ùëõùëõ)\nHow It Works\n‚Ä¢Each bit shift to the left multiplies th e\nnumber b y 2.\n‚Ä¢Zeros are added on the right side.\n‚Ä¢Leftmost bits are discarded if overflow\noccurs.\nUse Cases\nNow we have the example: 1 << 3\n‚Ä¢1 = 0000 0001\n‚Ä¢1 << 3 ‚Üí  0000 1000 = 8\nAnother method: 1* 23 = 8.\nC-PROGRAMMING\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 03\n[p5:c7] Right Shift Operator (>>)\nBitwise NOT Operator ( ~)\nLogical Not (!)  Comma Operator (,)\nIncrement (++) and Decrement ( -)\nPre-Increment / Pre -Increment\nSyntax: x >> n  = x / ( 2ùëõùëõ)\nExample: 8 >> 3\n‚Ä¢8 in binary: 0000 1000\n‚Ä¢8 >> 3 ‚Üí  0000 0001 = 1\nAnother\nmethod:\n8 / 23 = 8 / 8\n= 1\nOperates bit -by-bit.\nConverts each 1 to 0 and\neach 0 to 1.\n~x = -(x‚Ä¶\n[p5:c8] operator.\n// so, the final value of a=9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increm‚Ä¶", "draft_gold_evidence": "[p19:c34] Feature  Explanation\nUser-defined  Unlike int, char, etc., created\nby the programmer\nHolds multiple\ndata types e.g., int, float,  char [], all\ntogether\nMemory layout  All members stored\ncontiguously in memory\nStruct name is not\nan address Unlike arrays, structure\nnames are not pointers\nCan contain\nnested structures  Yes\ntypedef struct Student {\nint‚Ä¶\n[p4:c6] Syntax: x << n  = x * ( 2ùëõùëõ)\nHow It Works\n‚Ä¢Each bit shift to the left multiplies th e\nnumber b y 2.\n‚Ä¢Zeros are added on the right side.\n‚Ä¢Leftmost bits are discarded if overflow\noccurs.\nUse Cases\nNow we have the example: 1 << 3\n‚Ä¢1 = 0000 0001\n‚Ä¢1 << 3 ‚Üí  0000 1000 = 8\nAnother method: 1* 23 = 8.\nC-PROGRAMMING\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 03\n[p5:c7] Right Shift Operator (>>)\nBitwise NOT Operator ( ~)\nLogical Not (!)  Comma Operator (,)\nIncrement (++) and Decrement ( -)\nPre-Increment / Pre -Increment\nSyntax: x >> n  = x / ( 2ùëõùëõ)\nExample: 8 >> 3\n‚Ä¢8 in binary: 0000 1000\n‚Ä¢8 >> 3 ‚Üí  0000 0001 = 1\nAnother\nmethod:\n8 / 23 = 8 / 8\n= 1\nOperates bit -by-bit.\nConverts each 1 to 0 and\neach 0 to 1.\n~x = -(x‚Ä¶\n[p5:c8] operator.\n// so, the final value of a=9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increm‚Ä¶", "draft_gold_answer": "User-defined feature explanation."}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the main topic of these notes?", "gold_answer": "Compiler design and code optimization.", "gold_evidence": "[p15:c33] 1. Triple Notation\n‚óèEach row has: (Operator, Arg1, Arg2)\n‚óèResult is position index, not explicitly stored\n‚óèSpace efficient , but time inefficient (hard to\nreorder instructions)\n2. Quad ruple Notation\n‚óèEach row has: (Operator, Arg1, Arg2, Result)\n‚óèResult is explicit, easy to use and reorder\n‚óèTime efficient , but uses more space\n3. Indir ect Triple\n‚óè‚Ä¶\n[p16:c35] A basic block  is a group of 3-address code\ninstructions with:\n‚óèNo jump except at the end\n‚óèNo label (target of jump) except at the\nbeginning\nLead ers (start of each basic block):\n1.First instruction ( i = 1)\n2.Any target of jump ( goto 3  ‚Üí line 3, goto 2\n‚Üíline 2)\n3.Instruction after a jump ( line 10  after line 9)\nIdentified Basic Blocks:\n‚óèLB1 ‚Üí L‚Ä¶\n[p4:c7] ‚óèLiterals ‚Äì values like 5 , \"hello\"\n‚óèPunctuation/Special Symbols ‚Äì like ;, (), {}\nExample: int sum = a + 5;\nTokens in this line:\n1.int, 2. sum, 3.  =, 4. a, 5. +, 6. 5,  7. ;\nTotal tokens = 7\nNote : Spaces are not counted as tokens.\nPage No:- 03\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\n[p17:c36] Control Flow (Edges):\nLB1 ‚Üí LB2\nLB2 ‚Üí LB3\nLB3 ‚Üí LB4\nLB4 ‚Üí LB3 (if j ‚â§ 5)\nLB4 ‚Üí LB5 (else)\nLB5 ‚Üí LB6\nLB6 ‚Üí LB2 (if i < 5)\nThis CFG shows  two loops:\n‚òÖ Inner loop  on j ‚Üí LB3 to LB4 back to LB3\n‚òÖ Outer loop  on i ‚Üí from LB6 to LB2\n6.Code Optimization\nIntroduction :\n‚óèThe main goal is to save time or memory  by\nimproving the code.\n‚óèOptimization is base‚Ä¶", "draft_gold_evidence": "[p15:c33] 1. Triple Notation\n‚óèEach row has: (Operator, Arg1, Arg2)\n‚óèResult is position index, not explicitly stored\n‚óèSpace efficient , but time inefficient (hard to\nreorder instructions)\n2. Quad ruple Notation\n‚óèEach row has: (Operator, Arg1, Arg2, Result)\n‚óèResult is explicit, easy to use and reorder\n‚óèTime efficient , but uses more space\n3. Indir ect Triple\n‚óè‚Ä¶\n[p16:c35] A basic block  is a group of 3-address code\ninstructions with:\n‚óèNo jump except at the end\n‚óèNo label (target of jump) except at the\nbeginning\nLead ers (start of each basic block):\n1.First instruction ( i = 1)\n2.Any target of jump ( goto 3  ‚Üí line 3, goto 2\n‚Üíline 2)\n3.Instruction after a jump ( line 10  after line 9)\nIdentified Basic Blocks:\n‚óèLB1 ‚Üí L‚Ä¶\n[p4:c7] ‚óèLiterals ‚Äì values like 5 , \"hello\"\n‚óèPunctuation/Special Symbols ‚Äì like ;, (), {}\nExample: int sum = a + 5;\nTokens in this line:\n1.int, 2. sum, 3.  =, 4. a, 5. +, 6. 5,  7. ;\nTotal tokens = 7\nNote : Spaces are not counted as tokens.\nPage No:- 03\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\n[p17:c36] Control Flow (Edges):\nLB1 ‚Üí LB2\nLB2 ‚Üí LB3\nLB3 ‚Üí LB4\nLB4 ‚Üí LB3 (if j ‚â§ 5)\nLB4 ‚Üí LB5 (else)\nLB5 ‚Üí LB6\nLB6 ‚Üí LB2 (if i < 5)\nThis CFG shows  two loops:\n‚òÖ Inner loop  on j ‚Üí LB3 to LB4 back to LB3\n‚òÖ Outer loop  on i ‚Üí from LB6 to LB2\n6.Code Optimization\nIntroduction :\n‚óèThe main goal is to save time or memory  by\nimproving the code.\n‚óèOptimization is base‚Ä¶", "draft_gold_answer": "Compiler design and code optimization."}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 5 key concepts covered.", "gold_answer": "1. Compiler design\n2. Analysis phase\n3. Control flow\n4. Code optimization\n5. Lexical analysis", "gold_evidence": "[p2:c1] works from high-level to low- level language.\nThere are two main parts of a compiler:\n1.Analysis Phase\nIn this phase, the source code is checked and an\nintermediate representation is created. Itincludes:\n‚óãLexical Analyzer\n‚ÜíBreaks the source code into tokens\n‚ÜíUses DFA (Deterministic Finite Automaton)\n‚ÜíChecks spelling- like errors (example: wrong\nkey‚Ä¶\n[p17:c36] Control Flow (Edges):\nLB1 ‚Üí LB2\nLB2 ‚Üí LB3\nLB3 ‚Üí LB4\nLB4 ‚Üí LB3 (if j ‚â§ 5)\nLB4 ‚Üí LB5 (else)\nLB5 ‚Üí LB6\nLB6 ‚Üí LB2 (if i < 5)\nThis CFG shows  two loops:\n‚òÖ Inner loop  on j ‚Üí LB3 to LB4 back to LB3\n‚òÖ Outer loop  on i ‚Üí from LB6 to LB2\n6.Code Optimization\nIntroduction :\n‚óèThe main goal is to save time or memory  by\nimproving the code.\n‚óèOptimization is base‚Ä¶\n[p4:c7] ‚óèLiterals ‚Äì values like 5 , \"hello\"\n‚óèPunctuation/Special Symbols ‚Äì like ;, (), {}\nExample: int sum = a + 5;\nTokens in this line:\n1.int, 2. sum, 3.  =, 4. a, 5. +, 6. 5,  7. ;\nTotal tokens = 7\nNote : Spaces are not counted as tokens.\nPage No:- 03\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\n[p14:c31] B.Directed Acyclic Graph (DAG) : Use d to detect\ncommon subexpressions\nC.Control Flow Graph (CFG) : Shows how control\nflows between basic blocks\nExample: Expression :   (y + z) * (y + z)   Represent this in all\nform\nPage No:- 12\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á", "draft_gold_evidence": "[p2:c1] works from high-level to low- level language.\nThere are two main parts of a compiler:\n1.Analysis Phase\nIn this phase, the source code is checked and an\nintermediate representation is created. Itincludes:\n‚óãLexical Analyzer\n‚ÜíBreaks the source code into tokens\n‚ÜíUses DFA (Deterministic Finite Automaton)\n‚ÜíChecks spelling- like errors (example: wrong\nkey‚Ä¶\n[p17:c36] Control Flow (Edges):\nLB1 ‚Üí LB2\nLB2 ‚Üí LB3\nLB3 ‚Üí LB4\nLB4 ‚Üí LB3 (if j ‚â§ 5)\nLB4 ‚Üí LB5 (else)\nLB5 ‚Üí LB6\nLB6 ‚Üí LB2 (if i < 5)\nThis CFG shows  two loops:\n‚òÖ Inner loop  on j ‚Üí LB3 to LB4 back to LB3\n‚òÖ Outer loop  on i ‚Üí from LB6 to LB2\n6.Code Optimization\nIntroduction :\n‚óèThe main goal is to save time or memory  by\nimproving the code.\n‚óèOptimization is base‚Ä¶\n[p4:c7] ‚óèLiterals ‚Äì values like 5 , \"hello\"\n‚óèPunctuation/Special Symbols ‚Äì like ;, (), {}\nExample: int sum = a + 5;\nTokens in this line:\n1.int, 2. sum, 3.  =, 4. a, 5. +, 6. 5,  7. ;\nTotal tokens = 7\nNote : Spaces are not counted as tokens.\nPage No:- 03\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\n[p14:c31] B.Directed Acyclic Graph (DAG) : Use d to detect\ncommon subexpressions\nC.Control Flow Graph (CFG) : Shows how control\nflows between basic blocks\nExample: Expression :   (y + z) * (y + z)   Represent this in all\nform\nPage No:- 12\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á", "draft_gold_answer": "1. Compiler design\n2. Analysis phase\n3. Control flow\n4. Code optimization\n5. Lexical analysis"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Define two important terms exactly as stated in the notes.", "gold_answer": "Literals: values like 5, \"hello\"\nToken: a structured representation of a lexeme, usually as a pair: <token-type, attribute>.", "gold_evidence": "[p4:c7] ‚óèLiterals ‚Äì values like 5 , \"hello\"\n‚óèPunctuation/Special Symbols ‚Äì like ;, (), {}\nExample: int sum = a + 5;\nTokens in this line:\n1.int, 2. sum, 3.  =, 4. a, 5. +, 6. 5,  7. ;\nTotal tokens = 7\nNote : Spaces are not counted as tokens.\nPage No:- 03\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\n[p13:c27] values for mathemat ical expressions.\n‚òÖ An annotated parse tree  shows the attributes for\neach node in the parse tree. This helps us\nunderstand the meaning of the program and theintermediate values at each step.\nAttrib utes:\nIt is of two types.\n1.Inherited Attribute (RHS) : The value of an\ninherited attribute is calculated based on theparent or sib‚Ä¶\n[p15:c33] 1. Triple Notation\n‚óèEach row has: (Operator, Arg1, Arg2)\n‚óèResult is position index, not explicitly stored\n‚óèSpace efficient , but time inefficient (hard to\nreorder instructions)\n2. Quad ruple Notation\n‚óèEach row has: (Operator, Arg1, Arg2, Result)\n‚óèResult is explicit, easy to use and reorder\n‚óèTime efficient , but uses more space\n3. Indir ect Triple\n‚óè‚Ä¶\n[p4:c6] their attributes .\nImportant Definitions\n‚û¢ Lexeme: A sequence of characters in sourcecode that matches a token pattern.\nExample: x, +, 123\n‚û¢ Token : A structured representation of a lexeme,\nusually as a pair:\n<token -type, attribute> .\nExample: <IDENTIFIER, name> , <NUMBER,\nvalue>‚û¢ Attribute : Extra information associated with the\ntoken, such as th‚Ä¶", "draft_gold_evidence": "[p4:c7] ‚óèLiterals ‚Äì values like 5 , \"hello\"\n‚óèPunctuation/Special Symbols ‚Äì like ;, (), {}\nExample: int sum = a + 5;\nTokens in this line:\n1.int, 2. sum, 3.  =, 4. a, 5. +, 6. 5,  7. ;\nTotal tokens = 7\nNote : Spaces are not counted as tokens.\nPage No:- 03\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\n[p13:c27] values for mathemat ical expressions.\n‚òÖ An annotated parse tree  shows the attributes for\neach node in the parse tree. This helps us\nunderstand the meaning of the program and theintermediate values at each step.\nAttrib utes:\nIt is of two types.\n1.Inherited Attribute (RHS) : The value of an\ninherited attribute is calculated based on theparent or sib‚Ä¶\n[p15:c33] 1. Triple Notation\n‚óèEach row has: (Operator, Arg1, Arg2)\n‚óèResult is position index, not explicitly stored\n‚óèSpace efficient , but time inefficient (hard to\nreorder instructions)\n2. Quad ruple Notation\n‚óèEach row has: (Operator, Arg1, Arg2, Result)\n‚óèResult is explicit, easy to use and reorder\n‚óèTime efficient , but uses more space\n3. Indir ect Triple\n‚óè‚Ä¶\n[p4:c6] their attributes .\nImportant Definitions\n‚û¢ Lexeme: A sequence of characters in sourcecode that matches a token pattern.\nExample: x, +, 123\n‚û¢ Token : A structured representation of a lexeme,\nusually as a pair:\n<token -type, attribute> .\nExample: <IDENTIFIER, name> , <NUMBER,\nvalue>‚û¢ Attribute : Extra information associated with the\ntoken, such as th‚Ä¶", "draft_gold_answer": "Literals: values like 5, \"hello\"\nToken: a structured representation of a lexeme, usually as a pair: <token-type, attribute>."}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Write one formula/equation mentioned in the notes (as written).", "gold_answer": "Quadruple Notation: (Operator, Arg1, Arg2, Result)", "gold_evidence": "[p4:c7] ‚óèLiterals ‚Äì values like 5 , \"hello\"\n‚óèPunctuation/Special Symbols ‚Äì like ;, (), {}\nExample: int sum = a + 5;\nTokens in this line:\n1.int, 2. sum, 3.  =, 4. a, 5. +, 6. 5,  7. ;\nTotal tokens = 7\nNote : Spaces are not counted as tokens.\nPage No:- 03\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\n[p15:c33] 1. Triple Notation\n‚óèEach row has: (Operator, Arg1, Arg2)\n‚óèResult is position index, not explicitly stored\n‚óèSpace efficient , but time inefficient (hard to\nreorder instructions)\n2. Quad ruple Notation\n‚óèEach row has: (Operator, Arg1, Arg2, Result)\n‚óèResult is explicit, easy to use and reorder\n‚óèTime efficient , but uses more space\n3. Indir ect Triple\n‚óè‚Ä¶\n[p13:c27] values for mathemat ical expressions.\n‚òÖ An annotated parse tree  shows the attributes for\neach node in the parse tree. This helps us\nunderstand the meaning of the program and theintermediate values at each step.\nAttrib utes:\nIt is of two types.\n1.Inherited Attribute (RHS) : The value of an\ninherited attribute is calculated based on theparent or sib‚Ä¶\n[p6:c12] starts.\n‚óãIt never contains a variable but cancontain the empty string ( Œµ).\n‚óãThe First Set can always be\ndetermined for any variable.\nFollow Set:\n‚óèThe Follow Set contains terminals  and the\nspecial symbol $ (end of input).\n‚óèIt never contains  variab les or the empty\nstring (Œµ).\n‚óèHow to Find the Follow Set:\n1.Include $  in the  follow set  of the\nst‚Ä¶", "draft_gold_evidence": "[p4:c7] ‚óèLiterals ‚Äì values like 5 , \"hello\"\n‚óèPunctuation/Special Symbols ‚Äì like ;, (), {}\nExample: int sum = a + 5;\nTokens in this line:\n1.int, 2. sum, 3.  =, 4. a, 5. +, 6. 5,  7. ;\nTotal tokens = 7\nNote : Spaces are not counted as tokens.\nPage No:- 03\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\n[p15:c33] 1. Triple Notation\n‚óèEach row has: (Operator, Arg1, Arg2)\n‚óèResult is position index, not explicitly stored\n‚óèSpace efficient , but time inefficient (hard to\nreorder instructions)\n2. Quad ruple Notation\n‚óèEach row has: (Operator, Arg1, Arg2, Result)\n‚óèResult is explicit, easy to use and reorder\n‚óèTime efficient , but uses more space\n3. Indir ect Triple\n‚óè‚Ä¶\n[p13:c27] values for mathemat ical expressions.\n‚òÖ An annotated parse tree  shows the attributes for\neach node in the parse tree. This helps us\nunderstand the meaning of the program and theintermediate values at each step.\nAttrib utes:\nIt is of two types.\n1.Inherited Attribute (RHS) : The value of an\ninherited attribute is calculated based on theparent or sib‚Ä¶\n[p6:c12] starts.\n‚óãIt never contains a variable but cancontain the empty string ( Œµ).\n‚óãThe First Set can always be\ndetermined for any variable.\nFollow Set:\n‚óèThe Follow Set contains terminals  and the\nspecial symbol $ (end of input).\n‚óèIt never contains  variab les or the empty\nstring (Œµ).\n‚óèHow to Find the Follow Set:\n1.Include $  in the  follow set  of the\nst‚Ä¶", "draft_gold_answer": "Quadruple Notation: (Operator, Arg1, Arg2, Result)"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List the steps of one algorithm/procedure described in the notes.", "gold_answer": "- Code Motion (Frequency Reduction)\n- Induction Variable Elimination\n- Loop Merging/Loop Jamming\n- Loop Unrolling\n- Constant Folding\n- Copy Propagation\n- Strength Reduction\n- Dead Code Elimination\n- Common Sub-expression Elimination\n- Loop Optimization\n- Peephole Optimization", "gold_evidence": "[p18:c39] (i) Co de Motion (Frequency Reduction)\nMove statements that do not change within the\nloop, outside the loop.\n(ii) Induct ion Variable Elimination\nRemove unnecessary induction variables.Example:(iii)Loop Merging / Loop Jamming\nCombine multiple loops with the same range toreduce overhead.Example:\n(iv) L oop Unrolling\nReduce loop control overhead by m‚Ä¶\n[p17:c37] ‚óãCalled Inter-procedural  optimization.Optimization Techniques:\n1.Constant Folding\n2.Copy Propagation\n3.Strength Reduction\n4.Dead Code Elimination\n5.Common Sub-expression Elimination\n6.Loop Optimizati on\n7.Peephole Optimization\nConstant Folding\n‚óèEvaluate constant expressions at compiletime.\nExample:\nx = 2 * 3 + y ‚Üíx = 6 + y (Folding done)\nBut if a‚Ä¶\n[p17:c36] Control Flow (Edges):\nLB1 ‚Üí LB2\nLB2 ‚Üí LB3\nLB3 ‚Üí LB4\nLB4 ‚Üí LB3 (if j ‚â§ 5)\nLB4 ‚Üí LB5 (else)\nLB5 ‚Üí LB6\nLB6 ‚Üí LB2 (if i < 5)\nThis CFG shows  two loops:\n‚òÖ Inner loop  on j ‚Üí LB3 to LB4 back to LB3\n‚òÖ Outer loop  on i ‚Üí from LB6 to LB2\n6.Code Optimization\nIntroduction :\n‚óèThe main goal is to save time or memory  by\nimproving the code.\n‚óèOptimization is base‚Ä¶\n[p15:c33] 1. Triple Notation\n‚óèEach row has: (Operator, Arg1, Arg2)\n‚óèResult is position index, not explicitly stored\n‚óèSpace efficient , but time inefficient (hard to\nreorder instructions)\n2. Quad ruple Notation\n‚óèEach row has: (Operator, Arg1, Arg2, Result)\n‚óèResult is explicit, easy to use and reorder\n‚óèTime efficient , but uses more space\n3. Indir ect Triple\n‚óè‚Ä¶", "draft_gold_evidence": "[p18:c39] (i) Co de Motion (Frequency Reduction)\nMove statements that do not change within the\nloop, outside the loop.\n(ii) Induct ion Variable Elimination\nRemove unnecessary induction variables.Example:(iii)Loop Merging / Loop Jamming\nCombine multiple loops with the same range toreduce overhead.Example:\n(iv) L oop Unrolling\nReduce loop control overhead by m‚Ä¶\n[p17:c37] ‚óãCalled Inter-procedural  optimization.Optimization Techniques:\n1.Constant Folding\n2.Copy Propagation\n3.Strength Reduction\n4.Dead Code Elimination\n5.Common Sub-expression Elimination\n6.Loop Optimizati on\n7.Peephole Optimization\nConstant Folding\n‚óèEvaluate constant expressions at compiletime.\nExample:\nx = 2 * 3 + y ‚Üíx = 6 + y (Folding done)\nBut if a‚Ä¶\n[p17:c36] Control Flow (Edges):\nLB1 ‚Üí LB2\nLB2 ‚Üí LB3\nLB3 ‚Üí LB4\nLB4 ‚Üí LB3 (if j ‚â§ 5)\nLB4 ‚Üí LB5 (else)\nLB5 ‚Üí LB6\nLB6 ‚Üí LB2 (if i < 5)\nThis CFG shows  two loops:\n‚òÖ Inner loop  on j ‚Üí LB3 to LB4 back to LB3\n‚òÖ Outer loop  on i ‚Üí from LB6 to LB2\n6.Code Optimization\nIntroduction :\n‚óèThe main goal is to save time or memory  by\nimproving the code.\n‚óèOptimization is base‚Ä¶\n[p15:c33] 1. Triple Notation\n‚óèEach row has: (Operator, Arg1, Arg2)\n‚óèResult is position index, not explicitly stored\n‚óèSpace efficient , but time inefficient (hard to\nreorder instructions)\n2. Quad ruple Notation\n‚óèEach row has: (Operator, Arg1, Arg2, Result)\n‚óèResult is explicit, easy to use and reorder\n‚óèTime efficient , but uses more space\n3. Indir ect Triple\n‚óè‚Ä¶", "draft_gold_answer": "- Code Motion (Frequency Reduction)\n- Induction Variable Elimination\n- Loop Merging/Loop Jamming\n- Loop Unrolling\n- Constant Folding\n- Copy Propagation\n- Strength Reduction\n- Dead Code Elimination\n- Common Sub-expression Elimination\n- Loop Optimization\n- Peephole Optimization"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Compare two related concepts/methods mentioned (give at least one difference).", "gold_answer": "**Gold Answer:**\n\nConstant Folding and Common Sub-expression Elimination are two optimization techniques. Constant Folding evaluates constant expressions at compile-time, while Common Sub-expression Elimination detects and represents common subexpressions using a Directed Acyclic Graph (DAG).", "gold_evidence": "[p17:c37] ‚óãCalled Inter-procedural  optimization.Optimization Techniques:\n1.Constant Folding\n2.Copy Propagation\n3.Strength Reduction\n4.Dead Code Elimination\n5.Common Sub-expression Elimination\n6.Loop Optimizati on\n7.Peephole Optimization\nConstant Folding\n‚óèEvaluate constant expressions at compiletime.\nExample:\nx = 2 * 3 + y ‚Üíx = 6 + y (Folding done)\nBut if a‚Ä¶\n[p14:c31] B.Directed Acyclic Graph (DAG) : Use d to detect\ncommon subexpressions\nC.Control Flow Graph (CFG) : Shows how control\nflows between basic blocks\nExample: Expression :   (y + z) * (y + z)   Represent this in all\nform\nPage No:- 12\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\n[p17:c36] Control Flow (Edges):\nLB1 ‚Üí LB2\nLB2 ‚Üí LB3\nLB3 ‚Üí LB4\nLB4 ‚Üí LB3 (if j ‚â§ 5)\nLB4 ‚Üí LB5 (else)\nLB5 ‚Üí LB6\nLB6 ‚Üí LB2 (if i < 5)\nThis CFG shows  two loops:\n‚òÖ Inner loop  on j ‚Üí LB3 to LB4 back to LB3\n‚òÖ Outer loop  on i ‚Üí from LB6 to LB2\n6.Code Optimization\nIntroduction :\n‚óèThe main goal is to save time or memory  by\nimproving the code.\n‚óèOptimization is base‚Ä¶\n[p7:c15] ‚òÖ Also called as shift-reduce parser.\n‚òÖ Can be used for ambiguous and\nunambiguous grammars.\n‚òÖ It simulates the reverse of rightmost\nderivation .\n‚òÖ More powerful  than top -down parsing\ntechniques.\n‚òÖ Time complexity: O(n¬≥) in the general case.\nPage No:- 06\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á", "draft_gold_evidence": "[p17:c37] ‚óãCalled Inter-procedural  optimization.Optimization Techniques:\n1.Constant Folding\n2.Copy Propagation\n3.Strength Reduction\n4.Dead Code Elimination\n5.Common Sub-expression Elimination\n6.Loop Optimizati on\n7.Peephole Optimization\nConstant Folding\n‚óèEvaluate constant expressions at compiletime.\nExample:\nx = 2 * 3 + y ‚Üíx = 6 + y (Folding done)\nBut if a‚Ä¶\n[p14:c31] B.Directed Acyclic Graph (DAG) : Use d to detect\ncommon subexpressions\nC.Control Flow Graph (CFG) : Shows how control\nflows between basic blocks\nExample: Expression :   (y + z) * (y + z)   Represent this in all\nform\nPage No:- 12\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\n[p17:c36] Control Flow (Edges):\nLB1 ‚Üí LB2\nLB2 ‚Üí LB3\nLB3 ‚Üí LB4\nLB4 ‚Üí LB3 (if j ‚â§ 5)\nLB4 ‚Üí LB5 (else)\nLB5 ‚Üí LB6\nLB6 ‚Üí LB2 (if i < 5)\nThis CFG shows  two loops:\n‚òÖ Inner loop  on j ‚Üí LB3 to LB4 back to LB3\n‚òÖ Outer loop  on i ‚Üí from LB6 to LB2\n6.Code Optimization\nIntroduction :\n‚óèThe main goal is to save time or memory  by\nimproving the code.\n‚óèOptimization is base‚Ä¶\n[p7:c15] ‚òÖ Also called as shift-reduce parser.\n‚òÖ Can be used for ambiguous and\nunambiguous grammars.\n‚òÖ It simulates the reverse of rightmost\nderivation .\n‚òÖ More powerful  than top -down parsing\ntechniques.\n‚òÖ Time complexity: O(n¬≥) in the general case.\nPage No:- 06\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á", "draft_gold_answer": "**Gold Answer:**\n\nConstant Folding and Common Sub-expression Elimination are two optimization techniques. Constant Folding evaluates constant expressions at compile-time, while Common Sub-expression Elimination detects and represents common subexpressions using a Directed Acyclic Graph (DAG)."}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List any assumptions, prerequisites, or constraints mentioned.", "gold_answer": "- Frequency reduction\n- Unnecessary variables removal\n- Reducing overhead", "gold_evidence": "[p17:c37] ‚óãCalled Inter-procedural  optimization.Optimization Techniques:\n1.Constant Folding\n2.Copy Propagation\n3.Strength Reduction\n4.Dead Code Elimination\n5.Common Sub-expression Elimination\n6.Loop Optimizati on\n7.Peephole Optimization\nConstant Folding\n‚óèEvaluate constant expressions at compiletime.\nExample:\nx = 2 * 3 + y ‚Üíx = 6 + y (Folding done)\nBut if a‚Ä¶\n[p14:c31] B.Directed Acyclic Graph (DAG) : Use d to detect\ncommon subexpressions\nC.Control Flow Graph (CFG) : Shows how control\nflows between basic blocks\nExample: Expression :   (y + z) * (y + z)   Represent this in all\nform\nPage No:- 12\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\n[p18:c39] (i) Co de Motion (Frequency Reduction)\nMove statements that do not change within the\nloop, outside the loop.\n(ii) Induct ion Variable Elimination\nRemove unnecessary induction variables.Example:(iii)Loop Merging / Loop Jamming\nCombine multiple loops with the same range toreduce overhead.Example:\n(iv) L oop Unrolling\nReduce loop control overhead by m‚Ä¶\n[p9:c18] LR(0) Parsing Table Construction:\nWhile creating the parsing table :\n1.If GOTO (I ‚Çñ, a) = I‚±º, set the action as shift: [i,\na] = S‚±º.\n2.If GOTO (I ‚Çñ, A) = I‚±º, set the action as state\nentry : [i, A] = j .\n3.If I·µ¢ contains A ‚Üí Œ±¬∑ (reduced production),\nset the action as reduce : [i, all entries] = R ‚Çö.\nWhere P is the production number  and A ‚Üí\nŒ± is the‚Ä¶", "draft_gold_evidence": "[p17:c37] ‚óãCalled Inter-procedural  optimization.Optimization Techniques:\n1.Constant Folding\n2.Copy Propagation\n3.Strength Reduction\n4.Dead Code Elimination\n5.Common Sub-expression Elimination\n6.Loop Optimizati on\n7.Peephole Optimization\nConstant Folding\n‚óèEvaluate constant expressions at compiletime.\nExample:\nx = 2 * 3 + y ‚Üíx = 6 + y (Folding done)\nBut if a‚Ä¶\n[p14:c31] B.Directed Acyclic Graph (DAG) : Use d to detect\ncommon subexpressions\nC.Control Flow Graph (CFG) : Shows how control\nflows between basic blocks\nExample: Expression :   (y + z) * (y + z)   Represent this in all\nform\nPage No:- 12\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\n[p18:c39] (i) Co de Motion (Frequency Reduction)\nMove statements that do not change within the\nloop, outside the loop.\n(ii) Induct ion Variable Elimination\nRemove unnecessary induction variables.Example:(iii)Loop Merging / Loop Jamming\nCombine multiple loops with the same range toreduce overhead.Example:\n(iv) L oop Unrolling\nReduce loop control overhead by m‚Ä¶\n[p9:c18] LR(0) Parsing Table Construction:\nWhile creating the parsing table :\n1.If GOTO (I ‚Çñ, a) = I‚±º, set the action as shift: [i,\na] = S‚±º.\n2.If GOTO (I ‚Çñ, A) = I‚±º, set the action as state\nentry : [i, A] = j .\n3.If I·µ¢ contains A ‚Üí Œ±¬∑ (reduced production),\nset the action as reduce : [i, all entries] = R ‚Çö.\nWhere P is the production number  and A ‚Üí\nŒ± is the‚Ä¶", "draft_gold_answer": "- Frequency reduction\n- Unnecessary variables removal\n- Reducing overhead"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Give one example mentioned in the notes.", "gold_answer": "Loop Merging / Loop Jamming", "gold_evidence": "[p4:c7] ‚óèLiterals ‚Äì values like 5 , \"hello\"\n‚óèPunctuation/Special Symbols ‚Äì like ;, (), {}\nExample: int sum = a + 5;\nTokens in this line:\n1.int, 2. sum, 3.  =, 4. a, 5. +, 6. 5,  7. ;\nTotal tokens = 7\nNote : Spaces are not counted as tokens.\nPage No:- 03\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\n[p15:c33] 1. Triple Notation\n‚óèEach row has: (Operator, Arg1, Arg2)\n‚óèResult is position index, not explicitly stored\n‚óèSpace efficient , but time inefficient (hard to\nreorder instructions)\n2. Quad ruple Notation\n‚óèEach row has: (Operator, Arg1, Arg2, Result)\n‚óèResult is explicit, easy to use and reorder\n‚óèTime efficient , but uses more space\n3. Indir ect Triple\n‚óè‚Ä¶\n[p18:c39] (i) Co de Motion (Frequency Reduction)\nMove statements that do not change within the\nloop, outside the loop.\n(ii) Induct ion Variable Elimination\nRemove unnecessary induction variables.Example:(iii)Loop Merging / Loop Jamming\nCombine multiple loops with the same range toreduce overhead.Example:\n(iv) L oop Unrolling\nReduce loop control overhead by m‚Ä¶\n[p14:c31] B.Directed Acyclic Graph (DAG) : Use d to detect\ncommon subexpressions\nC.Control Flow Graph (CFG) : Shows how control\nflows between basic blocks\nExample: Expression :   (y + z) * (y + z)   Represent this in all\nform\nPage No:- 12\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á", "draft_gold_evidence": "[p4:c7] ‚óèLiterals ‚Äì values like 5 , \"hello\"\n‚óèPunctuation/Special Symbols ‚Äì like ;, (), {}\nExample: int sum = a + 5;\nTokens in this line:\n1.int, 2. sum, 3.  =, 4. a, 5. +, 6. 5,  7. ;\nTotal tokens = 7\nNote : Spaces are not counted as tokens.\nPage No:- 03\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\n[p15:c33] 1. Triple Notation\n‚óèEach row has: (Operator, Arg1, Arg2)\n‚óèResult is position index, not explicitly stored\n‚óèSpace efficient , but time inefficient (hard to\nreorder instructions)\n2. Quad ruple Notation\n‚óèEach row has: (Operator, Arg1, Arg2, Result)\n‚óèResult is explicit, easy to use and reorder\n‚óèTime efficient , but uses more space\n3. Indir ect Triple\n‚óè‚Ä¶\n[p18:c39] (i) Co de Motion (Frequency Reduction)\nMove statements that do not change within the\nloop, outside the loop.\n(ii) Induct ion Variable Elimination\nRemove unnecessary induction variables.Example:(iii)Loop Merging / Loop Jamming\nCombine multiple loops with the same range toreduce overhead.Example:\n(iv) L oop Unrolling\nReduce loop control overhead by m‚Ä¶\n[p14:c31] B.Directed Acyclic Graph (DAG) : Use d to detect\ncommon subexpressions\nC.Control Flow Graph (CFG) : Shows how control\nflows between basic blocks\nExample: Expression :   (y + z) * (y + z)   Represent this in all\nform\nPage No:- 12\nCOMPILER DESIGN\nGATE ‡§´‡§∞‡•ç‡§∞‡•á", "draft_gold_answer": "Loop Merging / Loop Jamming"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the main topic of these notes?", "gold_answer": "Memory and its various aspects.", "gold_evidence": "[p3:c2] 03. Acc umulator\nTemporary storage location for arithmetic &logical operations\n04. MAR\nWorks with the memory bus to fetch/store\ndata at a specific address.\n05. MDRa.Temporarily holds data being transferred\nto/from memory. Contents of MBR are\ndirectly connected to the data bus.\nb. Acts as a buffer between CPU and\nmemory.\n1.2.2.  Memory\n‚óèMain/Primary‚Ä¶\n[p20:c39] 1.Memory Access Rate = 1/cycle time\n2.Multiplication table for 2, n -bit unsign ed\nnumber = 22n * 2n bits\n3.Addition table for 2, n -bit unsign ed\nnumber = 22n * (n + 1) bits\n5.5. Locality Principles\n5.5.1. Temporal Locality: Recently\naccessed data likely to be reused soon.\n5.5.2. Spatial Locality: Data near recently accessed addresses likely to be‚Ä¶\n[p6:c10] ‚óèRegister Indirect Mode\n‚óèImmediate Mode\n‚óèAutoincrement or AutodecrementMode\n‚óèDirect Addressing Mode/Absolut e\nAddressing Mode\n‚óèRelative Address Mode\n‚óèIndirect Address Mode\n‚óèIndexed Addressing Mode\n‚óèRegister Mode\n‚óèBase Register Addressing Mode\n2.3.1. Implied Mode\nIn this mode the operands are specified\nimplicitly in the definition of the instruction‚Ä¶\n[p18:c36] 5.2.1. Sequential Access Memory\n‚óèData is accessed in a fixed linear order.\n‚óèExample: Magnetic tape.\n‚óèUse Case: Archival storage (low cost,\nhigh capacity), not for rando m\nreads/writes.\n5.2.2. Direct Access Memory\n‚óèAllows access to a record by first movin g\nto a general area (track/sector), then\nsequentially to the exact record.\n‚óèExample: Hard dis k‚Ä¶", "draft_gold_evidence": "[p3:c2] 03. Acc umulator\nTemporary storage location for arithmetic &logical operations\n04. MAR\nWorks with the memory bus to fetch/store\ndata at a specific address.\n05. MDRa.Temporarily holds data being transferred\nto/from memory. Contents of MBR are\ndirectly connected to the data bus.\nb. Acts as a buffer between CPU and\nmemory.\n1.2.2.  Memory\n‚óèMain/Primary‚Ä¶\n[p20:c39] 1.Memory Access Rate = 1/cycle time\n2.Multiplication table for 2, n -bit unsign ed\nnumber = 22n * 2n bits\n3.Addition table for 2, n -bit unsign ed\nnumber = 22n * (n + 1) bits\n5.5. Locality Principles\n5.5.1. Temporal Locality: Recently\naccessed data likely to be reused soon.\n5.5.2. Spatial Locality: Data near recently accessed addresses likely to be‚Ä¶\n[p6:c10] ‚óèRegister Indirect Mode\n‚óèImmediate Mode\n‚óèAutoincrement or AutodecrementMode\n‚óèDirect Addressing Mode/Absolut e\nAddressing Mode\n‚óèRelative Address Mode\n‚óèIndirect Address Mode\n‚óèIndexed Addressing Mode\n‚óèRegister Mode\n‚óèBase Register Addressing Mode\n2.3.1. Implied Mode\nIn this mode the operands are specified\nimplicitly in the definition of the instruction‚Ä¶\n[p18:c36] 5.2.1. Sequential Access Memory\n‚óèData is accessed in a fixed linear order.\n‚óèExample: Magnetic tape.\n‚óèUse Case: Archival storage (low cost,\nhigh capacity), not for rando m\nreads/writes.\n5.2.2. Direct Access Memory\n‚óèAllows access to a record by first movin g\nto a general area (track/sector), then\nsequentially to the exact record.\n‚óèExample: Hard dis k‚Ä¶", "draft_gold_answer": "Memory and its various aspects."}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 5 key concepts covered.", "gold_answer": "1. Sequential Access Memory\n2. Direct Access Memory\n3. Accumulator\n4. Memory Address Registers (MAR)\n5. Memory Data Registers (MDR)", "gold_evidence": "[p18:c36] 5.2.1. Sequential Access Memory\n‚óèData is accessed in a fixed linear order.\n‚óèExample: Magnetic tape.\n‚óèUse Case: Archival storage (low cost,\nhigh capacity), not for rando m\nreads/writes.\n5.2.2. Direct Access Memory\n‚óèAllows access to a record by first movin g\nto a general area (track/sector), then\nsequentially to the exact record.\n‚óèExample: Hard dis k‚Ä¶\n[p3:c2] 03. Acc umulator\nTemporary storage location for arithmetic &logical operations\n04. MAR\nWorks with the memory bus to fetch/store\ndata at a specific address.\n05. MDRa.Temporarily holds data being transferred\nto/from memory. Contents of MBR are\ndirectly connected to the data bus.\nb. Acts as a buffer between CPU and\nmemory.\n1.2.2.  Memory\n‚óèMain/Primary‚Ä¶\n[p12:c22] 1. Implementation\na.Fixed combinational and sequential logic\n(decoders, counters, gating circuits).b.Control signals expressed as Boolean SOP\n(Sum-of -Products) functions of:\n‚ûîControl step counter outputs (T‚ÇÅ, T‚ÇÇ,‚Ä¶).\n‚ûîInstruction register bits (opcode).\n‚ûîCondition codes & external flags (e.g.MFC, interrupt request).\n2.Characteristics\n‚ûîSpeed:  Very‚Ä¶\n[p15:c28] ‚óÜIndex: Selects a cache set or line .\n‚óÜOffset: Chooses the byte/word within\nthe cache line.\n‚ûîMetadata:\n‚óÜValid Bit: Line contains valid data.\n‚óÜDirty Bit: Line has been written (forwrite-back).\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-11", "draft_gold_evidence": "[p18:c36] 5.2.1. Sequential Access Memory\n‚óèData is accessed in a fixed linear order.\n‚óèExample: Magnetic tape.\n‚óèUse Case: Archival storage (low cost,\nhigh capacity), not for rando m\nreads/writes.\n5.2.2. Direct Access Memory\n‚óèAllows access to a record by first movin g\nto a general area (track/sector), then\nsequentially to the exact record.\n‚óèExample: Hard dis k‚Ä¶\n[p3:c2] 03. Acc umulator\nTemporary storage location for arithmetic &logical operations\n04. MAR\nWorks with the memory bus to fetch/store\ndata at a specific address.\n05. MDRa.Temporarily holds data being transferred\nto/from memory. Contents of MBR are\ndirectly connected to the data bus.\nb. Acts as a buffer between CPU and\nmemory.\n1.2.2.  Memory\n‚óèMain/Primary‚Ä¶\n[p12:c22] 1. Implementation\na.Fixed combinational and sequential logic\n(decoders, counters, gating circuits).b.Control signals expressed as Boolean SOP\n(Sum-of -Products) functions of:\n‚ûîControl step counter outputs (T‚ÇÅ, T‚ÇÇ,‚Ä¶).\n‚ûîInstruction register bits (opcode).\n‚ûîCondition codes & external flags (e.g.MFC, interrupt request).\n2.Characteristics\n‚ûîSpeed:  Very‚Ä¶\n[p15:c28] ‚óÜIndex: Selects a cache set or line .\n‚óÜOffset: Chooses the byte/word within\nthe cache line.\n‚ûîMetadata:\n‚óÜValid Bit: Line contains valid data.\n‚óÜDirty Bit: Line has been written (forwrite-back).\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-11", "draft_gold_answer": "1. Sequential Access Memory\n2. Direct Access Memory\n3. Accumulator\n4. Memory Address Registers (MAR)\n5. Memory Data Registers (MDR)"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Define two important terms exactly as stated in the notes.", "gold_answer": "Register Mode: A mode where the operands for an instruction are specified in the registers.\n\nIndirect Mode: A mode where the CPU uses a special flag or instruction to perform lower-priority or non-critical tasks, which cannot be disabled and always get attention.", "gold_evidence": "[p6:c10] ‚óèRegister Indirect Mode\n‚óèImmediate Mode\n‚óèAutoincrement or AutodecrementMode\n‚óèDirect Addressing Mode/Absolut e\nAddressing Mode\n‚óèRelative Address Mode\n‚óèIndirect Address Mode\n‚óèIndexed Addressing Mode\n‚óèRegister Mode\n‚óèBase Register Addressing Mode\n2.3.1. Implied Mode\nIn this mode the operands are specified\nimplicitly in the definition of the instruction‚Ä¶\n[p3:c2] 03. Acc umulator\nTemporary storage location for arithmetic &logical operations\n04. MAR\nWorks with the memory bus to fetch/store\ndata at a specific address.\n05. MDRa.Temporarily holds data being transferred\nto/from memory. Contents of MBR are\ndirectly connected to the data bus.\nb. Acts as a buffer between CPU and\nmemory.\n1.2.2.  Memory\n‚óèMain/Primary‚Ä¶\n[p15:c28] ‚óÜIndex: Selects a cache set or line .\n‚óÜOffset: Chooses the byte/word within\nthe cache line.\n‚ûîMetadata:\n‚óÜValid Bit: Line contains valid data.\n‚óÜDirty Bit: Line has been written (forwrite-back).\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-11\n[p21:c41] by the CPU using a special flag orinstruction.\n‚óèUsed for lower -priority or non -critical\ntasks.\n‚óèEg. INTR in 8085, I/O completion.\n‚óèControlled By: Interrupt Enable/Disabl e\ninstructions (EI, DI)\n5.7.2.4. Non- Maskable Interrupts\n‚óèCannot be disabled by the CPU; always\ngets attention.\n‚óèUsed for critical events (e.g., powerfailure, hardware fault).\n‚óè‚Ä¶", "draft_gold_evidence": "[p6:c10] ‚óèRegister Indirect Mode\n‚óèImmediate Mode\n‚óèAutoincrement or AutodecrementMode\n‚óèDirect Addressing Mode/Absolut e\nAddressing Mode\n‚óèRelative Address Mode\n‚óèIndirect Address Mode\n‚óèIndexed Addressing Mode\n‚óèRegister Mode\n‚óèBase Register Addressing Mode\n2.3.1. Implied Mode\nIn this mode the operands are specified\nimplicitly in the definition of the instruction‚Ä¶\n[p3:c2] 03. Acc umulator\nTemporary storage location for arithmetic &logical operations\n04. MAR\nWorks with the memory bus to fetch/store\ndata at a specific address.\n05. MDRa.Temporarily holds data being transferred\nto/from memory. Contents of MBR are\ndirectly connected to the data bus.\nb. Acts as a buffer between CPU and\nmemory.\n1.2.2.  Memory\n‚óèMain/Primary‚Ä¶\n[p15:c28] ‚óÜIndex: Selects a cache set or line .\n‚óÜOffset: Chooses the byte/word within\nthe cache line.\n‚ûîMetadata:\n‚óÜValid Bit: Line contains valid data.\n‚óÜDirty Bit: Line has been written (forwrite-back).\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-11\n[p21:c41] by the CPU using a special flag orinstruction.\n‚óèUsed for lower -priority or non -critical\ntasks.\n‚óèEg. INTR in 8085, I/O completion.\n‚óèControlled By: Interrupt Enable/Disabl e\ninstructions (EI, DI)\n5.7.2.4. Non- Maskable Interrupts\n‚óèCannot be disabled by the CPU; always\ngets attention.\n‚óèUsed for critical events (e.g., powerfailure, hardware fault).\n‚óè‚Ä¶", "draft_gold_answer": "Register Mode: A mode where the operands for an instruction are specified in the registers.\n\nIndirect Mode: A mode where the CPU uses a special flag or instruction to perform lower-priority or non-critical tasks, which cannot be disabled and always get attention."}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Write one formula/equation mentioned in the notes (as written).", "gold_answer": "X = (A + B) * (C + D)", "gold_evidence": "[p4:c5] performs the operation specified (e.g.,add, subtract, logical AND/OR, shift).\n‚óèAddress Calculation:  For me mory‚Äê\nreference instructions, effective address\nis computed here.\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-02\n[p5:c8] 2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One -Address Instructions\nOne-address instructions use an implied\naccumulator (AC) regi‚Ä¶\n[p13:c25] additions and subtractions are required.\n3.5.3. Key Idea\n‚û¢Exam ine pairs of bits of the multiplier\n(current LSB and an extra ‚Äúprevious ‚Äù\nbit); decide whether to add, subtract, or\ndo nothing with the multiplicand.\n‚û¢Shift right each cycle, accumulating thepartial product in a combined register.\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-10\n[p6:c9] 2.2.4. Zero -Address Instructions\nUsed in stack organised computers with\nPUSH & POP instructions. The following\nprogram shows how\nX = (A + B) * (C + D) will be written\nNote: To evaluate arithmetic expressions in\na stack computer, it is necessary to convert\nthe expression into Reverse Polish notation.\n2.2.5. RISC Instructions\nIt is restricted to LOA‚Ä¶", "draft_gold_evidence": "[p4:c5] performs the operation specified (e.g.,add, subtract, logical AND/OR, shift).\n‚óèAddress Calculation:  For me mory‚Äê\nreference instructions, effective address\nis computed here.\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-02\n[p5:c8] 2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One -Address Instructions\nOne-address instructions use an implied\naccumulator (AC) regi‚Ä¶\n[p13:c25] additions and subtractions are required.\n3.5.3. Key Idea\n‚û¢Exam ine pairs of bits of the multiplier\n(current LSB and an extra ‚Äúprevious ‚Äù\nbit); decide whether to add, subtract, or\ndo nothing with the multiplicand.\n‚û¢Shift right each cycle, accumulating thepartial product in a combined register.\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-10\n[p6:c9] 2.2.4. Zero -Address Instructions\nUsed in stack organised computers with\nPUSH & POP instructions. The following\nprogram shows how\nX = (A + B) * (C + D) will be written\nNote: To evaluate arithmetic expressions in\na stack computer, it is necessary to convert\nthe expression into Reverse Polish notation.\n2.2.5. RISC Instructions\nIt is restricted to LOA‚Ä¶", "draft_gold_answer": "X = (A + B) * (C + D)"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List the steps of one algorithm/procedure described in the notes.", "gold_answer": "- Initialize A = 0, Q = multiplier, Q‚Çã‚ÇÅ = 0, count = n.\n- Repeat until count...", "gold_evidence": "[p5:c8] 2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One -Address Instructions\nOne-address instructions use an implied\naccumulator (AC) regi‚Ä¶\n[p15:c26] 3.5.4. Registers & Initialization\nRegister  Width  Initial Content\nA n-bit 0‚Ä¶0\nQ n-bit Multiplier\nM n-bit Multiplicand\nQ-1 1 bit 0\nn - Number of bits in\nQ and M\nACC = [A (n bits) | Q (n bits) | Q -1(1 bit)]\nstarts as [0‚Ä¶0 | Q initial | 0]\n3.5.5. Step ‚Äëby‚Äë Step Algorithm\n1.Initialize A = 0, Q = multiplier, Q‚Çã ‚ÇÅ  =  0,\ncount = n.\n2.Repeat until count‚Ä¶\n[p13:c24] ‚óèDecoder: None (signals directly driven).\n3.4.4.2. Vertical Microprogrammi ng\n‚óèControl Word: Encoded fields (k -bits select 2·µè\nsignals).\n‚óèWord Width: Narrower, but requiresdecoders.\n‚óèParallelism: Limited (typically one grou p\nexecuted per cycle).\n3.5. Booth‚Äôs Algorithm\n3.5.1. Goal:  Efficie ntly multiply two signed\nbinary integers (tw o‚Äôs-complemen‚Ä¶\n[p4:c5] performs the operation specified (e.g.,add, subtract, logical AND/OR, shift).\n‚óèAddress Calculation:  For me mory‚Äê\nreference instructions, effective address\nis computed here.\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-02", "draft_gold_evidence": "[p5:c8] 2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One -Address Instructions\nOne-address instructions use an implied\naccumulator (AC) regi‚Ä¶\n[p15:c26] 3.5.4. Registers & Initialization\nRegister  Width  Initial Content\nA n-bit 0‚Ä¶0\nQ n-bit Multiplier\nM n-bit Multiplicand\nQ-1 1 bit 0\nn - Number of bits in\nQ and M\nACC = [A (n bits) | Q (n bits) | Q -1(1 bit)]\nstarts as [0‚Ä¶0 | Q initial | 0]\n3.5.5. Step ‚Äëby‚Äë Step Algorithm\n1.Initialize A = 0, Q = multiplier, Q‚Çã ‚ÇÅ  =  0,\ncount = n.\n2.Repeat until count‚Ä¶\n[p13:c24] ‚óèDecoder: None (signals directly driven).\n3.4.4.2. Vertical Microprogrammi ng\n‚óèControl Word: Encoded fields (k -bits select 2·µè\nsignals).\n‚óèWord Width: Narrower, but requiresdecoders.\n‚óèParallelism: Limited (typically one grou p\nexecuted per cycle).\n3.5. Booth‚Äôs Algorithm\n3.5.1. Goal:  Efficie ntly multiply two signed\nbinary integers (tw o‚Äôs-complemen‚Ä¶\n[p4:c5] performs the operation specified (e.g.,add, subtract, logical AND/OR, shift).\n‚óèAddress Calculation:  For me mory‚Äê\nreference instructions, effective address\nis computed here.\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-02", "draft_gold_answer": "- Initialize A = 0, Q = multiplier, Q‚Çã‚ÇÅ = 0, count = n.\n- Repeat until count..."}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Compare two related concepts/methods mentioned (give at least one difference).", "gold_answer": "Direct Access Memory and Sequential Access Memory differ in their data access methods. Direct Access Memory allows for random access to records, first moving to a general area and then sequentially to the exact record, while Sequential Access Memory accesses data in a fixed, linear order.", "gold_evidence": "[p18:c36] 5.2.1. Sequential Access Memory\n‚óèData is accessed in a fixed linear order.\n‚óèExample: Magnetic tape.\n‚óèUse Case: Archival storage (low cost,\nhigh capacity), not for rando m\nreads/writes.\n5.2.2. Direct Access Memory\n‚óèAllows access to a record by first movin g\nto a general area (track/sector), then\nsequentially to the exact record.\n‚óèExample: Hard dis k‚Ä¶\n[p18:c37] 5.2.4. Associative (Content -\nAddressable) Memory\n‚óèRetrieves data by content rather than byspecific address\n‚óèAll words are compared simultaneous ly;\nmatching word(s) are returned.\n‚óèExample: Translation Lookaside Buffer(TLB) in virtual memory.\n‚óèUse Case: Fast lookups (e.g., cache tags,\nTLB), where search key determines th e\nfetch.\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPag‚Ä¶\n[p16:c31] 4.4.3. Fully Associative Mapping\n‚û¢ Number of comparators = Number of blocks i n\ncache\n‚û¢ Size of comparator = Tag-bits\n‚û¢ OR-gate = 1 (number of blocks -input OR gate)\nNote:  Hit Latency Time\n‚û¢ Direct mapping = MUX delay + comparator delay\n‚û¢ Set associative mapping = MUX delay  +\ncomparator delay + OR- gate delay\n‚û¢ Fully ass ociative mapping = compar‚Ä¶\n[p4:c5] performs the operation specified (e.g.,add, subtract, logical AND/OR, shift).\n‚óèAddress Calculation:  For me mory‚Äê\nreference instructions, effective address\nis computed here.\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-02", "draft_gold_evidence": "[p18:c36] 5.2.1. Sequential Access Memory\n‚óèData is accessed in a fixed linear order.\n‚óèExample: Magnetic tape.\n‚óèUse Case: Archival storage (low cost,\nhigh capacity), not for rando m\nreads/writes.\n5.2.2. Direct Access Memory\n‚óèAllows access to a record by first movin g\nto a general area (track/sector), then\nsequentially to the exact record.\n‚óèExample: Hard dis k‚Ä¶\n[p18:c37] 5.2.4. Associative (Content -\nAddressable) Memory\n‚óèRetrieves data by content rather than byspecific address\n‚óèAll words are compared simultaneous ly;\nmatching word(s) are returned.\n‚óèExample: Translation Lookaside Buffer(TLB) in virtual memory.\n‚óèUse Case: Fast lookups (e.g., cache tags,\nTLB), where search key determines th e\nfetch.\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPag‚Ä¶\n[p16:c31] 4.4.3. Fully Associative Mapping\n‚û¢ Number of comparators = Number of blocks i n\ncache\n‚û¢ Size of comparator = Tag-bits\n‚û¢ OR-gate = 1 (number of blocks -input OR gate)\nNote:  Hit Latency Time\n‚û¢ Direct mapping = MUX delay + comparator delay\n‚û¢ Set associative mapping = MUX delay  +\ncomparator delay + OR- gate delay\n‚û¢ Fully ass ociative mapping = compar‚Ä¶\n[p4:c5] performs the operation specified (e.g.,add, subtract, logical AND/OR, shift).\n‚óèAddress Calculation:  For me mory‚Äê\nreference instructions, effective address\nis computed here.\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-02", "draft_gold_answer": "Direct Access Memory and Sequential Access Memory differ in their data access methods. Direct Access Memory allows for random access to records, first moving to a general area and then sequentially to the exact record, while Sequential Access Memory accesses data in a fixed, linear order."}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List any assumptions, prerequisites, or constraints mentioned.", "gold_answer": "Additions, subtractions, and logical operations are prerequisites for the described process.", "gold_evidence": "[p13:c25] additions and subtractions are required.\n3.5.3. Key Idea\n‚û¢Exam ine pairs of bits of the multiplier\n(current LSB and an extra ‚Äúprevious ‚Äù\nbit); decide whether to add, subtract, or\ndo nothing with the multiplicand.\n‚û¢Shift right each cycle, accumulating thepartial product in a combined register.\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-10\n[p4:c5] performs the operation specified (e.g.,add, subtract, logical AND/OR, shift).\n‚óèAddress Calculation:  For me mory‚Äê\nreference instructions, effective address\nis computed here.\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-02\n[p24:c49] Solution of above figure:\nIntroduce bubble/st all cycles  which stalls the\npipeline as in figure besides.\nAt t4, I4 is not allowed to proceed, rather\ndelayed. I t could have been allowed in t5,\nbut again a clash with I2 RW. For the same reason, I4 is not allowed in t6 too. Finally, I4 could be allowed to proceed (stalled) in the pipe only at t7.  S‚Ä¶\n[p25:c52] be solved by register renaming.\n2.WAR is known as Anti -dependency\n3.WAW is known as Output Depe ndency\n4.Operand forwarding and register\nrenaming can not solve the memory\naccess dependencies\n6.6.3. Control hazard\n6.6.3.1. Delayed Branch\nA technique where the instruction immediately following a branch, ‚Äúdelay slot‚Äù is always executed, regardless of‚Ä¶", "draft_gold_evidence": "[p13:c25] additions and subtractions are required.\n3.5.3. Key Idea\n‚û¢Exam ine pairs of bits of the multiplier\n(current LSB and an extra ‚Äúprevious ‚Äù\nbit); decide whether to add, subtract, or\ndo nothing with the multiplicand.\n‚û¢Shift right each cycle, accumulating thepartial product in a combined register.\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-10\n[p4:c5] performs the operation specified (e.g.,add, subtract, logical AND/OR, shift).\n‚óèAddress Calculation:  For me mory‚Äê\nreference instructions, effective address\nis computed here.\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-02\n[p24:c49] Solution of above figure:\nIntroduce bubble/st all cycles  which stalls the\npipeline as in figure besides.\nAt t4, I4 is not allowed to proceed, rather\ndelayed. I t could have been allowed in t5,\nbut again a clash with I2 RW. For the same reason, I4 is not allowed in t6 too. Finally, I4 could be allowed to proceed (stalled) in the pipe only at t7.  S‚Ä¶\n[p25:c52] be solved by register renaming.\n2.WAR is known as Anti -dependency\n3.WAW is known as Output Depe ndency\n4.Operand forwarding and register\nrenaming can not solve the memory\naccess dependencies\n6.6.3. Control hazard\n6.6.3.1. Delayed Branch\nA technique where the instruction immediately following a branch, ‚Äúdelay slot‚Äù is always executed, regardless of‚Ä¶", "draft_gold_answer": "Additions, subtractions, and logical operations are prerequisites for the described process."}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Give one example mentioned in the notes.", "gold_answer": "Example: Magnetic tape.", "gold_evidence": "[p18:c36] 5.2.1. Sequential Access Memory\n‚óèData is accessed in a fixed linear order.\n‚óèExample: Magnetic tape.\n‚óèUse Case: Archival storage (low cost,\nhigh capacity), not for rando m\nreads/writes.\n5.2.2. Direct Access Memory\n‚óèAllows access to a record by first movin g\nto a general area (track/sector), then\nsequentially to the exact record.\n‚óèExample: Hard dis k‚Ä¶\n[p20:c39] 1.Memory Access Rate = 1/cycle time\n2.Multiplication table for 2, n -bit unsign ed\nnumber = 22n * 2n bits\n3.Addition table for 2, n -bit unsign ed\nnumber = 22n * (n + 1) bits\n5.5. Locality Principles\n5.5.1. Temporal Locality: Recently\naccessed data likely to be reused soon.\n5.5.2. Spatial Locality: Data near recently accessed addresses likely to be‚Ä¶\n[p6:c10] ‚óèRegister Indirect Mode\n‚óèImmediate Mode\n‚óèAutoincrement or AutodecrementMode\n‚óèDirect Addressing Mode/Absolut e\nAddressing Mode\n‚óèRelative Address Mode\n‚óèIndirect Address Mode\n‚óèIndexed Addressing Mode\n‚óèRegister Mode\n‚óèBase Register Addressing Mode\n2.3.1. Implied Mode\nIn this mode the operands are specified\nimplicitly in the definition of the instruction‚Ä¶\n[p4:c5] performs the operation specified (e.g.,add, subtract, logical AND/OR, shift).\n‚óèAddress Calculation:  For me mory‚Äê\nreference instructions, effective address\nis computed here.\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-02", "draft_gold_evidence": "[p18:c36] 5.2.1. Sequential Access Memory\n‚óèData is accessed in a fixed linear order.\n‚óèExample: Magnetic tape.\n‚óèUse Case: Archival storage (low cost,\nhigh capacity), not for rando m\nreads/writes.\n5.2.2. Direct Access Memory\n‚óèAllows access to a record by first movin g\nto a general area (track/sector), then\nsequentially to the exact record.\n‚óèExample: Hard dis k‚Ä¶\n[p20:c39] 1.Memory Access Rate = 1/cycle time\n2.Multiplication table for 2, n -bit unsign ed\nnumber = 22n * 2n bits\n3.Addition table for 2, n -bit unsign ed\nnumber = 22n * (n + 1) bits\n5.5. Locality Principles\n5.5.1. Temporal Locality: Recently\naccessed data likely to be reused soon.\n5.5.2. Spatial Locality: Data near recently accessed addresses likely to be‚Ä¶\n[p6:c10] ‚óèRegister Indirect Mode\n‚óèImmediate Mode\n‚óèAutoincrement or AutodecrementMode\n‚óèDirect Addressing Mode/Absolut e\nAddressing Mode\n‚óèRelative Address Mode\n‚óèIndirect Address Mode\n‚óèIndexed Addressing Mode\n‚óèRegister Mode\n‚óèBase Register Addressing Mode\n2.3.1. Implied Mode\nIn this mode the operands are specified\nimplicitly in the definition of the instruction‚Ä¶\n[p4:c5] performs the operation specified (e.g.,add, subtract, logical AND/OR, shift).\n‚óèAddress Calculation:  For me mory‚Äê\nreference instructions, effective address\nis computed here.\nCOA\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:-02", "draft_gold_answer": "Example: Magnetic tape."}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the main topic of these notes?", "gold_answer": "Computer network protocols and their functions.", "gold_evidence": "[p16:c26] 2.ACK (Acknowledgement):\nIndicates whether the acknowledgment number fieldis valid. It‚Äôs used to confirm the receipt of a datasegment.\n3. PSH (Push):\nInstructs the receiver to deliver data to t he\napplication layer immediately  without buffering.\nCOMPUETR NETWORK\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 14\n[p37:c66] Main Functions :\n‚óèAuthentication & Authorization ‚Äì Confi rms\nwho can join the session.\n‚óèSynchronization (Checkpoints) ‚Äì Saves\nsession state, so data can resume from the\nlast point if failure occurs.\n‚óèDialog Control ‚Äì Decides who sends/recei ves\nand for how long.\nPresentation Layer\n‚óèLayer 6 of OSI model.\n‚óèActs a s a translator between application an‚Ä¶\n[p13:c20] Structure:\nP P P D T R C X\n‚óèP = Priority\n‚óèD = Min delay\n‚óèT = Max throughput\n‚óèR = High reliability\n‚óèC = Min cost\nPriority\nIt is a 3 -bit subfield ranging from 0 to 7 (000\nto 111 in binary). Priority field is needed if a\nrouter is congested and need to discard some datagram, those datagrams which have the lowest priority are discarded first.\nTypes of‚Ä¶\n[p37:c67] ‚óèDirectly interacts with the user andapplications.Main Functions :\n‚óèProvides network services to users (e.g. ,\nemail, file transfer, web browsing).\n‚óèSupports applications like Mail services, Fil e\nsharing, etc.\n‚óèGives access to network- based apps (e.g. ,\nbrowser,  FTP client).\n‚óèRepresents what the user sees or uses.\nExamples of Services :\n‚óèEmail (‚Ä¶", "draft_gold_evidence": "[p16:c26] 2.ACK (Acknowledgement):\nIndicates whether the acknowledgment number fieldis valid. It‚Äôs used to confirm the receipt of a datasegment.\n3. PSH (Push):\nInstructs the receiver to deliver data to t he\napplication layer immediately  without buffering.\nCOMPUETR NETWORK\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 14\n[p37:c66] Main Functions :\n‚óèAuthentication & Authorization ‚Äì Confi rms\nwho can join the session.\n‚óèSynchronization (Checkpoints) ‚Äì Saves\nsession state, so data can resume from the\nlast point if failure occurs.\n‚óèDialog Control ‚Äì Decides who sends/recei ves\nand for how long.\nPresentation Layer\n‚óèLayer 6 of OSI model.\n‚óèActs a s a translator between application an‚Ä¶\n[p13:c20] Structure:\nP P P D T R C X\n‚óèP = Priority\n‚óèD = Min delay\n‚óèT = Max throughput\n‚óèR = High reliability\n‚óèC = Min cost\nPriority\nIt is a 3 -bit subfield ranging from 0 to 7 (000\nto 111 in binary). Priority field is needed if a\nrouter is congested and need to discard some datagram, those datagrams which have the lowest priority are discarded first.\nTypes of‚Ä¶\n[p37:c67] ‚óèDirectly interacts with the user andapplications.Main Functions :\n‚óèProvides network services to users (e.g. ,\nemail, file transfer, web browsing).\n‚óèSupports applications like Mail services, Fil e\nsharing, etc.\n‚óèGives access to network- based apps (e.g. ,\nbrowser,  FTP client).\n‚óèRepresents what the user sees or uses.\nExamples of Services :\n‚óèEmail (‚Ä¶", "draft_gold_answer": "Computer network protocols and their functions."}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 5 key concepts covered.", "gold_answer": "1. Authentication and Authorization\n2. Synchronization and Checkpoints\n3. Dialog Control\n4. Congestion Control\n5. Multiplexing and Demultiplexing", "gold_evidence": "[p37:c66] Main Functions :\n‚óèAuthentication & Authorization ‚Äì Confi rms\nwho can join the session.\n‚óèSynchronization (Checkpoints) ‚Äì Saves\nsession state, so data can resume from the\nlast point if failure occurs.\n‚óèDialog Control ‚Äì Decides who sends/recei ves\nand for how long.\nPresentation Layer\n‚óèLayer 6 of OSI model.\n‚óèActs a s a translator between application an‚Ä¶\n[p37:c67] ‚óèDirectly interacts with the user andapplications.Main Functions :\n‚óèProvides network services to users (e.g. ,\nemail, file transfer, web browsing).\n‚óèSupports applications like Mail services, Fil e\nsharing, etc.\n‚óèGives access to network- based apps (e.g. ,\nbrowser,  FTP client).\n‚óèRepresents what the user sees or uses.\nExamples of Services :\n‚óèEmail (‚Ä¶\n[p36:c65] ‚óèCongestion Control ‚Äì Prevents overload i n\nthe network.\n‚óèConnection Control ‚Äì Supports bot h\nconnection-oriented (TCP) and\nconnectionless (UDP) communication.\n‚óèMultiplexing & Demultiplexing ‚Äì Allows\nmultiple applications to use the network atthe same time.\nSession Layer\n‚óèLayer 5 of OSI model.\n‚óèActs as a network dialog controller.\n‚óèStarts, manages,‚Ä¶\n[p39:c69] TCP/IP Model\nThere are 5 layers of the TCP/IP model.\n1.Physical Layer\n2.Data Link Layer\n3.Network Layer\n4.Transport Layer\n5.Application Layer\nPhysical Layer\n‚óèLowest layer of TCP/IP model.\n‚óèDeals with actual transmission of raw bit s\nover physical media (cables, wireless signals).\n‚óèDefines electrical and mechanical\nspecifications like voltage, cable‚Ä¶", "draft_gold_evidence": "[p37:c66] Main Functions :\n‚óèAuthentication & Authorization ‚Äì Confi rms\nwho can join the session.\n‚óèSynchronization (Checkpoints) ‚Äì Saves\nsession state, so data can resume from the\nlast point if failure occurs.\n‚óèDialog Control ‚Äì Decides who sends/recei ves\nand for how long.\nPresentation Layer\n‚óèLayer 6 of OSI model.\n‚óèActs a s a translator between application an‚Ä¶\n[p37:c67] ‚óèDirectly interacts with the user andapplications.Main Functions :\n‚óèProvides network services to users (e.g. ,\nemail, file transfer, web browsing).\n‚óèSupports applications like Mail services, Fil e\nsharing, etc.\n‚óèGives access to network- based apps (e.g. ,\nbrowser,  FTP client).\n‚óèRepresents what the user sees or uses.\nExamples of Services :\n‚óèEmail (‚Ä¶\n[p36:c65] ‚óèCongestion Control ‚Äì Prevents overload i n\nthe network.\n‚óèConnection Control ‚Äì Supports bot h\nconnection-oriented (TCP) and\nconnectionless (UDP) communication.\n‚óèMultiplexing & Demultiplexing ‚Äì Allows\nmultiple applications to use the network atthe same time.\nSession Layer\n‚óèLayer 5 of OSI model.\n‚óèActs as a network dialog controller.\n‚óèStarts, manages,‚Ä¶\n[p39:c69] TCP/IP Model\nThere are 5 layers of the TCP/IP model.\n1.Physical Layer\n2.Data Link Layer\n3.Network Layer\n4.Transport Layer\n5.Application Layer\nPhysical Layer\n‚óèLowest layer of TCP/IP model.\n‚óèDeals with actual transmission of raw bit s\nover physical media (cables, wireless signals).\n‚óèDefines electrical and mechanical\nspecifications like voltage, cable‚Ä¶", "draft_gold_answer": "1. Authentication and Authorization\n2. Synchronization and Checkpoints\n3. Dialog Control\n4. Congestion Control\n5. Multiplexing and Demultiplexing"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Define two important terms exactly as stated in the notes.", "gold_answer": "ACK (Acknowledgement): Indicates the validity of the acknowledgment number field and confirms the receipt of a data segment.\n\nPSH (Push): Instructs the receiver to deliver data to the application layer immediately without buffering.", "gold_evidence": "[p16:c26] 2.ACK (Acknowledgement):\nIndicates whether the acknowledgment number fieldis valid. It‚Äôs used to confirm the receipt of a datasegment.\n3. PSH (Push):\nInstructs the receiver to deliver data to t he\napplication layer immediately  without buffering.\nCOMPUETR NETWORK\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 14\n[p37:c67] ‚óèDirectly interacts with the user andapplications.Main Functions :\n‚óèProvides network services to users (e.g. ,\nemail, file transfer, web browsing).\n‚óèSupports applications like Mail services, Fil e\nsharing, etc.\n‚óèGives access to network- based apps (e.g. ,\nbrowser,  FTP client).\n‚óèRepresents what the user sees or uses.\nExamples of Services :\n‚óèEmail (‚Ä¶\n[p13:c20] Structure:\nP P P D T R C X\n‚óèP = Priority\n‚óèD = Min delay\n‚óèT = Max throughput\n‚óèR = High reliability\n‚óèC = Min cost\nPriority\nIt is a 3 -bit subfield ranging from 0 to 7 (000\nto 111 in binary). Priority field is needed if a\nrouter is congested and need to discard some datagram, those datagrams which have the lowest priority are discarded first.\nTypes of‚Ä¶\n[p39:c70] ‚óèResponsible for logical addressing androuting.\n‚óèDelivers packets from source to destinatio n\nacross multiple networks (routing).\n‚óèMain protocol: IP (IPv4, IPv6).\n‚óèAlso uses ARP, RARP for address mappingand ICMP for error reporting.\n‚óèHandles fragmentation and reassembly ofpackets.\nTransport Layer\n‚óèProvides end -to-end communicatio n\nbetween applica‚Ä¶", "draft_gold_evidence": "[p16:c26] 2.ACK (Acknowledgement):\nIndicates whether the acknowledgment number fieldis valid. It‚Äôs used to confirm the receipt of a datasegment.\n3. PSH (Push):\nInstructs the receiver to deliver data to t he\napplication layer immediately  without buffering.\nCOMPUETR NETWORK\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 14\n[p37:c67] ‚óèDirectly interacts with the user andapplications.Main Functions :\n‚óèProvides network services to users (e.g. ,\nemail, file transfer, web browsing).\n‚óèSupports applications like Mail services, Fil e\nsharing, etc.\n‚óèGives access to network- based apps (e.g. ,\nbrowser,  FTP client).\n‚óèRepresents what the user sees or uses.\nExamples of Services :\n‚óèEmail (‚Ä¶\n[p13:c20] Structure:\nP P P D T R C X\n‚óèP = Priority\n‚óèD = Min delay\n‚óèT = Max throughput\n‚óèR = High reliability\n‚óèC = Min cost\nPriority\nIt is a 3 -bit subfield ranging from 0 to 7 (000\nto 111 in binary). Priority field is needed if a\nrouter is congested and need to discard some datagram, those datagrams which have the lowest priority are discarded first.\nTypes of‚Ä¶\n[p39:c70] ‚óèResponsible for logical addressing androuting.\n‚óèDelivers packets from source to destinatio n\nacross multiple networks (routing).\n‚óèMain protocol: IP (IPv4, IPv6).\n‚óèAlso uses ARP, RARP for address mappingand ICMP for error reporting.\n‚óèHandles fragmentation and reassembly ofpackets.\nTransport Layer\n‚óèProvides end -to-end communicatio n\nbetween applica‚Ä¶", "draft_gold_answer": "ACK (Acknowledgement): Indicates the validity of the acknowledgment number field and confirms the receipt of a data segment.\n\nPSH (Push): Instructs the receiver to deliver data to the application layer immediately without buffering."}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Write one formula/equation mentioned in the notes (as written).", "gold_answer": "2.Determine x^r d(x).", "gold_evidence": "[p7:c10] 2.Determine x^r d(x).\n3.Divide x^r d(x) by g(x) ‚Üí remainder.\n4.Codeword = x^r d(x) + remainder.1. CRC (Cyclic Redundancy Check)\n‚óèDataword:  1001001\n‚óèDivisor (Generator polynomial): 1101 = x¬≥\n+ x¬≤ + 1\n‚óèDataword polynomial: d(x) = x ‚Å∂ + x¬≥ + 1\n‚óèAppend r (degree of divisor = 3) ‚Üí  multipl y\nby x¬≥\n‚Üíx¬≥¬∑d(x) = x‚Åπ + x ‚Å∂ + x¬≥\n‚óèDivide by g(x)  to get remain‚Ä¶\n[p7:c9] 1) Append k‚àí1=3k-1=3k‚àí1=3 zeros to the data\nDividend =1001001000=\n1001001\\ mathbf{000}=1001001000\n2) Long division (XOR when the current bit  is 1)\nDivisor =1101= 1101=1101\nStep @pos0: 1001 ‚äï 1101 = 0000   ‚Üí parti al :\n0000 001000 Step @pos1: 0010 ‚äï 0000 = 0010   ‚Üí (noXOR since leading 0, effectively shift)\nStep @pos1: 0100 ‚äï 1101 = 1001   ‚Üí parti‚Ä¶\n[p7:c11] ‚óèIf 8 bit checksum is used data is divided into8-8 bits group and added ,its 1‚Äôs complement\nis checksum.\n‚óèSender transmits (data + checksum) .\n‚óèReceiver also does same ,if results come tozero then data is correct ..\nCOMPUETR NETWORK\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 06\n[p12:c18] ‚óãCondition to solve:\nWS+WR‚â§ASN\nWhere:\n‚óèWS = Window Size\n‚óèWR = Receiver Window\n‚óèASN = Available Se quence Numbers\nFinal Conditions:\n‚óèGo-Back -N: Receiver window size is always 1\nWS+1‚â§ASN\n‚óèSR: Best condition:\n2WS‚â§ASN\nComparison Table:\nMetric  Stop and\nWait  Go-Back -N\n(GBN)  Selective\nRepeat (SR)\nEfficiency  Œ∑ = Td /\n(Total Time)  Œ∑ = N√óTd  /\n(Total‚Ä¶", "draft_gold_evidence": "[p7:c10] 2.Determine x^r d(x).\n3.Divide x^r d(x) by g(x) ‚Üí remainder.\n4.Codeword = x^r d(x) + remainder.1. CRC (Cyclic Redundancy Check)\n‚óèDataword:  1001001\n‚óèDivisor (Generator polynomial): 1101 = x¬≥\n+ x¬≤ + 1\n‚óèDataword polynomial: d(x) = x ‚Å∂ + x¬≥ + 1\n‚óèAppend r (degree of divisor = 3) ‚Üí  multipl y\nby x¬≥\n‚Üíx¬≥¬∑d(x) = x‚Åπ + x ‚Å∂ + x¬≥\n‚óèDivide by g(x)  to get remain‚Ä¶\n[p7:c9] 1) Append k‚àí1=3k-1=3k‚àí1=3 zeros to the data\nDividend =1001001000=\n1001001\\ mathbf{000}=1001001000\n2) Long division (XOR when the current bit  is 1)\nDivisor =1101= 1101=1101\nStep @pos0: 1001 ‚äï 1101 = 0000   ‚Üí parti al :\n0000 001000 Step @pos1: 0010 ‚äï 0000 = 0010   ‚Üí (noXOR since leading 0, effectively shift)\nStep @pos1: 0100 ‚äï 1101 = 1001   ‚Üí parti‚Ä¶\n[p7:c11] ‚óèIf 8 bit checksum is used data is divided into8-8 bits group and added ,its 1‚Äôs complement\nis checksum.\n‚óèSender transmits (data + checksum) .\n‚óèReceiver also does same ,if results come tozero then data is correct ..\nCOMPUETR NETWORK\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 06\n[p12:c18] ‚óãCondition to solve:\nWS+WR‚â§ASN\nWhere:\n‚óèWS = Window Size\n‚óèWR = Receiver Window\n‚óèASN = Available Se quence Numbers\nFinal Conditions:\n‚óèGo-Back -N: Receiver window size is always 1\nWS+1‚â§ASN\n‚óèSR: Best condition:\n2WS‚â§ASN\nComparison Table:\nMetric  Stop and\nWait  Go-Back -N\n(GBN)  Selective\nRepeat (SR)\nEfficiency  Œ∑ = Td /\n(Total Time)  Œ∑ = N√óTd  /\n(Total‚Ä¶", "draft_gold_answer": "2.Determine x^r d(x)."}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List the steps of one algorithm/procedure described in the notes.", "gold_answer": "1. Append zeros to the data.\n2. Perform long division with XOR.\n3. Determine $x^r d(x)$.\n4. Divide $x^r d(x)$ by $g(x)$ to get the remainder.\n5. Codeword equals $x^r d(x) +$ remainder.", "gold_evidence": "[p12:c18] ‚óãCondition to solve:\nWS+WR‚â§ASN\nWhere:\n‚óèWS = Window Size\n‚óèWR = Receiver Window\n‚óèASN = Available Se quence Numbers\nFinal Conditions:\n‚óèGo-Back -N: Receiver window size is always 1\nWS+1‚â§ASN\n‚óèSR: Best condition:\n2WS‚â§ASN\nComparison Table:\nMetric  Stop and\nWait  Go-Back -N\n(GBN)  Selective\nRepeat (SR)\nEfficiency  Œ∑ = Td /\n(Total Time)  Œ∑ = N√óTd  /\n(Total‚Ä¶\n[p7:c9] 1) Append k‚àí1=3k-1=3k‚àí1=3 zeros to the data\nDividend =1001001000=\n1001001\\ mathbf{000}=1001001000\n2) Long division (XOR when the current bit  is 1)\nDivisor =1101= 1101=1101\nStep @pos0: 1001 ‚äï 1101 = 0000   ‚Üí parti al :\n0000 001000 Step @pos1: 0010 ‚äï 0000 = 0010   ‚Üí (noXOR since leading 0, effectively shift)\nStep @pos1: 0100 ‚äï 1101 = 1001   ‚Üí parti‚Ä¶\n[p18:c30] 4.Timeout Timer\n‚óèStarts after sending TCP segment\n‚óèIf ACK not received in time ‚Üí\nRetransmission\n‚óèTimeout timer = Retransmission Timer\n‚óèShould adapt based on traffic:\n‚óãIncrease if traffic is high\n‚óãDecrease if low traffic\nAlgorithms for Computing Timeout Timer\n1.Basic Algorithm\n2. Jacobson's Algorithm\n3.Karn's Algorithm\nTimeout Timer = 2 √ó RTT\nKarn‚Äôs‚Ä¶\n[p7:c10] 2.Determine x^r d(x).\n3.Divide x^r d(x) by g(x) ‚Üí remainder.\n4.Codeword = x^r d(x) + remainder.1. CRC (Cyclic Redundancy Check)\n‚óèDataword:  1001001\n‚óèDivisor (Generator polynomial): 1101 = x¬≥\n+ x¬≤ + 1\n‚óèDataword polynomial: d(x) = x ‚Å∂ + x¬≥ + 1\n‚óèAppend r (degree of divisor = 3) ‚Üí  multipl y\nby x¬≥\n‚Üíx¬≥¬∑d(x) = x‚Åπ + x ‚Å∂ + x¬≥\n‚óèDivide by g(x)  to get remain‚Ä¶", "draft_gold_evidence": "[p12:c18] ‚óãCondition to solve:\nWS+WR‚â§ASN\nWhere:\n‚óèWS = Window Size\n‚óèWR = Receiver Window\n‚óèASN = Available Se quence Numbers\nFinal Conditions:\n‚óèGo-Back -N: Receiver window size is always 1\nWS+1‚â§ASN\n‚óèSR: Best condition:\n2WS‚â§ASN\nComparison Table:\nMetric  Stop and\nWait  Go-Back -N\n(GBN)  Selective\nRepeat (SR)\nEfficiency  Œ∑ = Td /\n(Total Time)  Œ∑ = N√óTd  /\n(Total‚Ä¶\n[p7:c9] 1) Append k‚àí1=3k-1=3k‚àí1=3 zeros to the data\nDividend =1001001000=\n1001001\\ mathbf{000}=1001001000\n2) Long division (XOR when the current bit  is 1)\nDivisor =1101= 1101=1101\nStep @pos0: 1001 ‚äï 1101 = 0000   ‚Üí parti al :\n0000 001000 Step @pos1: 0010 ‚äï 0000 = 0010   ‚Üí (noXOR since leading 0, effectively shift)\nStep @pos1: 0100 ‚äï 1101 = 1001   ‚Üí parti‚Ä¶\n[p18:c30] 4.Timeout Timer\n‚óèStarts after sending TCP segment\n‚óèIf ACK not received in time ‚Üí\nRetransmission\n‚óèTimeout timer = Retransmission Timer\n‚óèShould adapt based on traffic:\n‚óãIncrease if traffic is high\n‚óãDecrease if low traffic\nAlgorithms for Computing Timeout Timer\n1.Basic Algorithm\n2. Jacobson's Algorithm\n3.Karn's Algorithm\nTimeout Timer = 2 √ó RTT\nKarn‚Äôs‚Ä¶\n[p7:c10] 2.Determine x^r d(x).\n3.Divide x^r d(x) by g(x) ‚Üí remainder.\n4.Codeword = x^r d(x) + remainder.1. CRC (Cyclic Redundancy Check)\n‚óèDataword:  1001001\n‚óèDivisor (Generator polynomial): 1101 = x¬≥\n+ x¬≤ + 1\n‚óèDataword polynomial: d(x) = x ‚Å∂ + x¬≥ + 1\n‚óèAppend r (degree of divisor = 3) ‚Üí  multipl y\nby x¬≥\n‚Üíx¬≥¬∑d(x) = x‚Åπ + x ‚Å∂ + x¬≥\n‚óèDivide by g(x)  to get remain‚Ä¶", "draft_gold_answer": "1. Append zeros to the data.\n2. Perform long division with XOR.\n3. Determine $x^r d(x)$.\n4. Divide $x^r d(x)$ by $g(x)$ to get the remainder.\n5. Codeword equals $x^r d(x) +$ remainder."}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Compare two related concepts/methods mentioned (give at least one difference).", "gold_answer": "**Gold Answer:**\n\nThe main difference between the two concepts, UDP and IMAP, is their connection orientation. UDP is connectionless, while IMAP is connection-oriented. Additionally, UDP has no guarantee of delivery, whereas IMAP allows users to preview and organize emails on the server.", "gold_evidence": "[p40:c72] Replacement  Easy to replace\ntools and\nchange  Harder to replace tools\nReliability  Less reliable  More reliable\nProtocol Example Various protocols for each layer Common\nprotocols like HTTP, FTP, TCP,\nUDP\nError\nHandling  Built into Data\nLink & Transport\nlayers  Built into\nprotocols like\nTCP\nConnection\nOrientation Both\nconnection-oriented and connec‚Ä¶\n[p40:c71] ‚óãUDP (User Datagram Protocol): fast er,\nconnectionless, no guarantee.\n‚óèPerforms flow control, error control ,\nsegmentation and reassembly.\nApplication Layer\n‚óèHighest layer, directly interacts with user\napplications.\n‚óèProvides services like email, file transf er,\nremo te login, web browsing.\n‚óèSupports many protocols:\n‚óãHTTP, FTP, SMTP, DNS, Telnet, P‚Ä¶\n[p33:c59] Compar ison Table of Application Layer\nProtocols.\nComparison Iable of Application Layer Protocols\nFeature  DNS  HTTP  SMTP  POP IMAP  FTP\nStateful / Stateless  Stateless  Stateless  Stateless  Stateful  Stateful  Stateful\nTransport Protocol\nUsed  UDP TCP TCP TCP TCP TCP\nConnectionless/\nOriented  Connectionless  Connectionles\ns Connection\n-orientedC‚Ä¶\n[p30:c55] Limitations:\n‚óèCannot preview mail before downloading ‚Äì\nfull mail must be downloaded first.\n‚óèCannot organize emails on the mail server ‚Äìno folder structure support.\nIMAP4 (Internet Mail Ac cess Protocol v4)\n1.IMAP4 is similar to POP3, but it has mo re\nfeatures, is more powerful, and a bit\ncomplex.\n2.It allows users to:\n‚óãCheck the email header befo r‚Ä¶", "draft_gold_evidence": "[p40:c72] Replacement  Easy to replace\ntools and\nchange  Harder to replace tools\nReliability  Less reliable  More reliable\nProtocol Example Various protocols for each layer Common\nprotocols like HTTP, FTP, TCP,\nUDP\nError\nHandling  Built into Data\nLink & Transport\nlayers  Built into\nprotocols like\nTCP\nConnection\nOrientation Both\nconnection-oriented and connec‚Ä¶\n[p40:c71] ‚óãUDP (User Datagram Protocol): fast er,\nconnectionless, no guarantee.\n‚óèPerforms flow control, error control ,\nsegmentation and reassembly.\nApplication Layer\n‚óèHighest layer, directly interacts with user\napplications.\n‚óèProvides services like email, file transf er,\nremo te login, web browsing.\n‚óèSupports many protocols:\n‚óãHTTP, FTP, SMTP, DNS, Telnet, P‚Ä¶\n[p33:c59] Compar ison Table of Application Layer\nProtocols.\nComparison Iable of Application Layer Protocols\nFeature  DNS  HTTP  SMTP  POP IMAP  FTP\nStateful / Stateless  Stateless  Stateless  Stateless  Stateful  Stateful  Stateful\nTransport Protocol\nUsed  UDP TCP TCP TCP TCP TCP\nConnectionless/\nOriented  Connectionless  Connectionles\ns Connection\n-orientedC‚Ä¶\n[p30:c55] Limitations:\n‚óèCannot preview mail before downloading ‚Äì\nfull mail must be downloaded first.\n‚óèCannot organize emails on the mail server ‚Äìno folder structure support.\nIMAP4 (Internet Mail Ac cess Protocol v4)\n1.IMAP4 is similar to POP3, but it has mo re\nfeatures, is more powerful, and a bit\ncomplex.\n2.It allows users to:\n‚óãCheck the email header befo r‚Ä¶", "draft_gold_answer": "**Gold Answer:**\n\nThe main difference between the two concepts, UDP and IMAP, is their connection orientation. UDP is connectionless, while IMAP is connection-oriented. Additionally, UDP has no guarantee of delivery, whereas IMAP allows users to preview and organize emails on the server."}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List any assumptions, prerequisites, or constraints mentioned.", "gold_answer": "Assumptions: Network changes may affect routing speed.\n\nPrerequisites: Full network map for link state routing.\n\nConstraints: Harder to replace tools for some protocols.", "gold_evidence": "[p15:c23] Not\nChanged  May be Changed  Definitely\nChanged\nVER Total Length  TTL\nServices  MF (More Fragments)  Header\nChecksum\nIdentificatio\nn Number  Fragment Offset\nDF (Don‚Äôt\nFragment)  HL & Options (if present,\nHL may change)\nProtocol\nSource IP\n(SIP)\nDestination\nIP (DIP)\nCOMPUETR NETWORK\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 13\n[p7:c10] 2.Determine x^r d(x).\n3.Divide x^r d(x) by g(x) ‚Üí remainder.\n4.Codeword = x^r d(x) + remainder.1. CRC (Cyclic Redundancy Check)\n‚óèDataword:  1001001\n‚óèDivisor (Generator polynomial): 1101 = x¬≥\n+ x¬≤ + 1\n‚óèDataword polynomial: d(x) = x ‚Å∂ + x¬≥ + 1\n‚óèAppend r (degree of divisor = 3) ‚Üí  multipl y\nby x¬≥\n‚Üíx¬≥¬∑d(x) = x‚Åπ + x ‚Å∂ + x¬≥\n‚óèDivide by g(x)  to get remain‚Ä¶\n[p40:c72] Replacement  Easy to replace\ntools and\nchange  Harder to replace tools\nReliability  Less reliable  More reliable\nProtocol Example Various protocols for each layer Common\nprotocols like HTTP, FTP, TCP,\nUDP\nError\nHandling  Built into Data\nLink & Transport\nlayers  Built into\nprotocols like\nTCP\nConnection\nOrientation Both\nconnection-oriented and connec‚Ä¶\n[p25:c42] neighbors.\n‚óèWorks slowly and takes time to adjust if t he\nnetwork changes.\nb) Link State Routing\n‚óèEach router knows the full map of the\nnetwork.\n‚óèFast and adjusts quickly to network changes.\nCOMPUETR NETWORK\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 22", "draft_gold_evidence": "[p15:c23] Not\nChanged  May be Changed  Definitely\nChanged\nVER Total Length  TTL\nServices  MF (More Fragments)  Header\nChecksum\nIdentificatio\nn Number  Fragment Offset\nDF (Don‚Äôt\nFragment)  HL & Options (if present,\nHL may change)\nProtocol\nSource IP\n(SIP)\nDestination\nIP (DIP)\nCOMPUETR NETWORK\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 13\n[p7:c10] 2.Determine x^r d(x).\n3.Divide x^r d(x) by g(x) ‚Üí remainder.\n4.Codeword = x^r d(x) + remainder.1. CRC (Cyclic Redundancy Check)\n‚óèDataword:  1001001\n‚óèDivisor (Generator polynomial): 1101 = x¬≥\n+ x¬≤ + 1\n‚óèDataword polynomial: d(x) = x ‚Å∂ + x¬≥ + 1\n‚óèAppend r (degree of divisor = 3) ‚Üí  multipl y\nby x¬≥\n‚Üíx¬≥¬∑d(x) = x‚Åπ + x ‚Å∂ + x¬≥\n‚óèDivide by g(x)  to get remain‚Ä¶\n[p40:c72] Replacement  Easy to replace\ntools and\nchange  Harder to replace tools\nReliability  Less reliable  More reliable\nProtocol Example Various protocols for each layer Common\nprotocols like HTTP, FTP, TCP,\nUDP\nError\nHandling  Built into Data\nLink & Transport\nlayers  Built into\nprotocols like\nTCP\nConnection\nOrientation Both\nconnection-oriented and connec‚Ä¶\n[p25:c42] neighbors.\n‚óèWorks slowly and takes time to adjust if t he\nnetwork changes.\nb) Link State Routing\n‚óèEach router knows the full map of the\nnetwork.\n‚óèFast and adjusts quickly to network changes.\nCOMPUETR NETWORK\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 22", "draft_gold_answer": "Assumptions: Network changes may affect routing speed.\n\nPrerequisites: Full network map for link state routing.\n\nConstraints: Harder to replace tools for some protocols."}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Give one example mentioned in the notes.", "gold_answer": "Email.", "gold_evidence": "[p37:c67] ‚óèDirectly interacts with the user andapplications.Main Functions :\n‚óèProvides network services to users (e.g. ,\nemail, file transfer, web browsing).\n‚óèSupports applications like Mail services, Fil e\nsharing, etc.\n‚óèGives access to network- based apps (e.g. ,\nbrowser,  FTP client).\n‚óèRepresents what the user sees or uses.\nExamples of Services :\n‚óèEmail (‚Ä¶\n[p40:c72] Replacement  Easy to replace\ntools and\nchange  Harder to replace tools\nReliability  Less reliable  More reliable\nProtocol Example Various protocols for each layer Common\nprotocols like HTTP, FTP, TCP,\nUDP\nError\nHandling  Built into Data\nLink & Transport\nlayers  Built into\nprotocols like\nTCP\nConnection\nOrientation Both\nconnection-oriented and connec‚Ä¶\n[p16:c26] 2.ACK (Acknowledgement):\nIndicates whether the acknowledgment number fieldis valid. It‚Äôs used to confirm the receipt of a datasegment.\n3. PSH (Push):\nInstructs the receiver to deliver data to t he\napplication layer immediately  without buffering.\nCOMPUETR NETWORK\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 14\n[p15:c23] Not\nChanged  May be Changed  Definitely\nChanged\nVER Total Length  TTL\nServices  MF (More Fragments)  Header\nChecksum\nIdentificatio\nn Number  Fragment Offset\nDF (Don‚Äôt\nFragment)  HL & Options (if present,\nHL may change)\nProtocol\nSource IP\n(SIP)\nDestination\nIP (DIP)\nCOMPUETR NETWORK\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 13", "draft_gold_evidence": "[p37:c67] ‚óèDirectly interacts with the user andapplications.Main Functions :\n‚óèProvides network services to users (e.g. ,\nemail, file transfer, web browsing).\n‚óèSupports applications like Mail services, Fil e\nsharing, etc.\n‚óèGives access to network- based apps (e.g. ,\nbrowser,  FTP client).\n‚óèRepresents what the user sees or uses.\nExamples of Services :\n‚óèEmail (‚Ä¶\n[p40:c72] Replacement  Easy to replace\ntools and\nchange  Harder to replace tools\nReliability  Less reliable  More reliable\nProtocol Example Various protocols for each layer Common\nprotocols like HTTP, FTP, TCP,\nUDP\nError\nHandling  Built into Data\nLink & Transport\nlayers  Built into\nprotocols like\nTCP\nConnection\nOrientation Both\nconnection-oriented and connec‚Ä¶\n[p16:c26] 2.ACK (Acknowledgement):\nIndicates whether the acknowledgment number fieldis valid. It‚Äôs used to confirm the receipt of a datasegment.\n3. PSH (Push):\nInstructs the receiver to deliver data to t he\napplication layer immediately  without buffering.\nCOMPUETR NETWORK\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 14\n[p15:c23] Not\nChanged  May be Changed  Definitely\nChanged\nVER Total Length  TTL\nServices  MF (More Fragments)  Header\nChecksum\nIdentificatio\nn Number  Fragment Offset\nDF (Don‚Äôt\nFragment)  HL & Options (if present,\nHL may change)\nProtocol\nSource IP\n(SIP)\nDestination\nIP (DIP)\nCOMPUETR NETWORK\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 13", "draft_gold_answer": "Email."}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the main topic of these notes?", "gold_answer": "Hashing and collision resolution techniques.", "gold_evidence": "[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( Œª): Œª = n / m\n(n = total el ements, m = table size)\nPerformance‚Ä¶\n[p14:c24] thinking it's not present, even though 24 is at\nindex 5.\n‚Ä¢This happens because deletion breaks t he\nprobing chain, causing search failure.\n‚Ä¢This may require the rehashing.\n‚Ä¢\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (o‚Ä¶\n[p4:c5] ‚Ä¢Undo functionality\n‚Ä¢Backtracking (like maze, Sudoku)\n‚Ä¢Number of possible stack permutations\n= 2ùëõùëõùê∂ùê∂ùëõùëõ\nùëõùëõ+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 03\n[p14:c23] Solves primary clustering\nProblem : May lead to secondary clustering\nCan fail to insert even when space exists if not\ncarefully designed\nIn double hashing h2(k) should not be 0, otherwise it becomes the linear probing.\nDeletion Problem in Open Addressing (Linear,\nQuadratic, Double Hashing)\nIn open addressing , when you delete an element,\nsimply mar‚Ä¶", "draft_gold_evidence": "[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( Œª): Œª = n / m\n(n = total el ements, m = table size)\nPerformance‚Ä¶\n[p14:c24] thinking it's not present, even though 24 is at\nindex 5.\n‚Ä¢This happens because deletion breaks t he\nprobing chain, causing search failure.\n‚Ä¢This may require the rehashing.\n‚Ä¢\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (o‚Ä¶\n[p4:c5] ‚Ä¢Undo functionality\n‚Ä¢Backtracking (like maze, Sudoku)\n‚Ä¢Number of possible stack permutations\n= 2ùëõùëõùê∂ùê∂ùëõùëõ\nùëõùëõ+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 03\n[p14:c23] Solves primary clustering\nProblem : May lead to secondary clustering\nCan fail to insert even when space exists if not\ncarefully designed\nIn double hashing h2(k) should not be 0, otherwise it becomes the linear probing.\nDeletion Problem in Open Addressing (Linear,\nQuadratic, Double Hashing)\nIn open addressing , when you delete an element,\nsimply mar‚Ä¶", "draft_gold_answer": "Hashing and collision resolution techniques."}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 5 key concepts covered.", "gold_answer": "1. Depth-First Search (DFS)\n2. Implementation Methods (Array and Linked List)\n3. Queue (FIFO principle)\n4. Undo functionality and backtracking\n5. Separate chaining (collision resolution)", "gold_evidence": "[p13:c21] Depth -First Search (DFS)\n‚Ä¢Explores as deep as possible\n‚Ä¢Uses stack (explicit or recursion)\n‚Ä¢Backtracks when no unvisited neighbours\nAlgorithm:\n1.Mark current node visited\n2.Recursively visit all unvisited neighbours\nTime Complexity:\n‚Ä¢O (V + E)\nApplications:\n‚Ä¢Topological sorting (DAG)\n‚Ä¢Cycle detection\n‚Ä¢Strongly Connected Component s\n‚Ä¢Maze/path solv‚Ä¶\n[p4:c4] Implementation Methods:\n1.Using Array  (Fixed size, static memory)\n2.Using Linked List  (Dynamic size)Queue\nA Queue  is a linear data structure that follows the\nFIFO  principle:\nFirst In, First Out\nThe first element inserted is the first to be removed.\nReal-World Examples:\n‚Ä¢Ticket line\n‚Ä¢Print queue\nCPU task scheduling  Operation  Description  Time‚Ä¶\n[p14:c24] thinking it's not present, even though 24 is at\nindex 5.\n‚Ä¢This happens because deletion breaks t he\nprobing chain, causing search failure.\n‚Ä¢This may require the rehashing.\n‚Ä¢\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (o‚Ä¶\n[p4:c5] ‚Ä¢Undo functionality\n‚Ä¢Backtracking (like maze, Sudoku)\n‚Ä¢Number of possible stack permutations\n= 2ùëõùëõùê∂ùê∂ùëõùëõ\nùëõùëõ+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 03", "draft_gold_evidence": "[p13:c21] Depth -First Search (DFS)\n‚Ä¢Explores as deep as possible\n‚Ä¢Uses stack (explicit or recursion)\n‚Ä¢Backtracks when no unvisited neighbours\nAlgorithm:\n1.Mark current node visited\n2.Recursively visit all unvisited neighbours\nTime Complexity:\n‚Ä¢O (V + E)\nApplications:\n‚Ä¢Topological sorting (DAG)\n‚Ä¢Cycle detection\n‚Ä¢Strongly Connected Component s\n‚Ä¢Maze/path solv‚Ä¶\n[p4:c4] Implementation Methods:\n1.Using Array  (Fixed size, static memory)\n2.Using Linked List  (Dynamic size)Queue\nA Queue  is a linear data structure that follows the\nFIFO  principle:\nFirst In, First Out\nThe first element inserted is the first to be removed.\nReal-World Examples:\n‚Ä¢Ticket line\n‚Ä¢Print queue\nCPU task scheduling  Operation  Description  Time‚Ä¶\n[p14:c24] thinking it's not present, even though 24 is at\nindex 5.\n‚Ä¢This happens because deletion breaks t he\nprobing chain, causing search failure.\n‚Ä¢This may require the rehashing.\n‚Ä¢\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (o‚Ä¶\n[p4:c5] ‚Ä¢Undo functionality\n‚Ä¢Backtracking (like maze, Sudoku)\n‚Ä¢Number of possible stack permutations\n= 2ùëõùëõùê∂ùê∂ùëõùëõ\nùëõùëõ+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 03", "draft_gold_answer": "1. Depth-First Search (DFS)\n2. Implementation Methods (Array and Linked List)\n3. Queue (FIFO principle)\n4. Undo functionality and backtracking\n5. Separate chaining (collision resolution)"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Define two important terms exactly as stated in the notes.", "gold_answer": "**Graph:** A graph is a collection of vertices (nodes) and edges (connections) that represent relationships between pairs of objects.\n\n**Array:** An array is a collection of homogeneous elements stored in contiguous memory.", "gold_evidence": "[p12:c18] Graph\nA graph  is a collection of vertices (nodes)  and edges\n(connections)  that represent relationships between\npairs of objects.\nG= (V, E)\nWhere:\n‚Ä¢V = set of vertices\n‚Ä¢E = set of edges (unordered pair fo r\nundirected, ordered for directed)Deletion is mostly done at the root node  (i.e.,\nthe max in Max Heap or min in Min Heap).\nSteps:\n1.Remove th‚Ä¶\n[p5:c7] In a circular queue, we connect the rear back to\nfront , forming a circle . Priority queue\nA priority queue is a type of abstract data structure\nin which each element is associated with a priority ,\nand elements are served based on their priority , not\njust insertion order .\nTree data Structure\nA tree is a non -linear , hierarchical data structure‚Ä¶\n[p5:c6] Operation  Description  Time\nComplexity\nenqueue(x)  Insert\nelement x at\nthe rear  O (1) (array\nor LL)\ndequeue()  Remove\nand return\nelement\nfrom front  O (1)\n‚Ä¢Type ‚Ä¢Description\n‚Ä¢Simp le\nQueue‚Ä¢Basic FIFO q ueue\n(insertion at rear, deletio n\nat front)\n‚Ä¢Circular\nQueue‚Ä¢Last position connect s\nback to first (sol ves\noverflow in array)\n‚Ä¢Deque\n(Double-Ende‚Ä¶\n[p2:c0] Array\n‚Ä¢Array : A collection of homogeneous elements\nstored in contiguous memory .\n‚Ä¢Indexing : In C, starts from 0.\nint arr[10]; ‚Üí arr[0] is the first element, arr[9] is\nthe last.\n‚Ä¢Types :\no1D Array: Linear structure, e.g. int a [10];\no2D Array: Matrix -like, e.g. int a [2][3];\nint a[2][3] = { {0,0,0}, {1,1,1} };\noMulti -dimensional: int a [3][2][4]‚Ä¶", "draft_gold_evidence": "[p12:c18] Graph\nA graph  is a collection of vertices (nodes)  and edges\n(connections)  that represent relationships between\npairs of objects.\nG= (V, E)\nWhere:\n‚Ä¢V = set of vertices\n‚Ä¢E = set of edges (unordered pair fo r\nundirected, ordered for directed)Deletion is mostly done at the root node  (i.e.,\nthe max in Max Heap or min in Min Heap).\nSteps:\n1.Remove th‚Ä¶\n[p5:c7] In a circular queue, we connect the rear back to\nfront , forming a circle . Priority queue\nA priority queue is a type of abstract data structure\nin which each element is associated with a priority ,\nand elements are served based on their priority , not\njust insertion order .\nTree data Structure\nA tree is a non -linear , hierarchical data structure‚Ä¶\n[p5:c6] Operation  Description  Time\nComplexity\nenqueue(x)  Insert\nelement x at\nthe rear  O (1) (array\nor LL)\ndequeue()  Remove\nand return\nelement\nfrom front  O (1)\n‚Ä¢Type ‚Ä¢Description\n‚Ä¢Simp le\nQueue‚Ä¢Basic FIFO q ueue\n(insertion at rear, deletio n\nat front)\n‚Ä¢Circular\nQueue‚Ä¢Last position connect s\nback to first (sol ves\noverflow in array)\n‚Ä¢Deque\n(Double-Ende‚Ä¶\n[p2:c0] Array\n‚Ä¢Array : A collection of homogeneous elements\nstored in contiguous memory .\n‚Ä¢Indexing : In C, starts from 0.\nint arr[10]; ‚Üí arr[0] is the first element, arr[9] is\nthe last.\n‚Ä¢Types :\no1D Array: Linear structure, e.g. int a [10];\no2D Array: Matrix -like, e.g. int a [2][3];\nint a[2][3] = { {0,0,0}, {1,1,1} };\noMulti -dimensional: int a [3][2][4]‚Ä¶", "draft_gold_answer": "**Graph:** A graph is a collection of vertices (nodes) and edges (connections) that represent relationships between pairs of objects.\n\n**Array:** An array is a collection of homogeneous elements stored in contiguous memory."}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Write one formula/equation mentioned in the notes (as written).", "gold_answer": "Base + i * size", "gold_evidence": "[p2:c2] Complexity Explanation\nAccess  O (1)  Direct access using index:\narr[i] ‚Üí CPU calculates the\naddress directly using\nformula Base + i * size\nInsertion  O (n)  If insertion is at beginning\nor middle , all subsequent\nelements must be shifted\nright\nDeletion  O (n) If deleting from start  or\nmiddle , elements must be\nshifted left  to fill the gap\nDATA S‚Ä¶\n[p2:c0] Array\n‚Ä¢Array : A collection of homogeneous elements\nstored in contiguous memory .\n‚Ä¢Indexing : In C, starts from 0.\nint arr[10]; ‚Üí arr[0] is the first element, arr[9] is\nthe last.\n‚Ä¢Types :\no1D Array: Linear structure, e.g. int a [10];\no2D Array: Matrix -like, e.g. int a [2][3];\nint a[2][3] = { {0,0,0}, {1,1,1} };\noMulti -dimensional: int a [3][2][4]‚Ä¶\n[p8:c14] LL, RR are single rotations\nLR, RL are double rotations.\nWe check the balance factor from  bottom to top, if\nwe find any  node not following the properties then\nwe do the rotations.\ninorder(node) {\nif (node == NULL) return;\ninorder(node->left);\nvisit(node);\ninorder(node->right);\n}\nInorder: 20 10 30\npreorder(node) {\nif (node == NULL) return;     vis‚Ä¶\n[p4:c5] ‚Ä¢Undo functionality\n‚Ä¢Backtracking (like maze, Sudoku)\n‚Ä¢Number of possible stack permutations\n= 2ùëõùëõùê∂ùê∂ùëõùëõ\nùëõùëõ+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 03", "draft_gold_evidence": "[p2:c2] Complexity Explanation\nAccess  O (1)  Direct access using index:\narr[i] ‚Üí CPU calculates the\naddress directly using\nformula Base + i * size\nInsertion  O (n)  If insertion is at beginning\nor middle , all subsequent\nelements must be shifted\nright\nDeletion  O (n) If deleting from start  or\nmiddle , elements must be\nshifted left  to fill the gap\nDATA S‚Ä¶\n[p2:c0] Array\n‚Ä¢Array : A collection of homogeneous elements\nstored in contiguous memory .\n‚Ä¢Indexing : In C, starts from 0.\nint arr[10]; ‚Üí arr[0] is the first element, arr[9] is\nthe last.\n‚Ä¢Types :\no1D Array: Linear structure, e.g. int a [10];\no2D Array: Matrix -like, e.g. int a [2][3];\nint a[2][3] = { {0,0,0}, {1,1,1} };\noMulti -dimensional: int a [3][2][4]‚Ä¶\n[p8:c14] LL, RR are single rotations\nLR, RL are double rotations.\nWe check the balance factor from  bottom to top, if\nwe find any  node not following the properties then\nwe do the rotations.\ninorder(node) {\nif (node == NULL) return;\ninorder(node->left);\nvisit(node);\ninorder(node->right);\n}\nInorder: 20 10 30\npreorder(node) {\nif (node == NULL) return;     vis‚Ä¶\n[p4:c5] ‚Ä¢Undo functionality\n‚Ä¢Backtracking (like maze, Sudoku)\n‚Ä¢Number of possible stack permutations\n= 2ùëõùëõùê∂ùê∂ùëõùëõ\nùëõùëõ+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 03", "draft_gold_answer": "Base + i * size"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List the steps of one algorithm/procedure described in the notes.", "gold_answer": "**Gold Answer:**\n\n- Search: Hash the key, then linearly search the linked list at that index.\n- Deletion: Hash the key, search the linked list, and remove the node if found.\n- Insertion: Insert the element at the head of the linked list.", "gold_evidence": "[p2:c2] Complexity Explanation\nAccess  O (1)  Direct access using index:\narr[i] ‚Üí CPU calculates the\naddress directly using\nformula Base + i * size\nInsertion  O (n)  If insertion is at beginning\nor middle , all subsequent\nelements must be shifted\nright\nDeletion  O (n) If deleting from start  or\nmiddle , elements must be\nshifted left  to fill the gap\nDATA S‚Ä¶\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( Œª): Œª = n / m\n(n = total el ements, m = table size)\nPerformance‚Ä¶\n[p14:c24] thinking it's not present, even though 24 is at\nindex 5.\n‚Ä¢This happens because deletion breaks t he\nprobing chain, causing search failure.\n‚Ä¢This may require the rehashing.\n‚Ä¢\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (o‚Ä¶\n[p4:c4] Implementation Methods:\n1.Using Array  (Fixed size, static memory)\n2.Using Linked List  (Dynamic size)Queue\nA Queue  is a linear data structure that follows the\nFIFO  principle:\nFirst In, First Out\nThe first element inserted is the first to be removed.\nReal-World Examples:\n‚Ä¢Ticket line\n‚Ä¢Print queue\nCPU task scheduling  Operation  Description  Time‚Ä¶", "draft_gold_evidence": "[p2:c2] Complexity Explanation\nAccess  O (1)  Direct access using index:\narr[i] ‚Üí CPU calculates the\naddress directly using\nformula Base + i * size\nInsertion  O (n)  If insertion is at beginning\nor middle , all subsequent\nelements must be shifted\nright\nDeletion  O (n) If deleting from start  or\nmiddle , elements must be\nshifted left  to fill the gap\nDATA S‚Ä¶\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( Œª): Œª = n / m\n(n = total el ements, m = table size)\nPerformance‚Ä¶\n[p14:c24] thinking it's not present, even though 24 is at\nindex 5.\n‚Ä¢This happens because deletion breaks t he\nprobing chain, causing search failure.\n‚Ä¢This may require the rehashing.\n‚Ä¢\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (o‚Ä¶\n[p4:c4] Implementation Methods:\n1.Using Array  (Fixed size, static memory)\n2.Using Linked List  (Dynamic size)Queue\nA Queue  is a linear data structure that follows the\nFIFO  principle:\nFirst In, First Out\nThe first element inserted is the first to be removed.\nReal-World Examples:\n‚Ä¢Ticket line\n‚Ä¢Print queue\nCPU task scheduling  Operation  Description  Time‚Ä¶", "draft_gold_answer": "**Gold Answer:**\n\n- Search: Hash the key, then linearly search the linked list at that index.\n- Deletion: Hash the key, search the linked list, and remove the node if found.\n- Insertion: Insert the element at the head of the linked list."}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Compare two related concepts/methods mentioned (give at least one difference).", "gold_answer": "Search and deletion in separate chaining have different steps: search only requires a linear search of the linked list at the indexed position, while deletion involves searching the entire list and removing the node if found.", "gold_evidence": "[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( Œª): Œª = n / m\n(n = total el ements, m = table size)\nPerformance‚Ä¶\n[p14:c24] thinking it's not present, even though 24 is at\nindex 5.\n‚Ä¢This happens because deletion breaks t he\nprobing chain, causing search failure.\n‚Ä¢This may require the rehashing.\n‚Ä¢\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (o‚Ä¶\n[p4:c4] Implementation Methods:\n1.Using Array  (Fixed size, static memory)\n2.Using Linked List  (Dynamic size)Queue\nA Queue  is a linear data structure that follows the\nFIFO  principle:\nFirst In, First Out\nThe first element inserted is the first to be removed.\nReal-World Examples:\n‚Ä¢Ticket line\n‚Ä¢Print queue\nCPU task scheduling  Operation  Description  Time‚Ä¶\n[p5:c6] Operation  Description  Time\nComplexity\nenqueue(x)  Insert\nelement x at\nthe rear  O (1) (array\nor LL)\ndequeue()  Remove\nand return\nelement\nfrom front  O (1)\n‚Ä¢Type ‚Ä¢Description\n‚Ä¢Simp le\nQueue‚Ä¢Basic FIFO q ueue\n(insertion at rear, deletio n\nat front)\n‚Ä¢Circular\nQueue‚Ä¢Last position connect s\nback to first (sol ves\noverflow in array)\n‚Ä¢Deque\n(Double-Ende‚Ä¶", "draft_gold_evidence": "[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( Œª): Œª = n / m\n(n = total el ements, m = table size)\nPerformance‚Ä¶\n[p14:c24] thinking it's not present, even though 24 is at\nindex 5.\n‚Ä¢This happens because deletion breaks t he\nprobing chain, causing search failure.\n‚Ä¢This may require the rehashing.\n‚Ä¢\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (o‚Ä¶\n[p4:c4] Implementation Methods:\n1.Using Array  (Fixed size, static memory)\n2.Using Linked List  (Dynamic size)Queue\nA Queue  is a linear data structure that follows the\nFIFO  principle:\nFirst In, First Out\nThe first element inserted is the first to be removed.\nReal-World Examples:\n‚Ä¢Ticket line\n‚Ä¢Print queue\nCPU task scheduling  Operation  Description  Time‚Ä¶\n[p5:c6] Operation  Description  Time\nComplexity\nenqueue(x)  Insert\nelement x at\nthe rear  O (1) (array\nor LL)\ndequeue()  Remove\nand return\nelement\nfrom front  O (1)\n‚Ä¢Type ‚Ä¢Description\n‚Ä¢Simp le\nQueue‚Ä¢Basic FIFO q ueue\n(insertion at rear, deletio n\nat front)\n‚Ä¢Circular\nQueue‚Ä¢Last position connect s\nback to first (sol ves\noverflow in array)\n‚Ä¢Deque\n(Double-Ende‚Ä¶", "draft_gold_answer": "Search and deletion in separate chaining have different steps: search only requires a linear search of the linked list at the indexed position, while deletion involves searching the entire list and removing the node if found."}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List any assumptions, prerequisites, or constraints mentioned.", "gold_answer": "- Fixed-size arrays and linked lists are prerequisites for implementing stacks.\n- Backtracking and undo functionality are assumptions for certain applications.\n- Time complexity constraints are mentioned for depth-first search.", "gold_evidence": "[p13:c21] Depth -First Search (DFS)\n‚Ä¢Explores as deep as possible\n‚Ä¢Uses stack (explicit or recursion)\n‚Ä¢Backtracks when no unvisited neighbours\nAlgorithm:\n1.Mark current node visited\n2.Recursively visit all unvisited neighbours\nTime Complexity:\n‚Ä¢O (V + E)\nApplications:\n‚Ä¢Topological sorting (DAG)\n‚Ä¢Cycle detection\n‚Ä¢Strongly Connected Component s\n‚Ä¢Maze/path solv‚Ä¶\n[p4:c5] ‚Ä¢Undo functionality\n‚Ä¢Backtracking (like maze, Sudoku)\n‚Ä¢Number of possible stack permutations\n= 2ùëõùëõùê∂ùê∂ùëõùëõ\nùëõùëõ+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 03\n[p4:c4] Implementation Methods:\n1.Using Array  (Fixed size, static memory)\n2.Using Linked List  (Dynamic size)Queue\nA Queue  is a linear data structure that follows the\nFIFO  principle:\nFirst In, First Out\nThe first element inserted is the first to be removed.\nReal-World Examples:\n‚Ä¢Ticket line\n‚Ä¢Print queue\nCPU task scheduling  Operation  Description  Time‚Ä¶\n[p2:c2] Complexity Explanation\nAccess  O (1)  Direct access using index:\narr[i] ‚Üí CPU calculates the\naddress directly using\nformula Base + i * size\nInsertion  O (n)  If insertion is at beginning\nor middle , all subsequent\nelements must be shifted\nright\nDeletion  O (n) If deleting from start  or\nmiddle , elements must be\nshifted left  to fill the gap\nDATA S‚Ä¶", "draft_gold_evidence": "[p13:c21] Depth -First Search (DFS)\n‚Ä¢Explores as deep as possible\n‚Ä¢Uses stack (explicit or recursion)\n‚Ä¢Backtracks when no unvisited neighbours\nAlgorithm:\n1.Mark current node visited\n2.Recursively visit all unvisited neighbours\nTime Complexity:\n‚Ä¢O (V + E)\nApplications:\n‚Ä¢Topological sorting (DAG)\n‚Ä¢Cycle detection\n‚Ä¢Strongly Connected Component s\n‚Ä¢Maze/path solv‚Ä¶\n[p4:c5] ‚Ä¢Undo functionality\n‚Ä¢Backtracking (like maze, Sudoku)\n‚Ä¢Number of possible stack permutations\n= 2ùëõùëõùê∂ùê∂ùëõùëõ\nùëõùëõ+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 03\n[p4:c4] Implementation Methods:\n1.Using Array  (Fixed size, static memory)\n2.Using Linked List  (Dynamic size)Queue\nA Queue  is a linear data structure that follows the\nFIFO  principle:\nFirst In, First Out\nThe first element inserted is the first to be removed.\nReal-World Examples:\n‚Ä¢Ticket line\n‚Ä¢Print queue\nCPU task scheduling  Operation  Description  Time‚Ä¶\n[p2:c2] Complexity Explanation\nAccess  O (1)  Direct access using index:\narr[i] ‚Üí CPU calculates the\naddress directly using\nformula Base + i * size\nInsertion  O (n)  If insertion is at beginning\nor middle , all subsequent\nelements must be shifted\nright\nDeletion  O (n) If deleting from start  or\nmiddle , elements must be\nshifted left  to fill the gap\nDATA S‚Ä¶", "draft_gold_answer": "- Fixed-size arrays and linked lists are prerequisites for implementing stacks.\n- Backtracking and undo functionality are assumptions for certain applications.\n- Time complexity constraints are mentioned for depth-first search."}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Give one example mentioned in the notes.", "gold_answer": "[p4:c5] ‚Ä¢Undo functionality", "gold_evidence": "[p4:c5] ‚Ä¢Undo functionality\n‚Ä¢Backtracking (like maze, Sudoku)\n‚Ä¢Number of possible stack permutations\n= 2ùëõùëõùê∂ùê∂ùëõùëõ\nùëõùëõ+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 03\n[p4:c4] Implementation Methods:\n1.Using Array  (Fixed size, static memory)\n2.Using Linked List  (Dynamic size)Queue\nA Queue  is a linear data structure that follows the\nFIFO  principle:\nFirst In, First Out\nThe first element inserted is the first to be removed.\nReal-World Examples:\n‚Ä¢Ticket line\n‚Ä¢Print queue\nCPU task scheduling  Operation  Description  Time‚Ä¶\n[p10:c17] be found i n the leaf nodes, so the tim e\ncomplexity to find it is O(n) .\n‚Ä¢The number of leaf nodes in a heap is\nceil(n/2).\n‚Ä¢The minimum element  in a Max Heap will\nbe found i n the leaf nodes, so the time\ncomplexity is also O(n) .\n‚Ä¢Heap Sort repeatedly deletes the ro ot\nelement and re-heapifies the remaini ng\nheap, s o the total time complexity is‚Ä¶\n[p14:c24] thinking it's not present, even though 24 is at\nindex 5.\n‚Ä¢This happens because deletion breaks t he\nprobing chain, causing search failure.\n‚Ä¢This may require the rehashing.\n‚Ä¢\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (o‚Ä¶", "draft_gold_evidence": "[p4:c5] ‚Ä¢Undo functionality\n‚Ä¢Backtracking (like maze, Sudoku)\n‚Ä¢Number of possible stack permutations\n= 2ùëõùëõùê∂ùê∂ùëõùëõ\nùëõùëõ+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE ‡§´‡§∞‡•ç‡§∞‡•á\nPage No:- 03\n[p4:c4] Implementation Methods:\n1.Using Array  (Fixed size, static memory)\n2.Using Linked List  (Dynamic size)Queue\nA Queue  is a linear data structure that follows the\nFIFO  principle:\nFirst In, First Out\nThe first element inserted is the first to be removed.\nReal-World Examples:\n‚Ä¢Ticket line\n‚Ä¢Print queue\nCPU task scheduling  Operation  Description  Time‚Ä¶\n[p10:c17] be found i n the leaf nodes, so the tim e\ncomplexity to find it is O(n) .\n‚Ä¢The number of leaf nodes in a heap is\nceil(n/2).\n‚Ä¢The minimum element  in a Max Heap will\nbe found i n the leaf nodes, so the time\ncomplexity is also O(n) .\n‚Ä¢Heap Sort repeatedly deletes the ro ot\nelement and re-heapifies the remaini ng\nheap, s o the total time complexity is‚Ä¶\n[p14:c24] thinking it's not present, even though 24 is at\nindex 5.\n‚Ä¢This happens because deletion breaks t he\nprobing chain, causing search failure.\n‚Ä¢This may require the rehashing.\n‚Ä¢\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (o‚Ä¶", "draft_gold_answer": "[p4:c5] ‚Ä¢Undo functionality"}
{"doc_id": "94ff2fa31219cd6e", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the main topic of these notes?", "gold_answer": "Achievements and work experience.", "gold_evidence": "[p1:c0] AchievementsEDUCATIONWORK EXPERIENCESUMMARY\n2nd Place in PEC HACKS 2.0 an International level Hackathon With MLH.\nSmart India Hackathon 2024 Finalist Under ISRO problem Statement.\nHackfest 2024 Finalist: Placed 4th among 2500 teams, conducted by SAP.\n1st Place in Ideathon & Shark Tank Competition: Organized by the IEEE Society.\n1st Place in Mind Ma‚Ä¶\n[p1:c1] workflows to drive operational efficiency.Karthikeyan A\nThiruvallur, India 602002\n+91 8810337076\nkarthikeyana281104@gmail.com\nAssembly Assistant\nHYUNDAI, Inguratukottai, India                                                  February 2024 ‚Äì February 2024\nWeb Developer Intern\nCODSOFT, India‚Ä¶\n[p1:c2] Frameworks: Web Development (React), IoT Systems\nCloud: AWS\nOther Skills: Production Line Operations, Quality Inspection, Helpdesk Operations\nCertifications: Certified in Python, Web Development, and PC BuildingCGPA        -   7.91\nSSLC 2020 - 82.6%\nHSC 2022 - 85.16%\nCertifications\nCertified in Python: Proficient in coding and software development.‚Ä¶", "draft_gold_evidence": "[p1:c0] AchievementsEDUCATIONWORK EXPERIENCESUMMARY\n2nd Place in PEC HACKS 2.0 an International level Hackathon With MLH.\nSmart India Hackathon 2024 Finalist Under ISRO problem Statement.\nHackfest 2024 Finalist: Placed 4th among 2500 teams, conducted by SAP.\n1st Place in Ideathon & Shark Tank Competition: Organized by the IEEE Society.\n1st Place in Mind Ma‚Ä¶\n[p1:c1] workflows to drive operational efficiency.Karthikeyan A\nThiruvallur, India 602002\n+91 8810337076\nkarthikeyana281104@gmail.com\nAssembly Assistant\nHYUNDAI, Inguratukottai, India                                                  February 2024 ‚Äì February 2024\nWeb Developer Intern\nCODSOFT, India‚Ä¶\n[p1:c2] Frameworks: Web Development (React), IoT Systems\nCloud: AWS\nOther Skills: Production Line Operations, Quality Inspection, Helpdesk Operations\nCertifications: Certified in Python, Web Development, and PC BuildingCGPA        -   7.91\nSSLC 2020 - 82.6%\nHSC 2022 - 85.16%\nCertifications\nCertified in Python: Proficient in coding and software development.‚Ä¶", "draft_gold_answer": "Achievements and work experience."}
{"doc_id": "94ff2fa31219cd6e", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 5 key concepts covered.", "gold_answer": "1. Hackathons and competitions\n2. Web development and IoT frameworks\n3. Cloud computing (AWS)\n4. Certifications (Python, Web Dev, PC Building)\n5. Academic achievements and grades", "gold_evidence": "[p1:c0] AchievementsEDUCATIONWORK EXPERIENCESUMMARY\n2nd Place in PEC HACKS 2.0 an International level Hackathon With MLH.\nSmart India Hackathon 2024 Finalist Under ISRO problem Statement.\nHackfest 2024 Finalist: Placed 4th among 2500 teams, conducted by SAP.\n1st Place in Ideathon & Shark Tank Competition: Organized by the IEEE Society.\n1st Place in Mind Ma‚Ä¶\n[p1:c2] Frameworks: Web Development (React), IoT Systems\nCloud: AWS\nOther Skills: Production Line Operations, Quality Inspection, Helpdesk Operations\nCertifications: Certified in Python, Web Development, and PC BuildingCGPA        -   7.91\nSSLC 2020 - 82.6%\nHSC 2022 - 85.16%\nCertifications\nCertified in Python: Proficient in coding and software development.‚Ä¶\n[p1:c1] workflows to drive operational efficiency.Karthikeyan A\nThiruvallur, India 602002\n+91 8810337076\nkarthikeyana281104@gmail.com\nAssembly Assistant\nHYUNDAI, Inguratukottai, India                                                  February 2024 ‚Äì February 2024\nWeb Developer Intern\nCODSOFT, India‚Ä¶", "draft_gold_evidence": "[p1:c0] AchievementsEDUCATIONWORK EXPERIENCESUMMARY\n2nd Place in PEC HACKS 2.0 an International level Hackathon With MLH.\nSmart India Hackathon 2024 Finalist Under ISRO problem Statement.\nHackfest 2024 Finalist: Placed 4th among 2500 teams, conducted by SAP.\n1st Place in Ideathon & Shark Tank Competition: Organized by the IEEE Society.\n1st Place in Mind Ma‚Ä¶\n[p1:c2] Frameworks: Web Development (React), IoT Systems\nCloud: AWS\nOther Skills: Production Line Operations, Quality Inspection, Helpdesk Operations\nCertifications: Certified in Python, Web Development, and PC BuildingCGPA        -   7.91\nSSLC 2020 - 82.6%\nHSC 2022 - 85.16%\nCertifications\nCertified in Python: Proficient in coding and software development.‚Ä¶\n[p1:c1] workflows to drive operational efficiency.Karthikeyan A\nThiruvallur, India 602002\n+91 8810337076\nkarthikeyana281104@gmail.com\nAssembly Assistant\nHYUNDAI, Inguratukottai, India                                                  February 2024 ‚Äì February 2024\nWeb Developer Intern\nCODSOFT, India‚Ä¶", "draft_gold_answer": "1. Hackathons and competitions\n2. Web development and IoT frameworks\n3. Cloud computing (AWS)\n4. Certifications (Python, Web Dev, PC Building)\n5. Academic achievements and grades"}
{"doc_id": "94ff2fa31219cd6e", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Define two important terms exactly as stated in the notes.", "gold_answer": "Achievements: Awards and recognition gained through competitions and events.\nEducation: Academic qualifications and grades achieved.", "gold_evidence": "[p1:c0] AchievementsEDUCATIONWORK EXPERIENCESUMMARY\n2nd Place in PEC HACKS 2.0 an International level Hackathon With MLH.\nSmart India Hackathon 2024 Finalist Under ISRO problem Statement.\nHackfest 2024 Finalist: Placed 4th among 2500 teams, conducted by SAP.\n1st Place in Ideathon & Shark Tank Competition: Organized by the IEEE Society.\n1st Place in Mind Ma‚Ä¶\n[p1:c1] workflows to drive operational efficiency.Karthikeyan A\nThiruvallur, India 602002\n+91 8810337076\nkarthikeyana281104@gmail.com\nAssembly Assistant\nHYUNDAI, Inguratukottai, India                                                  February 2024 ‚Äì February 2024\nWeb Developer Intern\nCODSOFT, India‚Ä¶\n[p1:c2] Frameworks: Web Development (React), IoT Systems\nCloud: AWS\nOther Skills: Production Line Operations, Quality Inspection, Helpdesk Operations\nCertifications: Certified in Python, Web Development, and PC BuildingCGPA        -   7.91\nSSLC 2020 - 82.6%\nHSC 2022 - 85.16%\nCertifications\nCertified in Python: Proficient in coding and software development.‚Ä¶", "draft_gold_evidence": "[p1:c0] AchievementsEDUCATIONWORK EXPERIENCESUMMARY\n2nd Place in PEC HACKS 2.0 an International level Hackathon With MLH.\nSmart India Hackathon 2024 Finalist Under ISRO problem Statement.\nHackfest 2024 Finalist: Placed 4th among 2500 teams, conducted by SAP.\n1st Place in Ideathon & Shark Tank Competition: Organized by the IEEE Society.\n1st Place in Mind Ma‚Ä¶\n[p1:c1] workflows to drive operational efficiency.Karthikeyan A\nThiruvallur, India 602002\n+91 8810337076\nkarthikeyana281104@gmail.com\nAssembly Assistant\nHYUNDAI, Inguratukottai, India                                                  February 2024 ‚Äì February 2024\nWeb Developer Intern\nCODSOFT, India‚Ä¶\n[p1:c2] Frameworks: Web Development (React), IoT Systems\nCloud: AWS\nOther Skills: Production Line Operations, Quality Inspection, Helpdesk Operations\nCertifications: Certified in Python, Web Development, and PC BuildingCGPA        -   7.91\nSSLC 2020 - 82.6%\nHSC 2022 - 85.16%\nCertifications\nCertified in Python: Proficient in coding and software development.‚Ä¶", "draft_gold_answer": "Achievements: Awards and recognition gained through competitions and events.\nEducation: Academic qualifications and grades achieved."}
{"doc_id": "94ff2fa31219cd6e", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Write one formula/equation mentioned in the notes (as written).", "gold_answer": "Not found in the document.", "gold_evidence": "[p1:c0] AchievementsEDUCATIONWORK EXPERIENCESUMMARY\n2nd Place in PEC HACKS 2.0 an International level Hackathon With MLH.\nSmart India Hackathon 2024 Finalist Under ISRO problem Statement.\nHackfest 2024 Finalist: Placed 4th among 2500 teams, conducted by SAP.\n1st Place in Ideathon & Shark Tank Competition: Organized by the IEEE Society.\n1st Place in Mind Ma‚Ä¶\n[p1:c1] workflows to drive operational efficiency.Karthikeyan A\nThiruvallur, India 602002\n+91 8810337076\nkarthikeyana281104@gmail.com\nAssembly Assistant\nHYUNDAI, Inguratukottai, India                                                  February 2024 ‚Äì February 2024\nWeb Developer Intern\nCODSOFT, India‚Ä¶\n[p1:c2] Frameworks: Web Development (React), IoT Systems\nCloud: AWS\nOther Skills: Production Line Operations, Quality Inspection, Helpdesk Operations\nCertifications: Certified in Python, Web Development, and PC BuildingCGPA        -   7.91\nSSLC 2020 - 82.6%\nHSC 2022 - 85.16%\nCertifications\nCertified in Python: Proficient in coding and software development.‚Ä¶", "draft_gold_evidence": "[p1:c0] AchievementsEDUCATIONWORK EXPERIENCESUMMARY\n2nd Place in PEC HACKS 2.0 an International level Hackathon With MLH.\nSmart India Hackathon 2024 Finalist Under ISRO problem Statement.\nHackfest 2024 Finalist: Placed 4th among 2500 teams, conducted by SAP.\n1st Place in Ideathon & Shark Tank Competition: Organized by the IEEE Society.\n1st Place in Mind Ma‚Ä¶\n[p1:c1] workflows to drive operational efficiency.Karthikeyan A\nThiruvallur, India 602002\n+91 8810337076\nkarthikeyana281104@gmail.com\nAssembly Assistant\nHYUNDAI, Inguratukottai, India                                                  February 2024 ‚Äì February 2024\nWeb Developer Intern\nCODSOFT, India‚Ä¶\n[p1:c2] Frameworks: Web Development (React), IoT Systems\nCloud: AWS\nOther Skills: Production Line Operations, Quality Inspection, Helpdesk Operations\nCertifications: Certified in Python, Web Development, and PC BuildingCGPA        -   7.91\nSSLC 2020 - 82.6%\nHSC 2022 - 85.16%\nCertifications\nCertified in Python: Proficient in coding and software development.‚Ä¶", "draft_gold_answer": "Not found in the document."}
{"doc_id": "94ff2fa31219cd6e", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List the steps of one algorithm/procedure described in the notes.", "gold_answer": "Not found in the document.", "gold_evidence": "[p1:c0] AchievementsEDUCATIONWORK EXPERIENCESUMMARY\n2nd Place in PEC HACKS 2.0 an International level Hackathon With MLH.\nSmart India Hackathon 2024 Finalist Under ISRO problem Statement.\nHackfest 2024 Finalist: Placed 4th among 2500 teams, conducted by SAP.\n1st Place in Ideathon & Shark Tank Competition: Organized by the IEEE Society.\n1st Place in Mind Ma‚Ä¶\n[p1:c1] workflows to drive operational efficiency.Karthikeyan A\nThiruvallur, India 602002\n+91 8810337076\nkarthikeyana281104@gmail.com\nAssembly Assistant\nHYUNDAI, Inguratukottai, India                                                  February 2024 ‚Äì February 2024\nWeb Developer Intern\nCODSOFT, India‚Ä¶\n[p1:c2] Frameworks: Web Development (React), IoT Systems\nCloud: AWS\nOther Skills: Production Line Operations, Quality Inspection, Helpdesk Operations\nCertifications: Certified in Python, Web Development, and PC BuildingCGPA        -   7.91\nSSLC 2020 - 82.6%\nHSC 2022 - 85.16%\nCertifications\nCertified in Python: Proficient in coding and software development.‚Ä¶", "draft_gold_evidence": "[p1:c0] AchievementsEDUCATIONWORK EXPERIENCESUMMARY\n2nd Place in PEC HACKS 2.0 an International level Hackathon With MLH.\nSmart India Hackathon 2024 Finalist Under ISRO problem Statement.\nHackfest 2024 Finalist: Placed 4th among 2500 teams, conducted by SAP.\n1st Place in Ideathon & Shark Tank Competition: Organized by the IEEE Society.\n1st Place in Mind Ma‚Ä¶\n[p1:c1] workflows to drive operational efficiency.Karthikeyan A\nThiruvallur, India 602002\n+91 8810337076\nkarthikeyana281104@gmail.com\nAssembly Assistant\nHYUNDAI, Inguratukottai, India                                                  February 2024 ‚Äì February 2024\nWeb Developer Intern\nCODSOFT, India‚Ä¶\n[p1:c2] Frameworks: Web Development (React), IoT Systems\nCloud: AWS\nOther Skills: Production Line Operations, Quality Inspection, Helpdesk Operations\nCertifications: Certified in Python, Web Development, and PC BuildingCGPA        -   7.91\nSSLC 2020 - 82.6%\nHSC 2022 - 85.16%\nCertifications\nCertified in Python: Proficient in coding and software development.‚Ä¶", "draft_gold_answer": "Not found in the document."}
{"doc_id": "94ff2fa31219cd6e", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Compare two related concepts/methods mentioned (give at least one difference).", "gold_answer": "\"PEC Hacks 2.0 is an international-level hackathon, while Hackfest 2024 is conducted at a national level.\"", "gold_evidence": "[p1:c0] AchievementsEDUCATIONWORK EXPERIENCESUMMARY\n2nd Place in PEC HACKS 2.0 an International level Hackathon With MLH.\nSmart India Hackathon 2024 Finalist Under ISRO problem Statement.\nHackfest 2024 Finalist: Placed 4th among 2500 teams, conducted by SAP.\n1st Place in Ideathon & Shark Tank Competition: Organized by the IEEE Society.\n1st Place in Mind Ma‚Ä¶\n[p1:c2] Frameworks: Web Development (React), IoT Systems\nCloud: AWS\nOther Skills: Production Line Operations, Quality Inspection, Helpdesk Operations\nCertifications: Certified in Python, Web Development, and PC BuildingCGPA        -   7.91\nSSLC 2020 - 82.6%\nHSC 2022 - 85.16%\nCertifications\nCertified in Python: Proficient in coding and software development.‚Ä¶\n[p1:c1] workflows to drive operational efficiency.Karthikeyan A\nThiruvallur, India 602002\n+91 8810337076\nkarthikeyana281104@gmail.com\nAssembly Assistant\nHYUNDAI, Inguratukottai, India                                                  February 2024 ‚Äì February 2024\nWeb Developer Intern\nCODSOFT, India‚Ä¶", "draft_gold_evidence": "[p1:c0] AchievementsEDUCATIONWORK EXPERIENCESUMMARY\n2nd Place in PEC HACKS 2.0 an International level Hackathon With MLH.\nSmart India Hackathon 2024 Finalist Under ISRO problem Statement.\nHackfest 2024 Finalist: Placed 4th among 2500 teams, conducted by SAP.\n1st Place in Ideathon & Shark Tank Competition: Organized by the IEEE Society.\n1st Place in Mind Ma‚Ä¶\n[p1:c2] Frameworks: Web Development (React), IoT Systems\nCloud: AWS\nOther Skills: Production Line Operations, Quality Inspection, Helpdesk Operations\nCertifications: Certified in Python, Web Development, and PC BuildingCGPA        -   7.91\nSSLC 2020 - 82.6%\nHSC 2022 - 85.16%\nCertifications\nCertified in Python: Proficient in coding and software development.‚Ä¶\n[p1:c1] workflows to drive operational efficiency.Karthikeyan A\nThiruvallur, India 602002\n+91 8810337076\nkarthikeyana281104@gmail.com\nAssembly Assistant\nHYUNDAI, Inguratukottai, India                                                  February 2024 ‚Äì February 2024\nWeb Developer Intern\nCODSOFT, India‚Ä¶", "draft_gold_answer": "\"PEC Hacks 2.0 is an international-level hackathon, while Hackfest 2024 is conducted at a national level.\""}
{"doc_id": "94ff2fa31219cd6e", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List any assumptions, prerequisites, or constraints mentioned.", "gold_answer": "\"Not found in the document.\"", "gold_evidence": "[p1:c0] AchievementsEDUCATIONWORK EXPERIENCESUMMARY\n2nd Place in PEC HACKS 2.0 an International level Hackathon With MLH.\nSmart India Hackathon 2024 Finalist Under ISRO problem Statement.\nHackfest 2024 Finalist: Placed 4th among 2500 teams, conducted by SAP.\n1st Place in Ideathon & Shark Tank Competition: Organized by the IEEE Society.\n1st Place in Mind Ma‚Ä¶\n[p1:c2] Frameworks: Web Development (React), IoT Systems\nCloud: AWS\nOther Skills: Production Line Operations, Quality Inspection, Helpdesk Operations\nCertifications: Certified in Python, Web Development, and PC BuildingCGPA        -   7.91\nSSLC 2020 - 82.6%\nHSC 2022 - 85.16%\nCertifications\nCertified in Python: Proficient in coding and software development.‚Ä¶\n[p1:c1] workflows to drive operational efficiency.Karthikeyan A\nThiruvallur, India 602002\n+91 8810337076\nkarthikeyana281104@gmail.com\nAssembly Assistant\nHYUNDAI, Inguratukottai, India                                                  February 2024 ‚Äì February 2024\nWeb Developer Intern\nCODSOFT, India‚Ä¶", "draft_gold_evidence": "[p1:c0] AchievementsEDUCATIONWORK EXPERIENCESUMMARY\n2nd Place in PEC HACKS 2.0 an International level Hackathon With MLH.\nSmart India Hackathon 2024 Finalist Under ISRO problem Statement.\nHackfest 2024 Finalist: Placed 4th among 2500 teams, conducted by SAP.\n1st Place in Ideathon & Shark Tank Competition: Organized by the IEEE Society.\n1st Place in Mind Ma‚Ä¶\n[p1:c2] Frameworks: Web Development (React), IoT Systems\nCloud: AWS\nOther Skills: Production Line Operations, Quality Inspection, Helpdesk Operations\nCertifications: Certified in Python, Web Development, and PC BuildingCGPA        -   7.91\nSSLC 2020 - 82.6%\nHSC 2022 - 85.16%\nCertifications\nCertified in Python: Proficient in coding and software development.‚Ä¶\n[p1:c1] workflows to drive operational efficiency.Karthikeyan A\nThiruvallur, India 602002\n+91 8810337076\nkarthikeyana281104@gmail.com\nAssembly Assistant\nHYUNDAI, Inguratukottai, India                                                  February 2024 ‚Äì February 2024\nWeb Developer Intern\nCODSOFT, India‚Ä¶", "draft_gold_answer": "\"Not found in the document.\""}
{"doc_id": "94ff2fa31219cd6e", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Give one example mentioned in the notes.", "gold_answer": "2nd Place in PEC HACKS 2.0, an International level Hackathon with MLH.", "gold_evidence": "[p1:c0] AchievementsEDUCATIONWORK EXPERIENCESUMMARY\n2nd Place in PEC HACKS 2.0 an International level Hackathon With MLH.\nSmart India Hackathon 2024 Finalist Under ISRO problem Statement.\nHackfest 2024 Finalist: Placed 4th among 2500 teams, conducted by SAP.\n1st Place in Ideathon & Shark Tank Competition: Organized by the IEEE Society.\n1st Place in Mind Ma‚Ä¶\n[p1:c1] workflows to drive operational efficiency.Karthikeyan A\nThiruvallur, India 602002\n+91 8810337076\nkarthikeyana281104@gmail.com\nAssembly Assistant\nHYUNDAI, Inguratukottai, India                                                  February 2024 ‚Äì February 2024\nWeb Developer Intern\nCODSOFT, India‚Ä¶\n[p1:c2] Frameworks: Web Development (React), IoT Systems\nCloud: AWS\nOther Skills: Production Line Operations, Quality Inspection, Helpdesk Operations\nCertifications: Certified in Python, Web Development, and PC BuildingCGPA        -   7.91\nSSLC 2020 - 82.6%\nHSC 2022 - 85.16%\nCertifications\nCertified in Python: Proficient in coding and software development.‚Ä¶", "draft_gold_evidence": "[p1:c0] AchievementsEDUCATIONWORK EXPERIENCESUMMARY\n2nd Place in PEC HACKS 2.0 an International level Hackathon With MLH.\nSmart India Hackathon 2024 Finalist Under ISRO problem Statement.\nHackfest 2024 Finalist: Placed 4th among 2500 teams, conducted by SAP.\n1st Place in Ideathon & Shark Tank Competition: Organized by the IEEE Society.\n1st Place in Mind Ma‚Ä¶\n[p1:c1] workflows to drive operational efficiency.Karthikeyan A\nThiruvallur, India 602002\n+91 8810337076\nkarthikeyana281104@gmail.com\nAssembly Assistant\nHYUNDAI, Inguratukottai, India                                                  February 2024 ‚Äì February 2024\nWeb Developer Intern\nCODSOFT, India‚Ä¶\n[p1:c2] Frameworks: Web Development (React), IoT Systems\nCloud: AWS\nOther Skills: Production Line Operations, Quality Inspection, Helpdesk Operations\nCertifications: Certified in Python, Web Development, and PC BuildingCGPA        -   7.91\nSSLC 2020 - 82.6%\nHSC 2022 - 85.16%\nCertifications\nCertified in Python: Proficient in coding and software development.‚Ä¶", "draft_gold_answer": "2nd Place in PEC HACKS 2.0, an International level Hackathon with MLH."}
