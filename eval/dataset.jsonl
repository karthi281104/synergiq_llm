{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the main topic of these notes?", "gold_answer": "aph that is bi-connected. ALGORITHMS GATE फर्रे Articulation point (cut vertex) Articulation Point : A vertex whose removal increases the number of connected components in a graph. Page No:- 15", "gold_evidence": "[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p18:c40] Algorithm  Time complexity  Stable\nsorting  In\nplace\nsorting\nBest Avera\nge Worst\nQuick sort  Ω(n\nlog n)  Θ(n\nlog n)  O(n²)  No Yes\nMerge\nsort Ω(n\nlog n)  Θ(n\nlog n)  O(n\nlog n)  Yes No\nInsertion\nsort Ω(n) Θ(n²) O(n²)  Yes Yes\nSelection\nsort Ω(n²) Θ(n²) O(n²)  No Yes\nBubble\nsort Ω(n) Θ(n²) O(n²)  Yes Yes\nHeap sort  Ω(n\nlog n)  Θ(n\nlog n)  O(n\nlog n)…\n[p18:c39] Searching and Sorting\nClassification  Explanation\nInternal vs\nExternal\nsorting  Internal: All data fits into main\nmemory (RAM).\nExternal: Used when data is too large to fit into memory and uses external\nstorage\nComparison\nvs Non -\ncomparison\nBased  Comparison: Sorting is done using\ncomparisons between elements\nNon-comparison: Uses digit -based\nor c…\n[p13:c28] ble of size M* N)\n3.Travelling salesman problem\nGiven a set of cities and distances between ever y\npair of cities, the goal is to find the shortest\npossible tour that visits each city exactly once andreturns to the starting city.\nThis is equivalent to finding the minimum cost\nHamiltonian cycle.A cost/distance function C(i, j) representing the costt…", "draft_gold_evidence": "[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p18:c40] Algorithm  Time complexity  Stable\nsorting  In\nplace\nsorting\nBest Avera\nge Worst\nQuick sort  Ω(n\nlog n)  Θ(n\nlog n)  O(n²)  No Yes\nMerge\nsort Ω(n\nlog n)  Θ(n\nlog n)  O(n\nlog n)  Yes No\nInsertion\nsort Ω(n) Θ(n²) O(n²)  Yes Yes\nSelection\nsort Ω(n²) Θ(n²) O(n²)  No Yes\nBubble\nsort Ω(n) Θ(n²) O(n²)  Yes Yes\nHeap sort  Ω(n\nlog n)  Θ(n\nlog n)  O(n\nlog n)…\n[p18:c39] Searching and Sorting\nClassification  Explanation\nInternal vs\nExternal\nsorting  Internal: All data fits into main\nmemory (RAM).\nExternal: Used when data is too large to fit into memory and uses external\nstorage\nComparison\nvs Non -\ncomparison\nBased  Comparison: Sorting is done using\ncomparisons between elements\nNon-comparison: Uses digit -based\nor c…\n[p13:c28] ble of size M* N)\n3.Travelling salesman problem\nGiven a set of cities and distances between ever y\npair of cities, the goal is to find the shortest\npossible tour that visits each city exactly once andreturns to the starting city.\nThis is equivalent to finding the minimum cost\nHamiltonian cycle.A cost/distance function C(i, j) representing the costt…", "draft_gold_answer": "aph that is bi-connected. ALGORITHMS GATE फर्रे Articulation point (cut vertex) Articulation Point : A vertex whose removal increases the number of connected components in a graph. Page No:- 15"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 5 key concepts covered.", "gold_answer": "Divide and conquer problem 1. Finding minimum and maximum T(n) = 2T(n/2) + 2 , n>2 Time complexity using DAC : T(n) = O(n) Space complexity using DAC : T(n) = O(logn) 2.Power of an element Recurrence relation T(n) = 1 if n = 1T(n) = T(n/2) + C if n > 1 Time co…", "gold_evidence": "[p8:c14] Divide and conquer problem\n1. Finding minimum and maximum\nT(n) = 2T(n/2) + 2 , n>2\nTime complexity using DAC : T(n) = O(n)\nSpace complexity using DAC  :\nT(n) = O(logn)\n2.Power of an element\nRecurrence relation\nT(n) = 1 if n = 1T(n) = T(n/2) + C if n > 1\nTime complexity  : O(logn)\nSpace complexity  : O(logn)\n3.Binary Search Algorithm\nNote: Provided…\n[p12:c22] ●For e ach activity, check if its start time  is greater\nthan or equal to  the finish time of the last\nselected activity .\n●If the condition holds, select the activity  and\nupdate the last selected finish time.\nTime complexity\nIf activities are not sorted  by finish time:\n●Sorting takes O(nlog ⁡n)\n●Selecting activities takes O(n)O(n)O(n)\n●Total tim…\n[p3:c3] Asymptotic notation does not satisfy trichotomy\nproperty\nex: f(n) = n, g(n) = n * |sin(n)|, n > 0\n∴ These two functions cannot converge\nExample\n1.Loop\nfor ( i = 1; i <= n; i++) {\nx=y+z;\n}\nT(n) = O(n)\n2.Nested loop\nfor(i=1; i<=n; i++){\nfor(j=1; j<=n; j++){\nk= k+1;\n}\nT(n) = O(n2)\n3.Logarithm\nfor(i=1; i<=n ; i *= 2){\nk=k+1;\n}\nfor (int i = 1; i <= n; i…\n[p17:c36] Applicatio n of DFS & BSF\nTime complexity  of DFS and BFS depends upon\nrepresentation of Graph:\n(i)Adjacency matrix : O(V²)\n(ii)Adjacency list: O(V + E)\nBoth DFS and BFS can be used to detect the presence\nof cycle  in the graph.\nBoth DFS and BFS can be used to know whether the\ngiven graph is connected  or not.\nBoth DFS and BFS can be used to know w…", "draft_gold_evidence": "[p8:c14] Divide and conquer problem\n1. Finding minimum and maximum\nT(n) = 2T(n/2) + 2 , n>2\nTime complexity using DAC : T(n) = O(n)\nSpace complexity using DAC  :\nT(n) = O(logn)\n2.Power of an element\nRecurrence relation\nT(n) = 1 if n = 1T(n) = T(n/2) + C if n > 1\nTime complexity  : O(logn)\nSpace complexity  : O(logn)\n3.Binary Search Algorithm\nNote: Provided…\n[p12:c22] ●For e ach activity, check if its start time  is greater\nthan or equal to  the finish time of the last\nselected activity .\n●If the condition holds, select the activity  and\nupdate the last selected finish time.\nTime complexity\nIf activities are not sorted  by finish time:\n●Sorting takes O(nlog ⁡n)\n●Selecting activities takes O(n)O(n)O(n)\n●Total tim…\n[p3:c3] Asymptotic notation does not satisfy trichotomy\nproperty\nex: f(n) = n, g(n) = n * |sin(n)|, n > 0\n∴ These two functions cannot converge\nExample\n1.Loop\nfor ( i = 1; i <= n; i++) {\nx=y+z;\n}\nT(n) = O(n)\n2.Nested loop\nfor(i=1; i<=n; i++){\nfor(j=1; j<=n; j++){\nk= k+1;\n}\nT(n) = O(n2)\n3.Logarithm\nfor(i=1; i<=n ; i *= 2){\nk=k+1;\n}\nfor (int i = 1; i <= n; i…\n[p17:c36] Applicatio n of DFS & BSF\nTime complexity  of DFS and BFS depends upon\nrepresentation of Graph:\n(i)Adjacency matrix : O(V²)\n(ii)Adjacency list: O(V + E)\nBoth DFS and BFS can be used to detect the presence\nof cycle  in the graph.\nBoth DFS and BFS can be used to know whether the\ngiven graph is connected  or not.\nBoth DFS and BFS can be used to know w…", "draft_gold_answer": "Divide and conquer problem 1. Finding minimum and maximum T(n) = 2T(n/2) + 2 , n>2 Time complexity using DAC : T(n) = O(n) Space complexity using DAC : T(n) = O(logn) 2.Power of an element Recurrence relation T(n) = 1 if n = 1T(n) = T(n/2) + C if n > 1 Time co…"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Define two important terms exactly as stated in the notes.", "gold_answer": "aph that is bi-connected. ALGORITHMS GATE फर्रे Articulation point (cut vertex) Articulation Point : A vertex whose removal increases the number of connected components in a graph. Page No:- 15", "gold_evidence": "[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p17:c36] Applicatio n of DFS & BSF\nTime complexity  of DFS and BFS depends upon\nrepresentation of Graph:\n(i)Adjacency matrix : O(V²)\n(ii)Adjacency list: O(V + E)\nBoth DFS and BFS can be used to detect the presence\nof cycle  in the graph.\nBoth DFS and BFS can be used to know whether the\ngiven graph is connected  or not.\nBoth DFS and BFS can be used to know w…\n[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p8:c16] that i<j and arr[i] > arr[j])\nTime complexity : O(nlogn)\nSpace complexity : O(n)(due to merges)\n9.Closest pair of points (Find the minimum Euclidea n\ndistance between any two points in a 2D plane.)\nRecurrence relation => T(n) = 2T(n/2)  + O(n)\nTime complexity  = O(nlogn)\nSorting copies (x -sorted, y- sorted): O(n)\nAuxiliary space (recursion stack):…", "draft_gold_evidence": "[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p17:c36] Applicatio n of DFS & BSF\nTime complexity  of DFS and BFS depends upon\nrepresentation of Graph:\n(i)Adjacency matrix : O(V²)\n(ii)Adjacency list: O(V + E)\nBoth DFS and BFS can be used to detect the presence\nof cycle  in the graph.\nBoth DFS and BFS can be used to know whether the\ngiven graph is connected  or not.\nBoth DFS and BFS can be used to know w…\n[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p8:c16] that i<j and arr[i] > arr[j])\nTime complexity : O(nlogn)\nSpace complexity : O(n)(due to merges)\n9.Closest pair of points (Find the minimum Euclidea n\ndistance between any two points in a 2D plane.)\nRecurrence relation => T(n) = 2T(n/2)  + O(n)\nTime complexity  = O(nlogn)\nSorting copies (x -sorted, y- sorted): O(n)\nAuxiliary space (recursion stack):…", "draft_gold_answer": "aph that is bi-connected. ALGORITHMS GATE फर्रे Articulation point (cut vertex) Articulation Point : A vertex whose removal increases the number of connected components in a graph. Page No:- 15"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Write one formula/equation mentioned in the notes (as written).", "gold_answer": "aph that is bi-connected. ALGORITHMS GATE फर्रे Articulation point (cut vertex) Articulation Point : A vertex whose removal increases the number of connected components in a graph. Page No:- 15", "gold_evidence": "[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p11:c21] ue/weight ratio. Pick greedy until\ncapacity is full.for(i=1;i<=n;i++)a[i] = Profit(i)/weight(i)Take one by one object from a and keep i n\nknapsack until knapsack becomes full arrange arra y\na in ascending order\nTime complexity : O(n log n)\n4.Activity  selection problem  (You are given n\nactivities , each with a start time  and finish time .\nThe goa…\n[p11:c19] Module 3 : Greedy Algorithm\nThe greedy technique algorithm is a method that\nmakes the locally optimal choice at each step with\nthe hope of finding a global optimum, without reconsidering previous choices.\nApplication of Greedy algorithm\n1.Job sequencing with deadline\nSchedule jobs to maximize profit  before thei r\ndeadlines (one job per time slot).…\n[p9:c17] 11.Longest Integer multiplication(LIM)\nint data type, can stores digits max 32767\nlong int data types, can store 4B/8B (8-10 digit s\nnumber)  not more than that .\nSolution : We can store long integer multiplicatio n\nin an arra y.\nT(n) = 4T(n/2) + b.n ; if n>1\nTime complexity : O(n^2)\nSpace complexity : O(logn)\nKaratsuba optimization :\nT(n) = 3T(n/2…", "draft_gold_evidence": "[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p11:c21] ue/weight ratio. Pick greedy until\ncapacity is full.for(i=1;i<=n;i++)a[i] = Profit(i)/weight(i)Take one by one object from a and keep i n\nknapsack until knapsack becomes full arrange arra y\na in ascending order\nTime complexity : O(n log n)\n4.Activity  selection problem  (You are given n\nactivities , each with a start time  and finish time .\nThe goa…\n[p11:c19] Module 3 : Greedy Algorithm\nThe greedy technique algorithm is a method that\nmakes the locally optimal choice at each step with\nthe hope of finding a global optimum, without reconsidering previous choices.\nApplication of Greedy algorithm\n1.Job sequencing with deadline\nSchedule jobs to maximize profit  before thei r\ndeadlines (one job per time slot).…\n[p9:c17] 11.Longest Integer multiplication(LIM)\nint data type, can stores digits max 32767\nlong int data types, can store 4B/8B (8-10 digit s\nnumber)  not more than that .\nSolution : We can store long integer multiplicatio n\nin an arra y.\nT(n) = 4T(n/2) + b.n ; if n>1\nTime complexity : O(n^2)\nSpace complexity : O(logn)\nKaratsuba optimization :\nT(n) = 3T(n/2…", "draft_gold_answer": "aph that is bi-connected. ALGORITHMS GATE फर्रे Articulation point (cut vertex) Articulation Point : A vertex whose removal increases the number of connected components in a graph. Page No:- 15"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List the steps of one algorithm/procedure described in the notes.", "gold_answer": "Algorithm Time complexity Stable sorting In place sorting Best Avera ge Worst Quick sort Ω(n log n) Θ(n log n) O(n²) No Yes Merge sort Ω(n log n) Θ(n log n) O(n log n) Yes No Insertion sort Ω(n) Θ(n²) O(n²) Yes Yes Selection sort Ω(n²) Θ(n²) O(n²) No Yes Bubbl…", "gold_evidence": "[p18:c40] Algorithm  Time complexity  Stable\nsorting  In\nplace\nsorting\nBest Avera\nge Worst\nQuick sort  Ω(n\nlog n)  Θ(n\nlog n)  O(n²)  No Yes\nMerge\nsort Ω(n\nlog n)  Θ(n\nlog n)  O(n\nlog n)  Yes No\nInsertion\nsort Ω(n) Θ(n²) O(n²)  Yes Yes\nSelection\nsort Ω(n²) Θ(n²) O(n²)  No Yes\nBubble\nsort Ω(n) Θ(n²) O(n²)  Yes Yes\nHeap sort  Ω(n\nlog n)  Θ(n\nlog n)  O(n\nlog n)…\n[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…\n[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p11:c21] ue/weight ratio. Pick greedy until\ncapacity is full.for(i=1;i<=n;i++)a[i] = Profit(i)/weight(i)Take one by one object from a and keep i n\nknapsack until knapsack becomes full arrange arra y\na in ascending order\nTime complexity : O(n log n)\n4.Activity  selection problem  (You are given n\nactivities , each with a start time  and finish time .\nThe goa…", "draft_gold_evidence": "[p18:c40] Algorithm  Time complexity  Stable\nsorting  In\nplace\nsorting\nBest Avera\nge Worst\nQuick sort  Ω(n\nlog n)  Θ(n\nlog n)  O(n²)  No Yes\nMerge\nsort Ω(n\nlog n)  Θ(n\nlog n)  O(n\nlog n)  Yes No\nInsertion\nsort Ω(n) Θ(n²) O(n²)  Yes Yes\nSelection\nsort Ω(n²) Θ(n²) O(n²)  No Yes\nBubble\nsort Ω(n) Θ(n²) O(n²)  Yes Yes\nHeap sort  Ω(n\nlog n)  Θ(n\nlog n)  O(n\nlog n)…\n[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…\n[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p11:c21] ue/weight ratio. Pick greedy until\ncapacity is full.for(i=1;i<=n;i++)a[i] = Profit(i)/weight(i)Take one by one object from a and keep i n\nknapsack until knapsack becomes full arrange arra y\na in ascending order\nTime complexity : O(n log n)\n4.Activity  selection problem  (You are given n\nactivities , each with a start time  and finish time .\nThe goa…", "draft_gold_answer": "Algorithm Time complexity Stable sorting In place sorting Best Avera ge Worst Quick sort Ω(n log n) Θ(n log n) O(n²) No Yes Merge sort Ω(n log n) Θ(n log n) O(n log n) Yes No Insertion sort Ω(n) Θ(n²) O(n²) Yes Yes Selection sort Ω(n²) Θ(n²) O(n²) No Yes Bubbl…"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Compare two related concepts/methods mentioned (give at least one difference).", "gold_answer": "Module 3 : Greedy Algorithm The greedy technique algorithm is a method that makes the locally optimal choice at each step with the hope of finding a global optimum, without reconsidering previous choices. Application of Greedy algorithm 1.Job sequencing with d…", "gold_evidence": "[p11:c19] Module 3 : Greedy Algorithm\nThe greedy technique algorithm is a method that\nmakes the locally optimal choice at each step with\nthe hope of finding a global optimum, without reconsidering previous choices.\nApplication of Greedy algorithm\n1.Job sequencing with deadline\nSchedule jobs to maximize profit  before thei r\ndeadlines (one job per time slot).…\n[p4:c6] Master Theorem:\nLet f(n) is a positive function and T (n) is defined\nrecurrence relation:\nT(n) = aT(n/b) + f(n)\nWhere a >= 1 and b > 1 are two positive constants.\nCase 1:\nIf f(n) = O(n(logb a− ∈)) for some constant ∈ > o then T(n)\n= θ (n(logb a) )\nCase 2:\nIf f(n) = θ  (n(logb a) ), then T(n) = θ  (n(logb a) *log n)\nCase 3:\nIf f(n) = Ω  (n(logb a+∈)…\n[p4:c7] /b)) , if a > 1Common Recurrence Relation\nAnalogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n●If f(n) is O(g(n)) : a ≤ b (f grows slower tha n\nsome multiple of g)\n●If f(n) is Ω (g(n)) : a ≥ b (f grows faster than\nsome multiple of g)\n●If f(n) is Θ (g(n)) : a = b (f grows at same rate of\ng)\n●If f(n) i…\n[p5:c9] Discrete Properties of Asymptotic Notation\nAnalogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n●If f(n) is O(g(n)) : a ≤ b (f grows slower than so me\nmultiple of g)\n●If f(n) is Ω (g(n)) : a ≥ b (f grows faster than so me\nmultiple of g)\n●If f(n) is Θ (g(n)) : a = b (f grows at same rate of g)\n●If f(n)…", "draft_gold_evidence": "[p11:c19] Module 3 : Greedy Algorithm\nThe greedy technique algorithm is a method that\nmakes the locally optimal choice at each step with\nthe hope of finding a global optimum, without reconsidering previous choices.\nApplication of Greedy algorithm\n1.Job sequencing with deadline\nSchedule jobs to maximize profit  before thei r\ndeadlines (one job per time slot).…\n[p4:c6] Master Theorem:\nLet f(n) is a positive function and T (n) is defined\nrecurrence relation:\nT(n) = aT(n/b) + f(n)\nWhere a >= 1 and b > 1 are two positive constants.\nCase 1:\nIf f(n) = O(n(logb a− ∈)) for some constant ∈ > o then T(n)\n= θ (n(logb a) )\nCase 2:\nIf f(n) = θ  (n(logb a) ), then T(n) = θ  (n(logb a) *log n)\nCase 3:\nIf f(n) = Ω  (n(logb a+∈)…\n[p4:c7] /b)) , if a > 1Common Recurrence Relation\nAnalogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n●If f(n) is O(g(n)) : a ≤ b (f grows slower tha n\nsome multiple of g)\n●If f(n) is Ω (g(n)) : a ≥ b (f grows faster than\nsome multiple of g)\n●If f(n) is Θ (g(n)) : a = b (f grows at same rate of\ng)\n●If f(n) i…\n[p5:c9] Discrete Properties of Asymptotic Notation\nAnalogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n●If f(n) is O(g(n)) : a ≤ b (f grows slower than so me\nmultiple of g)\n●If f(n) is Ω (g(n)) : a ≥ b (f grows faster than so me\nmultiple of g)\n●If f(n) is Θ (g(n)) : a = b (f grows at same rate of g)\n●If f(n)…", "draft_gold_answer": "Module 3 : Greedy Algorithm The greedy technique algorithm is a method that makes the locally optimal choice at each step with the hope of finding a global optimum, without reconsidering previous choices. Application of Greedy algorithm 1.Job sequencing with d…"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List any assumptions, prerequisites, or constraints mentioned.", "gold_answer": "Applicatio n of DFS & BSF Time complexity of DFS and BFS depends upon representation of Graph: (i)Adjacency matrix : O(V²) (ii)Adjacency list: O(V + E) Both DFS and BFS can be used to detect the presence of cycle in the graph. Both DFS and BFS can be used to k…", "gold_evidence": "[p17:c36] Applicatio n of DFS & BSF\nTime complexity  of DFS and BFS depends upon\nrepresentation of Graph:\n(i)Adjacency matrix : O(V²)\n(ii)Adjacency list: O(V + E)\nBoth DFS and BFS can be used to detect the presence\nof cycle  in the graph.\nBoth DFS and BFS can be used to know whether the\ngiven graph is connected  or not.\nBoth DFS and BFS can be used to know w…\n[p12:c22] ●For e ach activity, check if its start time  is greater\nthan or equal to  the finish time of the last\nselected activity .\n●If the condition holds, select the activity  and\nupdate the last selected finish time.\nTime complexity\nIf activities are not sorted  by finish time:\n●Sorting takes O(nlog ⁡n)\n●Selecting activities takes O(n)O(n)O(n)\n●Total tim…\n[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…\n[p2:c2] h that  two positive constants c > 0, n0 ≥  1.\nAnalogy between real no & asymptot ic notation\n: Let a, b are two real no & f, g two positive\nfunctions If f(n) is O(g(n)) : a ≤ b\n●If f(n) is Ω (g(n)) : a ≥ b\n●If f(n) is Θ (g(n)) : a =  b\n●If f(n) is o(g(n)) : a < b\n●If f(n) is ω (g(n)) : a > b\nRate of growth of function\n[Highest]  —> n! —> 4n —> 2n…", "draft_gold_evidence": "[p17:c36] Applicatio n of DFS & BSF\nTime complexity  of DFS and BFS depends upon\nrepresentation of Graph:\n(i)Adjacency matrix : O(V²)\n(ii)Adjacency list: O(V + E)\nBoth DFS and BFS can be used to detect the presence\nof cycle  in the graph.\nBoth DFS and BFS can be used to know whether the\ngiven graph is connected  or not.\nBoth DFS and BFS can be used to know w…\n[p12:c22] ●For e ach activity, check if its start time  is greater\nthan or equal to  the finish time of the last\nselected activity .\n●If the condition holds, select the activity  and\nupdate the last selected finish time.\nTime complexity\nIf activities are not sorted  by finish time:\n●Sorting takes O(nlog ⁡n)\n●Selecting activities takes O(n)O(n)O(n)\n●Total tim…\n[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…\n[p2:c2] h that  two positive constants c > 0, n0 ≥  1.\nAnalogy between real no & asymptot ic notation\n: Let a, b are two real no & f, g two positive\nfunctions If f(n) is O(g(n)) : a ≤ b\n●If f(n) is Ω (g(n)) : a ≥ b\n●If f(n) is Θ (g(n)) : a =  b\n●If f(n) is o(g(n)) : a < b\n●If f(n) is ω (g(n)) : a > b\nRate of growth of function\n[Highest]  —> n! —> 4n —> 2n…", "draft_gold_answer": "Applicatio n of DFS & BSF Time complexity of DFS and BFS depends upon representation of Graph: (i)Adjacency matrix : O(V²) (ii)Adjacency list: O(V + E) Both DFS and BFS can be used to detect the presence of cycle in the graph. Both DFS and BFS can be used to k…"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Give one example mentioned in the notes.", "gold_answer": "aph that is bi-connected. ALGORITHMS GATE फर्रे Articulation point (cut vertex) Articulation Point : A vertex whose removal increases the number of connected components in a graph. Page No:- 15", "gold_evidence": "[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p16:c35] in the spanning tree\n3.Back edge: Leads from a node to its ancestors\n4.Cross edge: Leads to a node which is neit her\nascending nor descending.\nDFS in Directed graph acyclic graph\nTopological Sort:  Linear order of the vertices representing the activities maintaining precedence.\nExample below.\nTopological sort(){\n1.DFS(v).\n2.Arrange all the nodes of…\n[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p11:c21] ue/weight ratio. Pick greedy until\ncapacity is full.for(i=1;i<=n;i++)a[i] = Profit(i)/weight(i)Take one by one object from a and keep i n\nknapsack until knapsack becomes full arrange arra y\na in ascending order\nTime complexity : O(n log n)\n4.Activity  selection problem  (You are given n\nactivities , each with a start time  and finish time .\nThe goa…", "draft_gold_evidence": "[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p16:c35] in the spanning tree\n3.Back edge: Leads from a node to its ancestors\n4.Cross edge: Leads to a node which is neit her\nascending nor descending.\nDFS in Directed graph acyclic graph\nTopological Sort:  Linear order of the vertices representing the activities maintaining precedence.\nExample below.\nTopological sort(){\n1.DFS(v).\n2.Arrange all the nodes of…\n[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p11:c21] ue/weight ratio. Pick greedy until\ncapacity is full.for(i=1;i<=n;i++)a[i] = Profit(i)/weight(i)Take one by one object from a and keep i n\nknapsack until knapsack becomes full arrange arra y\na in ascending order\nTime complexity : O(n log n)\n4.Activity  selection problem  (You are given n\nactivities , each with a start time  and finish time .\nThe goa…", "draft_gold_answer": "aph that is bi-connected. ALGORITHMS GATE फर्रे Articulation point (cut vertex) Articulation Point : A vertex whose removal increases the number of connected components in a graph. Page No:- 15"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What are the advantages and limitations of the main method/topic (as stated)?", "gold_answer": "Module 4 : Dynamic Programming Use case of Tabulation and memoization method ●If the original problem requires all subproblems to be so lved, then tabulation is usually more efficient than memoization. ●Tabulation avoids the overhead of recursion and can use a…", "gold_evidence": "[p13:c26] Module 4 : Dynamic Programming\nUse case of Tabulation and memoization method\n●If the original problem requires all subproblems  to\nbe so lved, then tabulation  is usually more efficient\nthan memoization.\n●Tabulation  avoids the overhead of recursion  and\ncan use a preallocated array, leading to bett er\nperformance in both time and space in some cas…\n[p17:c36] Applicatio n of DFS & BSF\nTime complexity  of DFS and BFS depends upon\nrepresentation of Graph:\n(i)Adjacency matrix : O(V²)\n(ii)Adjacency list: O(V + E)\nBoth DFS and BFS can be used to detect the presence\nof cycle  in the graph.\nBoth DFS and BFS can be used to know whether the\ngiven graph is connected  or not.\nBoth DFS and BFS can be used to know w…\n[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p17:c37] ed graph is a maximal set of vertices such that for every\npair of vertices u and v in the set, there is a path from\nu to v and a path from v to u.\nProperties of Str ongly Connected Components\n1.Every directed graph is a D.A.G. of strongly\nconnected components.\n2.Let C and C′ b e distinct strongly connected\ncomponents in directed graph G = (V, E). L…", "draft_gold_evidence": "[p13:c26] Module 4 : Dynamic Programming\nUse case of Tabulation and memoization method\n●If the original problem requires all subproblems  to\nbe so lved, then tabulation  is usually more efficient\nthan memoization.\n●Tabulation  avoids the overhead of recursion  and\ncan use a preallocated array, leading to bett er\nperformance in both time and space in some cas…\n[p17:c36] Applicatio n of DFS & BSF\nTime complexity  of DFS and BFS depends upon\nrepresentation of Graph:\n(i)Adjacency matrix : O(V²)\n(ii)Adjacency list: O(V + E)\nBoth DFS and BFS can be used to detect the presence\nof cycle  in the graph.\nBoth DFS and BFS can be used to know whether the\ngiven graph is connected  or not.\nBoth DFS and BFS can be used to know w…\n[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p17:c37] ed graph is a maximal set of vertices such that for every\npair of vertices u and v in the set, there is a path from\nu to v and a path from v to u.\nProperties of Str ongly Connected Components\n1.Every directed graph is a D.A.G. of strongly\nconnected components.\n2.Let C and C′ b e distinct strongly connected\ncomponents in directed graph G = (V, E). L…", "draft_gold_answer": "Module 4 : Dynamic Programming Use case of Tabulation and memoization method ●If the original problem requires all subproblems to be so lved, then tabulation is usually more efficient than memoization. ●Tabulation avoids the overhead of recursion and can use a…"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Summarize the key takeaways in 3 bullet points.", "gold_answer": "ed graph is a maximal set of vertices such that for every pair of vertices u and v in the set, there is a path from u to v and a path from v to u. Properties of Str ongly Connected Components 1.Every directed graph is a D.A.G. of strongly connected components.…", "gold_evidence": "[p17:c37] ed graph is a maximal set of vertices such that for every\npair of vertices u and v in the set, there is a path from\nu to v and a path from v to u.\nProperties of Str ongly Connected Components\n1.Every directed graph is a D.A.G. of strongly\nconnected components.\n2.Let C and C′ b e distinct strongly connected\ncomponents in directed graph G = (V, E). L…\n[p8:c15] ort Algorithm\nBest Case / Average CaseT(n) = 1 ; if n = 1.T(n) = 2T(n/2) + n + C, if n>1Time complexity : O(n logn)\nWorst case :  T(n) = n + T(n -1) + C ; if n > 1\nNote: Quick sort behaves in worst case w hen\nelement are already sorted\nTime complexity : O(n^2)6.Matrix Multiplication\nI. Using DAC: T(n) = 8T(n/2)+O(n^2), for n>1\nT(n) = O(n^3)\nII.Stra…\n[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p16:c35] in the spanning tree\n3.Back edge: Leads from a node to its ancestors\n4.Cross edge: Leads to a node which is neit her\nascending nor descending.\nDFS in Directed graph acyclic graph\nTopological Sort:  Linear order of the vertices representing the activities maintaining precedence.\nExample below.\nTopological sort(){\n1.DFS(v).\n2.Arrange all the nodes of…", "draft_gold_evidence": "[p17:c37] ed graph is a maximal set of vertices such that for every\npair of vertices u and v in the set, there is a path from\nu to v and a path from v to u.\nProperties of Str ongly Connected Components\n1.Every directed graph is a D.A.G. of strongly\nconnected components.\n2.Let C and C′ b e distinct strongly connected\ncomponents in directed graph G = (V, E). L…\n[p8:c15] ort Algorithm\nBest Case / Average CaseT(n) = 1 ; if n = 1.T(n) = 2T(n/2) + n + C, if n>1Time complexity : O(n logn)\nWorst case :  T(n) = n + T(n -1) + C ; if n > 1\nNote: Quick sort behaves in worst case w hen\nelement are already sorted\nTime complexity : O(n^2)6.Matrix Multiplication\nI. Using DAC: T(n) = 8T(n/2)+O(n^2), for n>1\nT(n) = O(n^3)\nII.Stra…\n[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p16:c35] in the spanning tree\n3.Back edge: Leads from a node to its ancestors\n4.Cross edge: Leads to a node which is neit her\nascending nor descending.\nDFS in Directed graph acyclic graph\nTopological Sort:  Linear order of the vertices representing the activities maintaining precedence.\nExample below.\nTopological sort(){\n1.DFS(v).\n2.Arrange all the nodes of…", "draft_gold_answer": "ed graph is a maximal set of vertices such that for every pair of vertices u and v in the set, there is a path from u to v and a path from v to u. Properties of Str ongly Connected Components 1.Every directed graph is a D.A.G. of strongly connected components.…"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Is there any deadline/submission instruction in the document? If not, answer 'Not found in the document.'", "gold_answer": "Applicatio n of DFS & BSF Time complexity of DFS and BFS depends upon representation of Graph: (i)Adjacency matrix : O(V²) (ii)Adjacency list: O(V + E) Both DFS and BFS can be used to detect the presence of cycle in the graph. Both DFS and BFS can be used to k…", "gold_evidence": "[p17:c36] Applicatio n of DFS & BSF\nTime complexity  of DFS and BFS depends upon\nrepresentation of Graph:\n(i)Adjacency matrix : O(V²)\n(ii)Adjacency list: O(V + E)\nBoth DFS and BFS can be used to detect the presence\nof cycle  in the graph.\nBoth DFS and BFS can be used to know whether the\ngiven graph is connected  or not.\nBoth DFS and BFS can be used to know w…\n[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p5:c9] Discrete Properties of Asymptotic Notation\nAnalogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n●If f(n) is O(g(n)) : a ≤ b (f grows slower than so me\nmultiple of g)\n●If f(n) is Ω (g(n)) : a ≥ b (f grows faster than so me\nmultiple of g)\n●If f(n) is Θ (g(n)) : a = b (f grows at same rate of g)\n●If f(n)…\n[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15", "draft_gold_evidence": "[p17:c36] Applicatio n of DFS & BSF\nTime complexity  of DFS and BFS depends upon\nrepresentation of Graph:\n(i)Adjacency matrix : O(V²)\n(ii)Adjacency list: O(V + E)\nBoth DFS and BFS can be used to detect the presence\nof cycle  in the graph.\nBoth DFS and BFS can be used to know whether the\ngiven graph is connected  or not.\nBoth DFS and BFS can be used to know w…\n[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p5:c9] Discrete Properties of Asymptotic Notation\nAnalogy between real no & asymptotic notation\nLet a, b are two real no & f, g two positive functions\n●If f(n) is O(g(n)) : a ≤ b (f grows slower than so me\nmultiple of g)\n●If f(n) is Ω (g(n)) : a ≥ b (f grows faster than so me\nmultiple of g)\n●If f(n) is Θ (g(n)) : a = b (f grows at same rate of g)\n●If f(n)…\n[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15", "draft_gold_answer": "Applicatio n of DFS & BSF Time complexity of DFS and BFS depends upon representation of Graph: (i)Adjacency matrix : O(V²) (ii)Adjacency list: O(V + E) Both DFS and BFS can be used to detect the presence of cycle in the graph. Both DFS and BFS can be used to k…"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one definition stated in the notes? Quote it exactly if present; otherwise answer 'Not found in the document.'", "gold_answer": "cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units. Asymptotic Notations θ-Notation Let f(n) and g(n) be two positive functions f(n) = θ (g(n)) if and only if f(n) ≤ c1 . g(n) and f(n) ≥ c2 .…", "gold_evidence": "[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…\n[p14:c30] Time complexity:\n●Without DP : O(n!)\n●With DP : O(n^3)\nSpace complexity:\n●Without DP : O(n)\n●With DP : O(n^2)\n5. Sum of subset problem\nGiven a  set of numbers W[1...N] and a value M ,\ndetermine if there exists a subset whose sum i s\nexactly M.\nRecursive Relation:\nSoS(M, N, S) =\nreturn(S)   ;          if M = 0\nreturn( -1)   ;             if N = 0\nSo…\n[p13:c28] ble of size M* N)\n3.Travelling salesman problem\nGiven a set of cities and distances between ever y\npair of cities, the goal is to find the shortest\npossible tour that visits each city exactly once andreturns to the starting city.\nThis is equivalent to finding the minimum cost\nHamiltonian cycle.A cost/distance function C(i, j) representing the costt…", "draft_gold_evidence": "[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…\n[p14:c30] Time complexity:\n●Without DP : O(n!)\n●With DP : O(n^3)\nSpace complexity:\n●Without DP : O(n)\n●With DP : O(n^2)\n5. Sum of subset problem\nGiven a  set of numbers W[1...N] and a value M ,\ndetermine if there exists a subset whose sum i s\nexactly M.\nRecursive Relation:\nSoS(M, N, S) =\nreturn(S)   ;          if M = 0\nreturn( -1)   ;             if N = 0\nSo…\n[p13:c28] ble of size M* N)\n3.Travelling salesman problem\nGiven a set of cities and distances between ever y\npair of cities, the goal is to find the shortest\npossible tour that visits each city exactly once andreturns to the starting city.\nThis is equivalent to finding the minimum cost\nHamiltonian cycle.A cost/distance function C(i, j) representing the costt…", "draft_gold_answer": "cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units. Asymptotic Notations θ-Notation Let f(n) and g(n) be two positive functions f(n) = θ (g(n)) if and only if f(n) ≤ c1 . g(n) and f(n) ≥ c2 .…"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the time complexity of one algorithm mentioned (as stated)? If not present, answer 'Not found in the document.'", "gold_answer": "Algorithm Time complexity Stable sorting In place sorting Best Avera ge Worst Quick sort Ω(n log n) Θ(n log n) O(n²) No Yes Merge sort Ω(n log n) Θ(n log n) O(n log n) Yes No Insertion sort Ω(n) Θ(n²) O(n²) Yes Yes Selection sort Ω(n²) Θ(n²) O(n²) No Yes Bubbl…", "gold_evidence": "[p18:c40] Algorithm  Time complexity  Stable\nsorting  In\nplace\nsorting\nBest Avera\nge Worst\nQuick sort  Ω(n\nlog n)  Θ(n\nlog n)  O(n²)  No Yes\nMerge\nsort Ω(n\nlog n)  Θ(n\nlog n)  O(n\nlog n)  Yes No\nInsertion\nsort Ω(n) Θ(n²) O(n²)  Yes Yes\nSelection\nsort Ω(n²) Θ(n²) O(n²)  No Yes\nBubble\nsort Ω(n) Θ(n²) O(n²)  Yes Yes\nHeap sort  Ω(n\nlog n)  Θ(n\nlog n)  O(n\nlog n)…\n[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…\n[p9:c17] 11.Longest Integer multiplication(LIM)\nint data type, can stores digits max 32767\nlong int data types, can store 4B/8B (8-10 digit s\nnumber)  not more than that .\nSolution : We can store long integer multiplicatio n\nin an arra y.\nT(n) = 4T(n/2) + b.n ; if n>1\nTime complexity : O(n^2)\nSpace complexity : O(logn)\nKaratsuba optimization :\nT(n) = 3T(n/2…\n[p12:c22] ●For e ach activity, check if its start time  is greater\nthan or equal to  the finish time of the last\nselected activity .\n●If the condition holds, select the activity  and\nupdate the last selected finish time.\nTime complexity\nIf activities are not sorted  by finish time:\n●Sorting takes O(nlog ⁡n)\n●Selecting activities takes O(n)O(n)O(n)\n●Total tim…", "draft_gold_evidence": "[p18:c40] Algorithm  Time complexity  Stable\nsorting  In\nplace\nsorting\nBest Avera\nge Worst\nQuick sort  Ω(n\nlog n)  Θ(n\nlog n)  O(n²)  No Yes\nMerge\nsort Ω(n\nlog n)  Θ(n\nlog n)  O(n\nlog n)  Yes No\nInsertion\nsort Ω(n) Θ(n²) O(n²)  Yes Yes\nSelection\nsort Ω(n²) Θ(n²) O(n²)  No Yes\nBubble\nsort Ω(n) Θ(n²) O(n²)  Yes Yes\nHeap sort  Ω(n\nlog n)  Θ(n\nlog n)  O(n\nlog n)…\n[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…\n[p9:c17] 11.Longest Integer multiplication(LIM)\nint data type, can stores digits max 32767\nlong int data types, can store 4B/8B (8-10 digit s\nnumber)  not more than that .\nSolution : We can store long integer multiplicatio n\nin an arra y.\nT(n) = 4T(n/2) + b.n ; if n>1\nTime complexity : O(n^2)\nSpace complexity : O(logn)\nKaratsuba optimization :\nT(n) = 3T(n/2…\n[p12:c22] ●For e ach activity, check if its start time  is greater\nthan or equal to  the finish time of the last\nselected activity .\n●If the condition holds, select the activity  and\nupdate the last selected finish time.\nTime complexity\nIf activities are not sorted  by finish time:\n●Sorting takes O(nlog ⁡n)\n●Selecting activities takes O(n)O(n)O(n)\n●Total tim…", "draft_gold_answer": "Algorithm Time complexity Stable sorting In place sorting Best Avera ge Worst Quick sort Ω(n log n) Θ(n log n) O(n²) No Yes Merge sort Ω(n log n) Θ(n log n) O(n log n) Yes No Insertion sort Ω(n) Θ(n²) O(n²) Yes Yes Selection sort Ω(n²) Θ(n²) O(n²) No Yes Bubbl…"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 3 important keywords/terms that appear in the notes.", "gold_answer": "aph that is bi-connected. ALGORITHMS GATE फर्रे Articulation point (cut vertex) Articulation Point : A vertex whose removal increases the number of connected components in a graph. Page No:- 15", "gold_evidence": "[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p17:c36] Applicatio n of DFS & BSF\nTime complexity  of DFS and BFS depends upon\nrepresentation of Graph:\n(i)Adjacency matrix : O(V²)\n(ii)Adjacency list: O(V + E)\nBoth DFS and BFS can be used to detect the presence\nof cycle  in the graph.\nBoth DFS and BFS can be used to know whether the\ngiven graph is connected  or not.\nBoth DFS and BFS can be used to know w…\n[p17:c37] ed graph is a maximal set of vertices such that for every\npair of vertices u and v in the set, there is a path from\nu to v and a path from v to u.\nProperties of Str ongly Connected Components\n1.Every directed graph is a D.A.G. of strongly\nconnected components.\n2.Let C and C′ b e distinct strongly connected\ncomponents in directed graph G = (V, E). L…\n[p12:c24] vertices: ●Select the minimum-weight edge  that connects a\nvertex in the MST to a vertex outside.●Add the selected edge and vertex to the MST.\n●More efficient for dense graph\nTime complexity :\nAdjacency matrix + linear search = O(V^2)\nAdjacency list + binary heap = O(E log V)\nAdjacency list + Fibonacci heap = O(E + log V)\n6.Single source shortest p…", "draft_gold_evidence": "[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p17:c36] Applicatio n of DFS & BSF\nTime complexity  of DFS and BFS depends upon\nrepresentation of Graph:\n(i)Adjacency matrix : O(V²)\n(ii)Adjacency list: O(V + E)\nBoth DFS and BFS can be used to detect the presence\nof cycle  in the graph.\nBoth DFS and BFS can be used to know whether the\ngiven graph is connected  or not.\nBoth DFS and BFS can be used to know w…\n[p17:c37] ed graph is a maximal set of vertices such that for every\npair of vertices u and v in the set, there is a path from\nu to v and a path from v to u.\nProperties of Str ongly Connected Components\n1.Every directed graph is a D.A.G. of strongly\nconnected components.\n2.Let C and C′ b e distinct strongly connected\ncomponents in directed graph G = (V, E). L…\n[p12:c24] vertices: ●Select the minimum-weight edge  that connects a\nvertex in the MST to a vertex outside.●Add the selected edge and vertex to the MST.\n●More efficient for dense graph\nTime complexity :\nAdjacency matrix + linear search = O(V^2)\nAdjacency list + binary heap = O(E log V)\nAdjacency list + Fibonacci heap = O(E + log V)\n6.Single source shortest p…", "draft_gold_answer": "aph that is bi-connected. ALGORITHMS GATE फर्रे Articulation point (cut vertex) Articulation Point : A vertex whose removal increases the number of connected components in a graph. Page No:- 15"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one theorem/lemma/property stated? If not present, answer 'Not found in the document.'", "gold_answer": "T. For each edge in the sorted list: ●If the edge does not form a cycle with the MST formed so far, include it in the MST. Otherwi se discard the edge. Repeat until the MST includes V−1V - 1V−1 edg es (where VVV is the number of vertices). Time complexity : O(…", "gold_evidence": "[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…\n[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p2:c0] Module 1: Analysis of Algorithm\nAim : The goal of analysis of algorithms is to\ncompare algorithms mainly in terms of running time\nbut also in terms of other factors like memory, developer effort.\nNeed  for Analysis (Why to analyze || What to\nanalyze || How to analyze)\n1.To determine resource consumption\n<resource such that\nspace+time+cost+register>…", "draft_gold_evidence": "[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…\n[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p2:c0] Module 1: Analysis of Algorithm\nAim : The goal of analysis of algorithms is to\ncompare algorithms mainly in terms of running time\nbut also in terms of other factors like memory, developer effort.\nNeed  for Analysis (Why to analyze || What to\nanalyze || How to analyze)\n1.To determine resource consumption\n<resource such that\nspace+time+cost+register>…", "draft_gold_answer": "T. For each edge in the sorted list: ●If the edge does not form a cycle with the MST formed so far, include it in the MST. Otherwi se discard the edge. Repeat until the MST includes V−1V - 1V−1 edg es (where VVV is the number of vertices). Time complexity : O(…"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Describe one table/list mentioned (what items are compared or listed). If none, answer 'Not found in the document.'", "gold_answer": "BDC> Output : 2 <BC> Let, i & j denote indices of x & y. L(i, j) denote th e LCS of string x & y , n & m are length respectively. L(i, j) = 1 + L(i- 1, j-1) ; if x[i] = y[j] L(i, j) = max( L(i -1, j) , L(i , j- 1) ; if x[i] != y[j] L(-i, j) = 0 L(i, -j) = 0 Ti…", "gold_evidence": "[p13:c27] BDC>\nOutput : 2 <BC>\nLet, i & j denote indices of x & y. L(i, j) denote th e\nLCS of string x & y , n & m are length respectively.\nL(i, j) = 1 + L(i- 1, j-1) ; if x[i] = y[j]\nL(i, j) = max( L(i -1, j) , L(i , j- 1) ; if x[i] != y[j]\nL(-i, j) = 0\nL(i, -j) = 0\nTime complexity : O(n * m)Space complexity : O(n * m)\n2.0/1 Knapsack problem\nInput  : N item…\n[p17:c36] Applicatio n of DFS & BSF\nTime complexity  of DFS and BFS depends upon\nrepresentation of Graph:\n(i)Adjacency matrix : O(V²)\n(ii)Adjacency list: O(V + E)\nBoth DFS and BFS can be used to detect the presence\nof cycle  in the graph.\nBoth DFS and BFS can be used to know whether the\ngiven graph is connected  or not.\nBoth DFS and BFS can be used to know w…\n[p12:c22] ●For e ach activity, check if its start time  is greater\nthan or equal to  the finish time of the last\nselected activity .\n●If the condition holds, select the activity  and\nupdate the last selected finish time.\nTime complexity\nIf activities are not sorted  by finish time:\n●Sorting takes O(nlog ⁡n)\n●Selecting activities takes O(n)O(n)O(n)\n●Total tim…\n[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…", "draft_gold_evidence": "[p13:c27] BDC>\nOutput : 2 <BC>\nLet, i & j denote indices of x & y. L(i, j) denote th e\nLCS of string x & y , n & m are length respectively.\nL(i, j) = 1 + L(i- 1, j-1) ; if x[i] = y[j]\nL(i, j) = max( L(i -1, j) , L(i , j- 1) ; if x[i] != y[j]\nL(-i, j) = 0\nL(i, -j) = 0\nTime complexity : O(n * m)Space complexity : O(n * m)\n2.0/1 Knapsack problem\nInput  : N item…\n[p17:c36] Applicatio n of DFS & BSF\nTime complexity  of DFS and BFS depends upon\nrepresentation of Graph:\n(i)Adjacency matrix : O(V²)\n(ii)Adjacency list: O(V + E)\nBoth DFS and BFS can be used to detect the presence\nof cycle  in the graph.\nBoth DFS and BFS can be used to know whether the\ngiven graph is connected  or not.\nBoth DFS and BFS can be used to know w…\n[p12:c22] ●For e ach activity, check if its start time  is greater\nthan or equal to  the finish time of the last\nselected activity .\n●If the condition holds, select the activity  and\nupdate the last selected finish time.\nTime complexity\nIf activities are not sorted  by finish time:\n●Sorting takes O(nlog ⁡n)\n●Selecting activities takes O(n)O(n)O(n)\n●Total tim…\n[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…", "draft_gold_answer": "BDC> Output : 2 <BC> Let, i & j denote indices of x & y. L(i, j) denote th e LCS of string x & y , n & m are length respectively. L(i, j) = 1 + L(i- 1, j-1) ; if x[i] = y[j] L(i, j) = max( L(i -1, j) , L(i , j- 1) ; if x[i] != y[j] L(-i, j) = 0 L(i, -j) = 0 Ti…"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one stated limitation/constraint? If none, answer 'Not found in the document.'", "gold_answer": "T. For each edge in the sorted list: ●If the edge does not form a cycle with the MST formed so far, include it in the MST. Otherwi se discard the edge. Repeat until the MST includes V−1V - 1V−1 edg es (where VVV is the number of vertices). Time complexity : O(…", "gold_evidence": "[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…\n[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p11:c21] ue/weight ratio. Pick greedy until\ncapacity is full.for(i=1;i<=n;i++)a[i] = Profit(i)/weight(i)Take one by one object from a and keep i n\nknapsack until knapsack becomes full arrange arra y\na in ascending order\nTime complexity : O(n log n)\n4.Activity  selection problem  (You are given n\nactivities , each with a start time  and finish time .\nThe goa…", "draft_gold_evidence": "[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…\n[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p11:c21] ue/weight ratio. Pick greedy until\ncapacity is full.for(i=1;i<=n;i++)a[i] = Profit(i)/weight(i)Take one by one object from a and keep i n\nknapsack until knapsack becomes full arrange arra y\na in ascending order\nTime complexity : O(n log n)\n4.Activity  selection problem  (You are given n\nactivities , each with a start time  and finish time .\nThe goa…", "draft_gold_answer": "T. For each edge in the sorted list: ●If the edge does not form a cycle with the MST formed so far, include it in the MST. Otherwi se discard the edge. Repeat until the MST includes V−1V - 1V−1 edg es (where VVV is the number of vertices). Time complexity : O(…"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one stated advantage/benefit? If none, answer 'Not found in the document.'", "gold_answer": "T. For each edge in the sorted list: ●If the edge does not form a cycle with the MST formed so far, include it in the MST. Otherwi se discard the edge. Repeat until the MST includes V−1V - 1V−1 edg es (where VVV is the number of vertices). Time complexity : O(…", "gold_evidence": "[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…\n[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p2:c0] Module 1: Analysis of Algorithm\nAim : The goal of analysis of algorithms is to\ncompare algorithms mainly in terms of running time\nbut also in terms of other factors like memory, developer effort.\nNeed  for Analysis (Why to analyze || What to\nanalyze || How to analyze)\n1.To determine resource consumption\n<resource such that\nspace+time+cost+register>…", "draft_gold_evidence": "[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…\n[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p2:c0] Module 1: Analysis of Algorithm\nAim : The goal of analysis of algorithms is to\ncompare algorithms mainly in terms of running time\nbut also in terms of other factors like memory, developer effort.\nNeed  for Analysis (Why to analyze || What to\nanalyze || How to analyze)\n1.To determine resource consumption\n<resource such that\nspace+time+cost+register>…", "draft_gold_answer": "T. For each edge in the sorted list: ●If the edge does not form a cycle with the MST formed so far, include it in the MST. Otherwi se discard the edge. Repeat until the MST includes V−1V - 1V−1 edg es (where VVV is the number of vertices). Time complexity : O(…"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Provide one short quote (1–2 sentences) from the notes that best represents the topic.", "gold_answer": "Module 3 : Greedy Algorithm The greedy technique algorithm is a method that makes the locally optimal choice at each step with the hope of finding a global optimum, without reconsidering previous choices. Application of Greedy algorithm 1.Job sequencing with d…", "gold_evidence": "[p11:c19] Module 3 : Greedy Algorithm\nThe greedy technique algorithm is a method that\nmakes the locally optimal choice at each step with\nthe hope of finding a global optimum, without reconsidering previous choices.\nApplication of Greedy algorithm\n1.Job sequencing with deadline\nSchedule jobs to maximize profit  before thei r\ndeadlines (one job per time slot).…\n[p17:c37] ed graph is a maximal set of vertices such that for every\npair of vertices u and v in the set, there is a path from\nu to v and a path from v to u.\nProperties of Str ongly Connected Components\n1.Every directed graph is a D.A.G. of strongly\nconnected components.\n2.Let C and C′ b e distinct strongly connected\ncomponents in directed graph G = (V, E). L…\n[p5:c10] oes not satisfy trichotomy\npropertyEx: f(n) = n, g(n) = n ^ |sin(n)|, n > 0∴ These two functions cannot converge\n1.Reflexivef(n) = O(f(n))\nf(n) = Ω (f(n))\nf(n) = Θ (f(n))2.Symmetric\nf(n) = Θ (g(n)), iff g(n) = Θ(f(n))\n3.Transitive\nf(n) = Θ (g(n)) & g(n) = O(h(n))\nf(n) = O(h(n))Note : Ω  and Θ also satisfy transitivity\n4.Transpose Symmetric\nf(n) = O…\n[p11:c21] ue/weight ratio. Pick greedy until\ncapacity is full.for(i=1;i<=n;i++)a[i] = Profit(i)/weight(i)Take one by one object from a and keep i n\nknapsack until knapsack becomes full arrange arra y\na in ascending order\nTime complexity : O(n log n)\n4.Activity  selection problem  (You are given n\nactivities , each with a start time  and finish time .\nThe goa…", "draft_gold_evidence": "[p11:c19] Module 3 : Greedy Algorithm\nThe greedy technique algorithm is a method that\nmakes the locally optimal choice at each step with\nthe hope of finding a global optimum, without reconsidering previous choices.\nApplication of Greedy algorithm\n1.Job sequencing with deadline\nSchedule jobs to maximize profit  before thei r\ndeadlines (one job per time slot).…\n[p17:c37] ed graph is a maximal set of vertices such that for every\npair of vertices u and v in the set, there is a path from\nu to v and a path from v to u.\nProperties of Str ongly Connected Components\n1.Every directed graph is a D.A.G. of strongly\nconnected components.\n2.Let C and C′ b e distinct strongly connected\ncomponents in directed graph G = (V, E). L…\n[p5:c10] oes not satisfy trichotomy\npropertyEx: f(n) = n, g(n) = n ^ |sin(n)|, n > 0∴ These two functions cannot converge\n1.Reflexivef(n) = O(f(n))\nf(n) = Ω (f(n))\nf(n) = Θ (f(n))2.Symmetric\nf(n) = Θ (g(n)), iff g(n) = Θ(f(n))\n3.Transitive\nf(n) = Θ (g(n)) & g(n) = O(h(n))\nf(n) = O(h(n))Note : Ω  and Θ also satisfy transitivity\n4.Transpose Symmetric\nf(n) = O…\n[p11:c21] ue/weight ratio. Pick greedy until\ncapacity is full.for(i=1;i<=n;i++)a[i] = Profit(i)/weight(i)Take one by one object from a and keep i n\nknapsack until knapsack becomes full arrange arra y\na in ascending order\nTime complexity : O(n log n)\n4.Activity  selection problem  (You are given n\nactivities , each with a start time  and finish time .\nThe goa…", "draft_gold_answer": "Module 3 : Greedy Algorithm The greedy technique algorithm is a method that makes the locally optimal choice at each step with the hope of finding a global optimum, without reconsidering previous choices. Application of Greedy algorithm 1.Job sequencing with d…"}
{"doc_id": "0a21fd127fcc6c58", "pdf_path": "eval/pdfs/public/ALGORTIHM-SHORT-NOTES-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one abbreviation/acronym expanded in the notes? If none, answer 'Not found in the document.'", "gold_answer": "T. For each edge in the sorted list: ●If the edge does not form a cycle with the MST formed so far, include it in the MST. Otherwi se discard the edge. Repeat until the MST includes V−1V - 1V−1 edg es (where VVV is the number of vertices). Time complexity : O(…", "gold_evidence": "[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…\n[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p2:c0] Module 1: Analysis of Algorithm\nAim : The goal of analysis of algorithms is to\ncompare algorithms mainly in terms of running time\nbut also in terms of other factors like memory, developer effort.\nNeed  for Analysis (Why to analyze || What to\nanalyze || How to analyze)\n1.To determine resource consumption\n<resource such that\nspace+time+cost+register>…", "draft_gold_evidence": "[p12:c23] T.\nFor each edge in the sorted list:\n●If the edge does not form a cycle  with the MST\nformed so far, include it in the MST. Otherwi se\ndiscard the edge.\nRepeat until the MST includes V−1V - 1V−1 edg es\n(where VVV is the number of vertices).\nTime complexity : O(E log E) or O(E log V)\nNote : Works well with sparse graphs  (fewer\nedges). May produce a…\n[p17:c38] aph  that\nis bi-connected.\nALGORITHMS\nGATE फर्रे\nArticulation point (cut vertex)\nArticulation Point : A vertex whose removal\nincreases the number of connected components in a\ngraph.\nPage No:- 15\n[p2:c1] cient performance oftwo algorithms in a way such that it is platformindependent. It will not give real values in units.\nAsymptotic Notations\nθ-Notation\nLet f(n) and g(n) be two positive functions\nf(n) = θ (g(n)) if and only if\nf(n) ≤ c1 . g(n) and f(n) ≥ c2 . g(n)  ∀ n ≥  n0 such that there exists three positive constant\nc1 > 0, c2 > 0 and n0 ≥ 1\nO…\n[p2:c0] Module 1: Analysis of Algorithm\nAim : The goal of analysis of algorithms is to\ncompare algorithms mainly in terms of running time\nbut also in terms of other factors like memory, developer effort.\nNeed  for Analysis (Why to analyze || What to\nanalyze || How to analyze)\n1.To determine resource consumption\n<resource such that\nspace+time+cost+register>…", "draft_gold_answer": "T. For each edge in the sorted list: ●If the edge does not form a cycle with the MST formed so far, include it in the MST. Otherwi se discard the edge. Repeat until the MST includes V−1V - 1V−1 edg es (where VVV is the number of vertices). Time complexity : O(…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the main topic of these notes?", "gold_answer": "=9; ex. int a= 9, 8,7; is interpreted as : int a = 9; 8; 7; // so the final value of a =5; Syntax: ++x, --x We do the increment or decrement first then will use the value in the expression. Ex. int x = 5; int y = ++x; // x becomes 6, then y = 6 Syntax: x++, x…", "gold_evidence": "[p5:c8] =9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increment or decrement.\nint x = 5;\nint y =…\n[p10:c16] tf(\"I'll be rank 1\") && 0)\nBut when we see the short -circuiting, (printf (\"I'll\nbe rank 1\") && 0) will not execute.\nOutput: 1.\n•printf () is defined in the <stdio.h > header file.\n•It returns the number of characters it prints.\n•If an error occurs, it returns a negative number\n(usually -1).\n•Format specifiers like %s (for strings), %d (for\ninteger…\n[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p3:c2] When we try to store 129 in a char variable, it\ncauses an overflow because the value exceeds the\nmaximum limit of 127 (for signed char).\nSince it goes beyond the range, it wraps around using the cyclic property.\nLet’s understand it step- by-step:\n•If c = 128, it overflows by 1 step and wraps to -\n128 = - (129 -1)\n•If c = 129, it overflows by 2, so…", "draft_gold_evidence": "[p5:c8] =9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increment or decrement.\nint x = 5;\nint y =…\n[p10:c16] tf(\"I'll be rank 1\") && 0)\nBut when we see the short -circuiting, (printf (\"I'll\nbe rank 1\") && 0) will not execute.\nOutput: 1.\n•printf () is defined in the <stdio.h > header file.\n•It returns the number of characters it prints.\n•If an error occurs, it returns a negative number\n(usually -1).\n•Format specifiers like %s (for strings), %d (for\ninteger…\n[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p3:c2] When we try to store 129 in a char variable, it\ncauses an overflow because the value exceeds the\nmaximum limit of 127 (for signed char).\nSince it goes beyond the range, it wraps around using the cyclic property.\nLet’s understand it step- by-step:\n•If c = 128, it overflows by 1 step and wraps to -\n128 = - (129 -1)\n•If c = 129, it overflows by 2, so…", "draft_gold_answer": "=9; ex. int a= 9, 8,7; is interpreted as : int a = 9; 8; 7; // so the final value of a =5; Syntax: ++x, --x We do the increment or decrement first then will use the value in the expression. Ex. int x = 5; int y = ++x; // x becomes 6, then y = 6 Syntax: x++, x…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 5 key concepts covered.", "gold_answer": "prototype declares a function's name, return type, and parameters to the compiler before its definition, enabling type checking and early function calls. int add (int, int); // Function prototype Note: •If you do not specify a return type, the default return t…", "gold_evidence": "[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p11:c19] (can be empty)\n4.Function Body – The block of code that\nperforms the task\n5.Return Statement – (if not void) To send t he\nresul t back to the caller\nC-PROGRAMMING\nGATE फर्रे\nPage No:- 09\n[p14:c23] defined,\nyou can declare it using extern.\n1.You cannot  initialize an extern variabl e\nduring declaration.\nextern int x = 10; // Error extern int count;\nint main () {\nprintf (\"%d\",\ncount);\nreturn 0; } int count = 5; //\nDefined later\nC-PROGRAMMING\nGATE फर्रे\nPage No:- 11\n[p5:c8] =9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increment or decrement.\nint x = 5;\nint y =…", "draft_gold_evidence": "[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p11:c19] (can be empty)\n4.Function Body – The block of code that\nperforms the task\n5.Return Statement – (if not void) To send t he\nresul t back to the caller\nC-PROGRAMMING\nGATE फर्रे\nPage No:- 09\n[p14:c23] defined,\nyou can declare it using extern.\n1.You cannot  initialize an extern variabl e\nduring declaration.\nextern int x = 10; // Error extern int count;\nint main () {\nprintf (\"%d\",\ncount);\nreturn 0; } int count = 5; //\nDefined later\nC-PROGRAMMING\nGATE फर्रे\nPage No:- 11\n[p5:c8] =9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increment or decrement.\nint x = 5;\nint y =…", "draft_gold_answer": "prototype declares a function's name, return type, and parameters to the compiler before its definition, enabling type checking and early function calls. int add (int, int); // Function prototype Note: •If you do not specify a return type, the default return t…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Define two important terms exactly as stated in the notes.", "gold_answer": "=9; ex. int a= 9, 8,7; is interpreted as : int a = 9; 8; 7; // so the final value of a =5; Syntax: ++x, --x We do the increment or decrement first then will use the value in the expression. Ex. int x = 5; int y = ++x; // x becomes 6, then y = 6 Syntax: x++, x…", "gold_evidence": "[p5:c8] =9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increment or decrement.\nint x = 5;\nint y =…\n[p17:c31] har str [] = \"hello\";\nStored in stack or heap, which is read/write memory Duplicates are allowed — each array creates a separate\ncopy of the  string\nStrings in C can be represented in two ways:\n3.Using a character array\n4.Using a pointer to a string literalFeature  Array  Pointer\nDeclaration  char str []\n= \"hello\";  char *str\n=\n\"hello\";\nMemory\nLoca…\n[p5:c7] Right Shift Operator (>>)\nBitwise NOT Operator ( ~)\nLogical Not (!)  Comma Operator (,)\nIncrement (++) and Decrement ( -)\nPre-Increment / Pre -Increment\nSyntax: x >> n  = x / ( 2𝑛𝑛)\nExample: 8 >> 3\n•8 in binary: 0000 1000\n•8 >> 3 →  0000 0001 = 1\nAnother\nmethod:\n8 / 23 = 8 / 8\n= 1\nOperates bit -by-bit.\nConverts each 1 to 0 and\neach 0 to 1.\n~x = -(x…\n[p15:c26] other variable or item.\n•You can also have pointers to pointers, and even\nmore levels (multiple indirection).\n•We dereference a pointer using the * operator.\nint variable; // Normal integer variable\nint *ptr; // Declaration of a po inter to int\nptr = &variable; // Storing the address of variable in\npointer\n// Or in a single line:\nint *ptr = &variab…", "draft_gold_evidence": "[p5:c8] =9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increment or decrement.\nint x = 5;\nint y =…\n[p17:c31] har str [] = \"hello\";\nStored in stack or heap, which is read/write memory Duplicates are allowed — each array creates a separate\ncopy of the  string\nStrings in C can be represented in two ways:\n3.Using a character array\n4.Using a pointer to a string literalFeature  Array  Pointer\nDeclaration  char str []\n= \"hello\";  char *str\n=\n\"hello\";\nMemory\nLoca…\n[p5:c7] Right Shift Operator (>>)\nBitwise NOT Operator ( ~)\nLogical Not (!)  Comma Operator (,)\nIncrement (++) and Decrement ( -)\nPre-Increment / Pre -Increment\nSyntax: x >> n  = x / ( 2𝑛𝑛)\nExample: 8 >> 3\n•8 in binary: 0000 1000\n•8 >> 3 →  0000 0001 = 1\nAnother\nmethod:\n8 / 23 = 8 / 8\n= 1\nOperates bit -by-bit.\nConverts each 1 to 0 and\neach 0 to 1.\n~x = -(x…\n[p15:c26] other variable or item.\n•You can also have pointers to pointers, and even\nmore levels (multiple indirection).\n•We dereference a pointer using the * operator.\nint variable; // Normal integer variable\nint *ptr; // Declaration of a po inter to int\nptr = &variable; // Storing the address of variable in\npointer\n// Or in a single line:\nint *ptr = &variab…", "draft_gold_answer": "=9; ex. int a= 9, 8,7; is interpreted as : int a = 9; 8; 7; // so the final value of a =5; Syntax: ++x, --x We do the increment or decrement first then will use the value in the expression. Ex. int x = 5; int y = ++x; // x becomes 6, then y = 6 Syntax: x++, x…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Write one formula/equation mentioned in the notes (as written).", "gold_answer": "pe , lifetime, visibility , and memory location of variables. auto •Default for local variables. •Scope: Inside block/function. •Lifetime: Till the block ends. auto int a = 10; // usually just written as int a = 10; register 1.Stored in CPU registers (if avail…", "gold_evidence": "[p12:c21] pe , lifetime, visibility ,\nand memory location of variables.\nauto\n•Default for local variables.\n•Scope: Inside block/function.\n•Lifetime: Till the block ends.\nauto int a = 10; // usually just written as int a = 10;\nregister\n1.Stored in CPU registers (if available) for fast er\naccess.\n2.Cannot get the address using & register int\ncounter;register i…\n[p5:c8] =9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increment or decrement.\nint x = 5;\nint y =…\n[p17:c31] har str [] = \"hello\";\nStored in stack or heap, which is read/write memory Duplicates are allowed — each array creates a separate\ncopy of the  string\nStrings in C can be represented in two ways:\n3.Using a character array\n4.Using a pointer to a string literalFeature  Array  Pointer\nDeclaration  char str []\n= \"hello\";  char *str\n=\n\"hello\";\nMemory\nLoca…\n[p6:c10] lse.\nYou cannot  write else without if.\nelse {\n// statement;\n} // invalid, compiler give the error of wrong\nsyntax\nIf( )\nStatement;  // expression is mandatory in the if block\nIf(1)    –> this is perfect statements\nNote:  In C, if you do not use curly braces {} after an if\nstatement, only the very next single statement is\nconsidered part of the if…", "draft_gold_evidence": "[p12:c21] pe , lifetime, visibility ,\nand memory location of variables.\nauto\n•Default for local variables.\n•Scope: Inside block/function.\n•Lifetime: Till the block ends.\nauto int a = 10; // usually just written as int a = 10;\nregister\n1.Stored in CPU registers (if available) for fast er\naccess.\n2.Cannot get the address using & register int\ncounter;register i…\n[p5:c8] =9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increment or decrement.\nint x = 5;\nint y =…\n[p17:c31] har str [] = \"hello\";\nStored in stack or heap, which is read/write memory Duplicates are allowed — each array creates a separate\ncopy of the  string\nStrings in C can be represented in two ways:\n3.Using a character array\n4.Using a pointer to a string literalFeature  Array  Pointer\nDeclaration  char str []\n= \"hello\";  char *str\n=\n\"hello\";\nMemory\nLoca…\n[p6:c10] lse.\nYou cannot  write else without if.\nelse {\n// statement;\n} // invalid, compiler give the error of wrong\nsyntax\nIf( )\nStatement;  // expression is mandatory in the if block\nIf(1)    –> this is perfect statements\nNote:  In C, if you do not use curly braces {} after an if\nstatement, only the very next single statement is\nconsidered part of the if…", "draft_gold_answer": "pe , lifetime, visibility , and memory location of variables. auto •Default for local variables. •Scope: Inside block/function. •Lifetime: Till the block ends. auto int a = 10; // usually just written as int a = 10; register 1.Stored in CPU registers (if avail…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List the steps of one algorithm/procedure described in the notes.", "gold_answer": "=9; ex. int a= 9, 8,7; is interpreted as : int a = 9; 8; 7; // so the final value of a =5; Syntax: ++x, --x We do the increment or decrement first then will use the value in the expression. Ex. int x = 5; int y = ++x; // x becomes 6, then y = 6 Syntax: x++, x…", "gold_evidence": "[p5:c8] =9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increment or decrement.\nint x = 5;\nint y =…\n[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p11:c17] Scanf in C\nFunctions\nA function  is a block of code that performs a specific\ntask. It promotes code reusability  and modular\nprogramming . •scanf () is defined in the <stdio.h>  header file.\n•It is used to read input from the user.\n•scanf () returns the number of input it ems\nsuccessfully assigned.\n•If the input fails (like wrong format or EOF),\nit…\n[p18:c32] string.h Functions in C\nstrlen\nGet Length of String\nunsigned int strlen(const char *str);\nReturns the number of characters in the string\n(excluding the ' \\0' null terminator).\nThe parameter is const because strlen does not modify the string.\nstrcpy\nchar *strcpy (char *destination, const char *source);\nCopies the string from source to destination in…", "draft_gold_evidence": "[p5:c8] =9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increment or decrement.\nint x = 5;\nint y =…\n[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p11:c17] Scanf in C\nFunctions\nA function  is a block of code that performs a specific\ntask. It promotes code reusability  and modular\nprogramming . •scanf () is defined in the <stdio.h>  header file.\n•It is used to read input from the user.\n•scanf () returns the number of input it ems\nsuccessfully assigned.\n•If the input fails (like wrong format or EOF),\nit…\n[p18:c32] string.h Functions in C\nstrlen\nGet Length of String\nunsigned int strlen(const char *str);\nReturns the number of characters in the string\n(excluding the ' \\0' null terminator).\nThe parameter is const because strlen does not modify the string.\nstrcpy\nchar *strcpy (char *destination, const char *source);\nCopies the string from source to destination in…", "draft_gold_answer": "=9; ex. int a= 9, 8,7; is interpreted as : int a = 9; 8; 7; // so the final value of a =5; Syntax: ++x, --x We do the increment or decrement first then will use the value in the expression. Ex. int x = 5; int y = ++x; // x becomes 6, then y = 6 Syntax: x++, x…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Compare two related concepts/methods mentioned (give at least one difference).", "gold_answer": "string.h Functions in C strlen Get Length of String unsigned int strlen(const char *str); Returns the number of characters in the string (excluding the ' \\0' null terminator). The parameter is const because strlen does not modify the string. strcpy char *strcp…", "gold_evidence": "[p18:c32] string.h Functions in C\nstrlen\nGet Length of String\nunsigned int strlen(const char *str);\nReturns the number of characters in the string\n(excluding the ' \\0' null terminator).\nThe parameter is const because strlen does not modify the string.\nstrcpy\nchar *strcpy (char *destination, const char *source);\nCopies the string from source to destination in…\n[p9:c14] ue (no variables orranges allowed).\n•default is optional and executes when no cases match.\n•The position of the default case doesn’t matter.\n•continue cannot be used inside a switch statement.\n•If there is any stateme nt between two case labels, it is\nignored (not executed) unless one of the cases above\nfalls through.\n•switch is generally faster th…\n[p6:c9] Ternary Operator\nsizeof\nIf and else statements Syntax: ++x, --x\nWe do the increment or decrement first then\nwill use the value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nis a compile -time operator used to determine\nthe memory size (in bytes) of a data type or\nvariable.\nReturns size_t type (an unsigned integer).\nEvalu…\n[p16:c27] We cannot perform arbitrary pointer arithmetic\nbetween unrelated pointers, but pointer - pointer  is\nvalid when both pointers point to elements of the\nsame array.\nIn this case, the result is the difference in element positions , not in bytes, because the compiler\nautomatically divides the address difference by the size of the data type. int a[10];…", "draft_gold_evidence": "[p18:c32] string.h Functions in C\nstrlen\nGet Length of String\nunsigned int strlen(const char *str);\nReturns the number of characters in the string\n(excluding the ' \\0' null terminator).\nThe parameter is const because strlen does not modify the string.\nstrcpy\nchar *strcpy (char *destination, const char *source);\nCopies the string from source to destination in…\n[p9:c14] ue (no variables orranges allowed).\n•default is optional and executes when no cases match.\n•The position of the default case doesn’t matter.\n•continue cannot be used inside a switch statement.\n•If there is any stateme nt between two case labels, it is\nignored (not executed) unless one of the cases above\nfalls through.\n•switch is generally faster th…\n[p6:c9] Ternary Operator\nsizeof\nIf and else statements Syntax: ++x, --x\nWe do the increment or decrement first then\nwill use the value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nis a compile -time operator used to determine\nthe memory size (in bytes) of a data type or\nvariable.\nReturns size_t type (an unsigned integer).\nEvalu…\n[p16:c27] We cannot perform arbitrary pointer arithmetic\nbetween unrelated pointers, but pointer - pointer  is\nvalid when both pointers point to elements of the\nsame array.\nIn this case, the result is the difference in element positions , not in bytes, because the compiler\nautomatically divides the address difference by the size of the data type. int a[10];…", "draft_gold_answer": "string.h Functions in C strlen Get Length of String unsigned int strlen(const char *str); Returns the number of characters in the string (excluding the ' \\0' null terminator). The parameter is const because strlen does not modify the string. strcpy char *strcp…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List any assumptions, prerequisites, or constraints mentioned.", "gold_answer": "prototype declares a function's name, return type, and parameters to the compiler before its definition, enabling type checking and early function calls. int add (int, int); // Function prototype Note: •If you do not specify a return type, the default return t…", "gold_evidence": "[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p16:c27] We cannot perform arbitrary pointer arithmetic\nbetween unrelated pointers, but pointer - pointer  is\nvalid when both pointers point to elements of the\nsame array.\nIn this case, the result is the difference in element positions , not in bytes, because the compiler\nautomatically divides the address difference by the size of the data type. int a[10];…\n[p11:c17] Scanf in C\nFunctions\nA function  is a block of code that performs a specific\ntask. It promotes code reusability  and modular\nprogramming . •scanf () is defined in the <stdio.h>  header file.\n•It is used to read input from the user.\n•scanf () returns the number of input it ems\nsuccessfully assigned.\n•If the input fails (like wrong format or EOF),\nit…\n[p5:c8] =9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increment or decrement.\nint x = 5;\nint y =…", "draft_gold_evidence": "[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p16:c27] We cannot perform arbitrary pointer arithmetic\nbetween unrelated pointers, but pointer - pointer  is\nvalid when both pointers point to elements of the\nsame array.\nIn this case, the result is the difference in element positions , not in bytes, because the compiler\nautomatically divides the address difference by the size of the data type. int a[10];…\n[p11:c17] Scanf in C\nFunctions\nA function  is a block of code that performs a specific\ntask. It promotes code reusability  and modular\nprogramming . •scanf () is defined in the <stdio.h>  header file.\n•It is used to read input from the user.\n•scanf () returns the number of input it ems\nsuccessfully assigned.\n•If the input fails (like wrong format or EOF),\nit…\n[p5:c8] =9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increment or decrement.\nint x = 5;\nint y =…", "draft_gold_answer": "prototype declares a function's name, return type, and parameters to the compiler before its definition, enabling type checking and early function calls. int add (int, int); // Function prototype Note: •If you do not specify a return type, the default return t…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Give one example mentioned in the notes.", "gold_answer": "Flow chart of the C program Data Typ es Signed vs Unsigned •Signed (default): Can store both positive and negative numbers. −�𝟐𝟐𝒏𝒏−𝟏𝟏�𝒕𝒕𝒕𝒕 𝟐𝟐𝒏𝒏−𝟏𝟏− 𝟏𝟏 •Unsigned: Can store only positive numbers, but with double the max range. 𝟎𝟎 𝒕𝒕𝒕𝒕 𝟐𝟐𝒏𝒏− 𝟏𝟏Format Specifier \\…", "gold_evidence": "[p2:c0] Flow chart of the C program\nData Typ es\nSigned  vs Unsigned\n•Signed (default):  Can store both positive and\nnegative numbers. −�𝟐𝟐𝒏𝒏−𝟏𝟏�𝒕𝒕𝒕𝒕 𝟐𝟐𝒏𝒏−𝟏𝟏− 𝟏𝟏\n•Unsigned: Can store only positive numbers, but with\ndouble the max range.  𝟎𝟎  𝒕𝒕𝒕𝒕 𝟐𝟐𝒏𝒏− 𝟏𝟏Format  Specifier\n\\n: use to give the break in the line.\n\\t: move the cursor to the next available frame…\n[p6:c10] lse.\nYou cannot  write else without if.\nelse {\n// statement;\n} // invalid, compiler give the error of wrong\nsyntax\nIf( )\nStatement;  // expression is mandatory in the if block\nIf(1)    –> this is perfect statements\nNote:  In C, if you do not use curly braces {} after an if\nstatement, only the very next single statement is\nconsidered part of the if…\n[p3:c4] k runs\nModulus (%)\nboth operands must be int value types\na%b = remainder of a when divided by b.\nSign of the Result Follows Dividend (Left Operand)\n5 % 3 = 2\n-5 % 3 = -2\n5 % - 3 = 2\n-5 % - 3 = -2\n-\n0\n1\n2\n3\n-\n1\nThis is 129, it is positive overflow. So, we need to\nmove in the clockwise direction by 2 unit which is -\n127.\nChar c\n(8bit)−𝟐𝟐𝟖𝟖−𝟏𝟏 𝒕𝒕𝒕𝒕  𝟐…\n[p17:c31] har str [] = \"hello\";\nStored in stack or heap, which is read/write memory Duplicates are allowed — each array creates a separate\ncopy of the  string\nStrings in C can be represented in two ways:\n3.Using a character array\n4.Using a pointer to a string literalFeature  Array  Pointer\nDeclaration  char str []\n= \"hello\";  char *str\n=\n\"hello\";\nMemory\nLoca…", "draft_gold_evidence": "[p2:c0] Flow chart of the C program\nData Typ es\nSigned  vs Unsigned\n•Signed (default):  Can store both positive and\nnegative numbers. −�𝟐𝟐𝒏𝒏−𝟏𝟏�𝒕𝒕𝒕𝒕 𝟐𝟐𝒏𝒏−𝟏𝟏− 𝟏𝟏\n•Unsigned: Can store only positive numbers, but with\ndouble the max range.  𝟎𝟎  𝒕𝒕𝒕𝒕 𝟐𝟐𝒏𝒏− 𝟏𝟏Format  Specifier\n\\n: use to give the break in the line.\n\\t: move the cursor to the next available frame…\n[p6:c10] lse.\nYou cannot  write else without if.\nelse {\n// statement;\n} // invalid, compiler give the error of wrong\nsyntax\nIf( )\nStatement;  // expression is mandatory in the if block\nIf(1)    –> this is perfect statements\nNote:  In C, if you do not use curly braces {} after an if\nstatement, only the very next single statement is\nconsidered part of the if…\n[p3:c4] k runs\nModulus (%)\nboth operands must be int value types\na%b = remainder of a when divided by b.\nSign of the Result Follows Dividend (Left Operand)\n5 % 3 = 2\n-5 % 3 = -2\n5 % - 3 = 2\n-5 % - 3 = -2\n-\n0\n1\n2\n3\n-\n1\nThis is 129, it is positive overflow. So, we need to\nmove in the clockwise direction by 2 unit which is -\n127.\nChar c\n(8bit)−𝟐𝟐𝟖𝟖−𝟏𝟏 𝒕𝒕𝒕𝒕  𝟐…\n[p17:c31] har str [] = \"hello\";\nStored in stack or heap, which is read/write memory Duplicates are allowed — each array creates a separate\ncopy of the  string\nStrings in C can be represented in two ways:\n3.Using a character array\n4.Using a pointer to a string literalFeature  Array  Pointer\nDeclaration  char str []\n= \"hello\";  char *str\n=\n\"hello\";\nMemory\nLoca…", "draft_gold_answer": "Flow chart of the C program Data Typ es Signed vs Unsigned •Signed (default): Can store both positive and negative numbers. −�𝟐𝟐𝒏𝒏−𝟏𝟏�𝒕𝒕𝒕𝒕 𝟐𝟐𝒏𝒏−𝟏𝟏− 𝟏𝟏 •Unsigned: Can store only positive numbers, but with double the max range. 𝟎𝟎 𝒕𝒕𝒕𝒕 𝟐𝟐𝒏𝒏− 𝟏𝟏Format Specifier \\…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What are the advantages and limitations of the main method/topic (as stated)?", "gold_answer": "=9; ex. int a= 9, 8,7; is interpreted as : int a = 9; 8; 7; // so the final value of a =5; Syntax: ++x, --x We do the increment or decrement first then will use the value in the expression. Ex. int x = 5; int y = ++x; // x becomes 6, then y = 6 Syntax: x++, x…", "gold_evidence": "[p5:c8] =9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increment or decrement.\nint x = 5;\nint y =…\n[p17:c31] har str [] = \"hello\";\nStored in stack or heap, which is read/write memory Duplicates are allowed — each array creates a separate\ncopy of the  string\nStrings in C can be represented in two ways:\n3.Using a character array\n4.Using a pointer to a string literalFeature  Array  Pointer\nDeclaration  char str []\n= \"hello\";  char *str\n=\n\"hello\";\nMemory\nLoca…\n[p12:c20] Function calling:   function_name (arguments);\nCall by Value\nFormal arguments are the parameters listed in the\nfunction definition . When a function is called, copies\nof actual values are passed to them.\nChanges made to formal arguments do not affect\nactual arguments.\nThis is the default behaviour in C.\nSeparate memory is allocated for the formal p…\n[p5:c7] Right Shift Operator (>>)\nBitwise NOT Operator ( ~)\nLogical Not (!)  Comma Operator (,)\nIncrement (++) and Decrement ( -)\nPre-Increment / Pre -Increment\nSyntax: x >> n  = x / ( 2𝑛𝑛)\nExample: 8 >> 3\n•8 in binary: 0000 1000\n•8 >> 3 →  0000 0001 = 1\nAnother\nmethod:\n8 / 23 = 8 / 8\n= 1\nOperates bit -by-bit.\nConverts each 1 to 0 and\neach 0 to 1.\n~x = -(x…", "draft_gold_evidence": "[p5:c8] =9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increment or decrement.\nint x = 5;\nint y =…\n[p17:c31] har str [] = \"hello\";\nStored in stack or heap, which is read/write memory Duplicates are allowed — each array creates a separate\ncopy of the  string\nStrings in C can be represented in two ways:\n3.Using a character array\n4.Using a pointer to a string literalFeature  Array  Pointer\nDeclaration  char str []\n= \"hello\";  char *str\n=\n\"hello\";\nMemory\nLoca…\n[p12:c20] Function calling:   function_name (arguments);\nCall by Value\nFormal arguments are the parameters listed in the\nfunction definition . When a function is called, copies\nof actual values are passed to them.\nChanges made to formal arguments do not affect\nactual arguments.\nThis is the default behaviour in C.\nSeparate memory is allocated for the formal p…\n[p5:c7] Right Shift Operator (>>)\nBitwise NOT Operator ( ~)\nLogical Not (!)  Comma Operator (,)\nIncrement (++) and Decrement ( -)\nPre-Increment / Pre -Increment\nSyntax: x >> n  = x / ( 2𝑛𝑛)\nExample: 8 >> 3\n•8 in binary: 0000 1000\n•8 >> 3 →  0000 0001 = 1\nAnother\nmethod:\n8 / 23 = 8 / 8\n= 1\nOperates bit -by-bit.\nConverts each 1 to 0 and\neach 0 to 1.\n~x = -(x…", "draft_gold_answer": "=9; ex. int a= 9, 8,7; is interpreted as : int a = 9; 8; 7; // so the final value of a =5; Syntax: ++x, --x We do the increment or decrement first then will use the value in the expression. Ex. int x = 5; int y = ++x; // x becomes 6, then y = 6 Syntax: x++, x…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Summarize the key takeaways in 3 bullet points.", "gold_answer": "Summa ry of Key Points •Arrays allow changing individual characters , e.g., str [0] = 'H'; •Pointers may point to string literals, which are often read-only •You cannot assign a new string to an array like: str = \"new\"; → invalid •But with pointers: str = \"new…", "gold_evidence": "[p17:c30] Summa ry of Key Points\n•Arrays allow changing individual characters ,\ne.g., str [0] = 'H';\n•Pointers may point to string literals, which are\noften read-only\n•You cannot assign a new string to an array\nlike: str = \"new\"; →  invalid\n•But with pointers: str = \"new\"; → valid\nMemory Behaviour for Strings in C\nRead-Only Memory (String Literals)\n•Strings…\n[p3:c4] k runs\nModulus (%)\nboth operands must be int value types\na%b = remainder of a when divided by b.\nSign of the Result Follows Dividend (Left Operand)\n5 % 3 = 2\n-5 % 3 = -2\n5 % - 3 = 2\n-5 % - 3 = -2\n-\n0\n1\n2\n3\n-\n1\nThis is 129, it is positive overflow. So, we need to\nmove in the clockwise direction by 2 unit which is -\n127.\nChar c\n(8bit)−𝟐𝟐𝟖𝟖−𝟏𝟏 𝒕𝒕𝒕𝒕  𝟐…\n[p17:c31] har str [] = \"hello\";\nStored in stack or heap, which is read/write memory Duplicates are allowed — each array creates a separate\ncopy of the  string\nStrings in C can be represented in two ways:\n3.Using a character array\n4.Using a pointer to a string literalFeature  Array  Pointer\nDeclaration  char str []\n= \"hello\";  char *str\n=\n\"hello\";\nMemory\nLoca…\n[p8:c11] Loops\nFor loops\nWhile\nPattern  Valid?  Explanation\nif (exp)\n{statement;}  yes Only if block, no else needed,\nbut expression is mandatory in if\nblock\nIf () statement;  no Expression is missing\nelse\n{statement;}  no Must follow an if block\nif (exp)\n{statement;} statement; else {statement;}  no Statement between if and else\nbreaks the pair\nif (exp)\n{s…", "draft_gold_evidence": "[p17:c30] Summa ry of Key Points\n•Arrays allow changing individual characters ,\ne.g., str [0] = 'H';\n•Pointers may point to string literals, which are\noften read-only\n•You cannot assign a new string to an array\nlike: str = \"new\"; →  invalid\n•But with pointers: str = \"new\"; → valid\nMemory Behaviour for Strings in C\nRead-Only Memory (String Literals)\n•Strings…\n[p3:c4] k runs\nModulus (%)\nboth operands must be int value types\na%b = remainder of a when divided by b.\nSign of the Result Follows Dividend (Left Operand)\n5 % 3 = 2\n-5 % 3 = -2\n5 % - 3 = 2\n-5 % - 3 = -2\n-\n0\n1\n2\n3\n-\n1\nThis is 129, it is positive overflow. So, we need to\nmove in the clockwise direction by 2 unit which is -\n127.\nChar c\n(8bit)−𝟐𝟐𝟖𝟖−𝟏𝟏 𝒕𝒕𝒕𝒕  𝟐…\n[p17:c31] har str [] = \"hello\";\nStored in stack or heap, which is read/write memory Duplicates are allowed — each array creates a separate\ncopy of the  string\nStrings in C can be represented in two ways:\n3.Using a character array\n4.Using a pointer to a string literalFeature  Array  Pointer\nDeclaration  char str []\n= \"hello\";  char *str\n=\n\"hello\";\nMemory\nLoca…\n[p8:c11] Loops\nFor loops\nWhile\nPattern  Valid?  Explanation\nif (exp)\n{statement;}  yes Only if block, no else needed,\nbut expression is mandatory in if\nblock\nIf () statement;  no Expression is missing\nelse\n{statement;}  no Must follow an if block\nif (exp)\n{statement;} statement; else {statement;}  no Statement between if and else\nbreaks the pair\nif (exp)\n{s…", "draft_gold_answer": "Summa ry of Key Points •Arrays allow changing individual characters , e.g., str [0] = 'H'; •Pointers may point to string literals, which are often read-only •You cannot assign a new string to an array like: str = \"new\"; → invalid •But with pointers: str = \"new…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Is there any deadline/submission instruction in the document? If not, answer 'Not found in the document.'", "gold_answer": "lse. You cannot write else without if. else { // statement; } // invalid, compiler give the error of wrong syntax If( ) Statement; // expression is mandatory in the if block If(1) –> this is perfect statements Note: In C, if you do not use curly braces {} afte…", "gold_evidence": "[p6:c10] lse.\nYou cannot  write else without if.\nelse {\n// statement;\n} // invalid, compiler give the error of wrong\nsyntax\nIf( )\nStatement;  // expression is mandatory in the if block\nIf(1)    –> this is perfect statements\nNote:  In C, if you do not use curly braces {} after an if\nstatement, only the very next single statement is\nconsidered part of the if…\n[p9:c14] ue (no variables orranges allowed).\n•default is optional and executes when no cases match.\n•The position of the default case doesn’t matter.\n•continue cannot be used inside a switch statement.\n•If there is any stateme nt between two case labels, it is\nignored (not executed) unless one of the cases above\nfalls through.\n•switch is generally faster th…\n[p8:c11] Loops\nFor loops\nWhile\nPattern  Valid?  Explanation\nif (exp)\n{statement;}  yes Only if block, no else needed,\nbut expression is mandatory in if\nblock\nIf () statement;  no Expression is missing\nelse\n{statement;}  no Must follow an if block\nif (exp)\n{statement;} statement; else {statement;}  no Statement between if and else\nbreaks the pair\nif (exp)\n{s…\n[p6:c9] Ternary Operator\nsizeof\nIf and else statements Syntax: ++x, --x\nWe do the increment or decrement first then\nwill use the value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nis a compile -time operator used to determine\nthe memory size (in bytes) of a data type or\nvariable.\nReturns size_t type (an unsigned integer).\nEvalu…", "draft_gold_evidence": "[p6:c10] lse.\nYou cannot  write else without if.\nelse {\n// statement;\n} // invalid, compiler give the error of wrong\nsyntax\nIf( )\nStatement;  // expression is mandatory in the if block\nIf(1)    –> this is perfect statements\nNote:  In C, if you do not use curly braces {} after an if\nstatement, only the very next single statement is\nconsidered part of the if…\n[p9:c14] ue (no variables orranges allowed).\n•default is optional and executes when no cases match.\n•The position of the default case doesn’t matter.\n•continue cannot be used inside a switch statement.\n•If there is any stateme nt between two case labels, it is\nignored (not executed) unless one of the cases above\nfalls through.\n•switch is generally faster th…\n[p8:c11] Loops\nFor loops\nWhile\nPattern  Valid?  Explanation\nif (exp)\n{statement;}  yes Only if block, no else needed,\nbut expression is mandatory in if\nblock\nIf () statement;  no Expression is missing\nelse\n{statement;}  no Must follow an if block\nif (exp)\n{statement;} statement; else {statement;}  no Statement between if and else\nbreaks the pair\nif (exp)\n{s…\n[p6:c9] Ternary Operator\nsizeof\nIf and else statements Syntax: ++x, --x\nWe do the increment or decrement first then\nwill use the value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nis a compile -time operator used to determine\nthe memory size (in bytes) of a data type or\nvariable.\nReturns size_t type (an unsigned integer).\nEvalu…", "draft_gold_answer": "lse. You cannot write else without if. else { // statement; } // invalid, compiler give the error of wrong syntax If( ) Statement; // expression is mandatory in the if block If(1) –> this is perfect statements Note: In C, if you do not use curly braces {} afte…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one definition stated in the notes? Quote it exactly if present; otherwise answer 'Not found in the document.'", "gold_answer": "prototype declares a function's name, return type, and parameters to the compiler before its definition, enabling type checking and early function calls. int add (int, int); // Function prototype Note: •If you do not specify a return type, the default return t…", "gold_evidence": "[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p10:c16] tf(\"I'll be rank 1\") && 0)\nBut when we see the short -circuiting, (printf (\"I'll\nbe rank 1\") && 0) will not execute.\nOutput: 1.\n•printf () is defined in the <stdio.h > header file.\n•It returns the number of characters it prints.\n•If an error occurs, it returns a negative number\n(usually -1).\n•Format specifiers like %s (for strings), %d (for\ninteger…\n[p8:c12] s all the blocks condition are true. But we\ncheck first condition which is if(x > 10) and it comes\ntrue then we will not execute to the next level, even\nif the next blocks like else if(x>5), else(x>0) are true.\nValid syntax:\nfor (exp1; exp2; exp3) {\nStatements;\n}\nFlow:  exp1 →  exp2? → statements → exp3\nExpression inside the for loop are optional.…\n[p11:c17] Scanf in C\nFunctions\nA function  is a block of code that performs a specific\ntask. It promotes code reusability  and modular\nprogramming . •scanf () is defined in the <stdio.h>  header file.\n•It is used to read input from the user.\n•scanf () returns the number of input it ems\nsuccessfully assigned.\n•If the input fails (like wrong format or EOF),\nit…", "draft_gold_evidence": "[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p10:c16] tf(\"I'll be rank 1\") && 0)\nBut when we see the short -circuiting, (printf (\"I'll\nbe rank 1\") && 0) will not execute.\nOutput: 1.\n•printf () is defined in the <stdio.h > header file.\n•It returns the number of characters it prints.\n•If an error occurs, it returns a negative number\n(usually -1).\n•Format specifiers like %s (for strings), %d (for\ninteger…\n[p8:c12] s all the blocks condition are true. But we\ncheck first condition which is if(x > 10) and it comes\ntrue then we will not execute to the next level, even\nif the next blocks like else if(x>5), else(x>0) are true.\nValid syntax:\nfor (exp1; exp2; exp3) {\nStatements;\n}\nFlow:  exp1 →  exp2? → statements → exp3\nExpression inside the for loop are optional.…\n[p11:c17] Scanf in C\nFunctions\nA function  is a block of code that performs a specific\ntask. It promotes code reusability  and modular\nprogramming . •scanf () is defined in the <stdio.h>  header file.\n•It is used to read input from the user.\n•scanf () returns the number of input it ems\nsuccessfully assigned.\n•If the input fails (like wrong format or EOF),\nit…", "draft_gold_answer": "prototype declares a function's name, return type, and parameters to the compiler before its definition, enabling type checking and early function calls. int add (int, int); // Function prototype Note: •If you do not specify a return type, the default return t…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the time complexity of one algorithm mentioned (as stated)? If not present, answer 'Not found in the document.'", "gold_answer": "prototype declares a function's name, return type, and parameters to the compiler before its definition, enabling type checking and early function calls. int add (int, int); // Function prototype Note: •If you do not specify a return type, the default return t…", "gold_evidence": "[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p5:c8] =9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increment or decrement.\nint x = 5;\nint y =…\n[p15:c24] Array\nPointers\n•Array name represents the address of its first\nelement.\nint arr [5];\nprintf (\"%p\", arr); // Prints address of arr [0]);\narr means &arr[0]\n•Array name is constant, so it can’t be the left\nvalue.\narr = value; → Invalid\n•Array size must be a constant or fixed expressio n\n(at compile time).\nint arr[10]; valid\nint size; int arr[size]; in…\n[p10:c16] tf(\"I'll be rank 1\") && 0)\nBut when we see the short -circuiting, (printf (\"I'll\nbe rank 1\") && 0) will not execute.\nOutput: 1.\n•printf () is defined in the <stdio.h > header file.\n•It returns the number of characters it prints.\n•If an error occurs, it returns a negative number\n(usually -1).\n•Format specifiers like %s (for strings), %d (for\ninteger…", "draft_gold_evidence": "[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p5:c8] =9; ex.  int a= 9, 8,7;\nis interpreted as :\nint a = 9;\n8;\n7;\n// so the final value of a =5;\nSyntax: ++x, --x\nWe do the increment or decrement first then will use\nthe value in the expression.\nEx. int x = 5;\nint y = ++x; // x becomes 6, then y = 6\nSyntax: x++, x --, First use  the value and then perform\nthe increment or decrement.\nint x = 5;\nint y =…\n[p15:c24] Array\nPointers\n•Array name represents the address of its first\nelement.\nint arr [5];\nprintf (\"%p\", arr); // Prints address of arr [0]);\narr means &arr[0]\n•Array name is constant, so it can’t be the left\nvalue.\narr = value; → Invalid\n•Array size must be a constant or fixed expressio n\n(at compile time).\nint arr[10]; valid\nint size; int arr[size]; in…\n[p10:c16] tf(\"I'll be rank 1\") && 0)\nBut when we see the short -circuiting, (printf (\"I'll\nbe rank 1\") && 0) will not execute.\nOutput: 1.\n•printf () is defined in the <stdio.h > header file.\n•It returns the number of characters it prints.\n•If an error occurs, it returns a negative number\n(usually -1).\n•Format specifiers like %s (for strings), %d (for\ninteger…", "draft_gold_answer": "prototype declares a function's name, return type, and parameters to the compiler before its definition, enabling type checking and early function calls. int add (int, int); // Function prototype Note: •If you do not specify a return type, the default return t…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 3 important keywords/terms that appear in the notes.", "gold_answer": "prototype declares a function's name, return type, and parameters to the compiler before its definition, enabling type checking and early function calls. int add (int, int); // Function prototype Note: •If you do not specify a return type, the default return t…", "gold_evidence": "[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p11:c17] Scanf in C\nFunctions\nA function  is a block of code that performs a specific\ntask. It promotes code reusability  and modular\nprogramming . •scanf () is defined in the <stdio.h>  header file.\n•It is used to read input from the user.\n•scanf () returns the number of input it ems\nsuccessfully assigned.\n•If the input fails (like wrong format or EOF),\nit…\n[p15:c25] itialize the array during declaration, the first\ndimension’s size can be omitted — the compiler\nwill count it automatically.\nint arr [] = {1, 2, 3}; // Size = 3 (automatically)\nint arr [3] = {1, 2, 3}; // Also OK\n•Multidimensional Arrays → Only First Dimensio n\nCan Be Omitted\nIn multi -dimensional arrays:\n•You can omit the first dimension if initia…\n[p3:c4] k runs\nModulus (%)\nboth operands must be int value types\na%b = remainder of a when divided by b.\nSign of the Result Follows Dividend (Left Operand)\n5 % 3 = 2\n-5 % 3 = -2\n5 % - 3 = 2\n-5 % - 3 = -2\n-\n0\n1\n2\n3\n-\n1\nThis is 129, it is positive overflow. So, we need to\nmove in the clockwise direction by 2 unit which is -\n127.\nChar c\n(8bit)−𝟐𝟐𝟖𝟖−𝟏𝟏 𝒕𝒕𝒕𝒕  𝟐…", "draft_gold_evidence": "[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p11:c17] Scanf in C\nFunctions\nA function  is a block of code that performs a specific\ntask. It promotes code reusability  and modular\nprogramming . •scanf () is defined in the <stdio.h>  header file.\n•It is used to read input from the user.\n•scanf () returns the number of input it ems\nsuccessfully assigned.\n•If the input fails (like wrong format or EOF),\nit…\n[p15:c25] itialize the array during declaration, the first\ndimension’s size can be omitted — the compiler\nwill count it automatically.\nint arr [] = {1, 2, 3}; // Size = 3 (automatically)\nint arr [3] = {1, 2, 3}; // Also OK\n•Multidimensional Arrays → Only First Dimensio n\nCan Be Omitted\nIn multi -dimensional arrays:\n•You can omit the first dimension if initia…\n[p3:c4] k runs\nModulus (%)\nboth operands must be int value types\na%b = remainder of a when divided by b.\nSign of the Result Follows Dividend (Left Operand)\n5 % 3 = 2\n-5 % 3 = -2\n5 % - 3 = 2\n-5 % - 3 = -2\n-\n0\n1\n2\n3\n-\n1\nThis is 129, it is positive overflow. So, we need to\nmove in the clockwise direction by 2 unit which is -\n127.\nChar c\n(8bit)−𝟐𝟐𝟖𝟖−𝟏𝟏 𝒕𝒕𝒕𝒕  𝟐…", "draft_gold_answer": "prototype declares a function's name, return type, and parameters to the compiler before its definition, enabling type checking and early function calls. int add (int, int); // Function prototype Note: •If you do not specify a return type, the default return t…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one theorem/lemma/property stated? If not present, answer 'Not found in the document.'", "gold_answer": "tf(\"I'll be rank 1\") && 0) But when we see the short -circuiting, (printf (\"I'll be rank 1\") && 0) will not execute. Output: 1. •printf () is defined in the <stdio.h > header file. •It returns the number of characters it prints. •If an error occurs, it returns…", "gold_evidence": "[p10:c16] tf(\"I'll be rank 1\") && 0)\nBut when we see the short -circuiting, (printf (\"I'll\nbe rank 1\") && 0) will not execute.\nOutput: 1.\n•printf () is defined in the <stdio.h > header file.\n•It returns the number of characters it prints.\n•If an error occurs, it returns a negative number\n(usually -1).\n•Format specifiers like %s (for strings), %d (for\ninteger…\n[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p6:c10] lse.\nYou cannot  write else without if.\nelse {\n// statement;\n} // invalid, compiler give the error of wrong\nsyntax\nIf( )\nStatement;  // expression is mandatory in the if block\nIf(1)    –> this is perfect statements\nNote:  In C, if you do not use curly braces {} after an if\nstatement, only the very next single statement is\nconsidered part of the if…\n[p8:c12] s all the blocks condition are true. But we\ncheck first condition which is if(x > 10) and it comes\ntrue then we will not execute to the next level, even\nif the next blocks like else if(x>5), else(x>0) are true.\nValid syntax:\nfor (exp1; exp2; exp3) {\nStatements;\n}\nFlow:  exp1 →  exp2? → statements → exp3\nExpression inside the for loop are optional.…", "draft_gold_evidence": "[p10:c16] tf(\"I'll be rank 1\") && 0)\nBut when we see the short -circuiting, (printf (\"I'll\nbe rank 1\") && 0) will not execute.\nOutput: 1.\n•printf () is defined in the <stdio.h > header file.\n•It returns the number of characters it prints.\n•If an error occurs, it returns a negative number\n(usually -1).\n•Format specifiers like %s (for strings), %d (for\ninteger…\n[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p6:c10] lse.\nYou cannot  write else without if.\nelse {\n// statement;\n} // invalid, compiler give the error of wrong\nsyntax\nIf( )\nStatement;  // expression is mandatory in the if block\nIf(1)    –> this is perfect statements\nNote:  In C, if you do not use curly braces {} after an if\nstatement, only the very next single statement is\nconsidered part of the if…\n[p8:c12] s all the blocks condition are true. But we\ncheck first condition which is if(x > 10) and it comes\ntrue then we will not execute to the next level, even\nif the next blocks like else if(x>5), else(x>0) are true.\nValid syntax:\nfor (exp1; exp2; exp3) {\nStatements;\n}\nFlow:  exp1 →  exp2? → statements → exp3\nExpression inside the for loop are optional.…", "draft_gold_answer": "tf(\"I'll be rank 1\") && 0) But when we see the short -circuiting, (printf (\"I'll be rank 1\") && 0) will not execute. Output: 1. •printf () is defined in the <stdio.h > header file. •It returns the number of characters it prints. •If an error occurs, it returns…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Describe one table/list mentioned (what items are compared or listed). If none, answer 'Not found in the document.'", "gold_answer": "tf(\"I'll be rank 1\") && 0) But when we see the short -circuiting, (printf (\"I'll be rank 1\") && 0) will not execute. Output: 1. •printf () is defined in the <stdio.h > header file. •It returns the number of characters it prints. •If an error occurs, it returns…", "gold_evidence": "[p10:c16] tf(\"I'll be rank 1\") && 0)\nBut when we see the short -circuiting, (printf (\"I'll\nbe rank 1\") && 0) will not execute.\nOutput: 1.\n•printf () is defined in the <stdio.h > header file.\n•It returns the number of characters it prints.\n•If an error occurs, it returns a negative number\n(usually -1).\n•Format specifiers like %s (for strings), %d (for\ninteger…\n[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p18:c32] string.h Functions in C\nstrlen\nGet Length of String\nunsigned int strlen(const char *str);\nReturns the number of characters in the string\n(excluding the ' \\0' null terminator).\nThe parameter is const because strlen does not modify the string.\nstrcpy\nchar *strcpy (char *destination, const char *source);\nCopies the string from source to destination in…\n[p17:c30] Summa ry of Key Points\n•Arrays allow changing individual characters ,\ne.g., str [0] = 'H';\n•Pointers may point to string literals, which are\noften read-only\n•You cannot assign a new string to an array\nlike: str = \"new\"; →  invalid\n•But with pointers: str = \"new\"; → valid\nMemory Behaviour for Strings in C\nRead-Only Memory (String Literals)\n•Strings…", "draft_gold_evidence": "[p10:c16] tf(\"I'll be rank 1\") && 0)\nBut when we see the short -circuiting, (printf (\"I'll\nbe rank 1\") && 0) will not execute.\nOutput: 1.\n•printf () is defined in the <stdio.h > header file.\n•It returns the number of characters it prints.\n•If an error occurs, it returns a negative number\n(usually -1).\n•Format specifiers like %s (for strings), %d (for\ninteger…\n[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p18:c32] string.h Functions in C\nstrlen\nGet Length of String\nunsigned int strlen(const char *str);\nReturns the number of characters in the string\n(excluding the ' \\0' null terminator).\nThe parameter is const because strlen does not modify the string.\nstrcpy\nchar *strcpy (char *destination, const char *source);\nCopies the string from source to destination in…\n[p17:c30] Summa ry of Key Points\n•Arrays allow changing individual characters ,\ne.g., str [0] = 'H';\n•Pointers may point to string literals, which are\noften read-only\n•You cannot assign a new string to an array\nlike: str = \"new\"; →  invalid\n•But with pointers: str = \"new\"; → valid\nMemory Behaviour for Strings in C\nRead-Only Memory (String Literals)\n•Strings…", "draft_gold_answer": "tf(\"I'll be rank 1\") && 0) But when we see the short -circuiting, (printf (\"I'll be rank 1\") && 0) will not execute. Output: 1. •printf () is defined in the <stdio.h > header file. •It returns the number of characters it prints. •If an error occurs, it returns…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one stated limitation/constraint? If none, answer 'Not found in the document.'", "gold_answer": "tf(\"I'll be rank 1\") && 0) But when we see the short -circuiting, (printf (\"I'll be rank 1\") && 0) will not execute. Output: 1. •printf () is defined in the <stdio.h > header file. •It returns the number of characters it prints. •If an error occurs, it returns…", "gold_evidence": "[p10:c16] tf(\"I'll be rank 1\") && 0)\nBut when we see the short -circuiting, (printf (\"I'll\nbe rank 1\") && 0) will not execute.\nOutput: 1.\n•printf () is defined in the <stdio.h > header file.\n•It returns the number of characters it prints.\n•If an error occurs, it returns a negative number\n(usually -1).\n•Format specifiers like %s (for strings), %d (for\ninteger…\n[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p6:c10] lse.\nYou cannot  write else without if.\nelse {\n// statement;\n} // invalid, compiler give the error of wrong\nsyntax\nIf( )\nStatement;  // expression is mandatory in the if block\nIf(1)    –> this is perfect statements\nNote:  In C, if you do not use curly braces {} after an if\nstatement, only the very next single statement is\nconsidered part of the if…\n[p8:c12] s all the blocks condition are true. But we\ncheck first condition which is if(x > 10) and it comes\ntrue then we will not execute to the next level, even\nif the next blocks like else if(x>5), else(x>0) are true.\nValid syntax:\nfor (exp1; exp2; exp3) {\nStatements;\n}\nFlow:  exp1 →  exp2? → statements → exp3\nExpression inside the for loop are optional.…", "draft_gold_evidence": "[p10:c16] tf(\"I'll be rank 1\") && 0)\nBut when we see the short -circuiting, (printf (\"I'll\nbe rank 1\") && 0) will not execute.\nOutput: 1.\n•printf () is defined in the <stdio.h > header file.\n•It returns the number of characters it prints.\n•If an error occurs, it returns a negative number\n(usually -1).\n•Format specifiers like %s (for strings), %d (for\ninteger…\n[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p6:c10] lse.\nYou cannot  write else without if.\nelse {\n// statement;\n} // invalid, compiler give the error of wrong\nsyntax\nIf( )\nStatement;  // expression is mandatory in the if block\nIf(1)    –> this is perfect statements\nNote:  In C, if you do not use curly braces {} after an if\nstatement, only the very next single statement is\nconsidered part of the if…\n[p8:c12] s all the blocks condition are true. But we\ncheck first condition which is if(x > 10) and it comes\ntrue then we will not execute to the next level, even\nif the next blocks like else if(x>5), else(x>0) are true.\nValid syntax:\nfor (exp1; exp2; exp3) {\nStatements;\n}\nFlow:  exp1 →  exp2? → statements → exp3\nExpression inside the for loop are optional.…", "draft_gold_answer": "tf(\"I'll be rank 1\") && 0) But when we see the short -circuiting, (printf (\"I'll be rank 1\") && 0) will not execute. Output: 1. •printf () is defined in the <stdio.h > header file. •It returns the number of characters it prints. •If an error occurs, it returns…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one stated advantage/benefit? If none, answer 'Not found in the document.'", "gold_answer": "tf(\"I'll be rank 1\") && 0) But when we see the short -circuiting, (printf (\"I'll be rank 1\") && 0) will not execute. Output: 1. •printf () is defined in the <stdio.h > header file. •It returns the number of characters it prints. •If an error occurs, it returns…", "gold_evidence": "[p10:c16] tf(\"I'll be rank 1\") && 0)\nBut when we see the short -circuiting, (printf (\"I'll\nbe rank 1\") && 0) will not execute.\nOutput: 1.\n•printf () is defined in the <stdio.h > header file.\n•It returns the number of characters it prints.\n•If an error occurs, it returns a negative number\n(usually -1).\n•Format specifiers like %s (for strings), %d (for\ninteger…\n[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p6:c10] lse.\nYou cannot  write else without if.\nelse {\n// statement;\n} // invalid, compiler give the error of wrong\nsyntax\nIf( )\nStatement;  // expression is mandatory in the if block\nIf(1)    –> this is perfect statements\nNote:  In C, if you do not use curly braces {} after an if\nstatement, only the very next single statement is\nconsidered part of the if…\n[p8:c12] s all the blocks condition are true. But we\ncheck first condition which is if(x > 10) and it comes\ntrue then we will not execute to the next level, even\nif the next blocks like else if(x>5), else(x>0) are true.\nValid syntax:\nfor (exp1; exp2; exp3) {\nStatements;\n}\nFlow:  exp1 →  exp2? → statements → exp3\nExpression inside the for loop are optional.…", "draft_gold_evidence": "[p10:c16] tf(\"I'll be rank 1\") && 0)\nBut when we see the short -circuiting, (printf (\"I'll\nbe rank 1\") && 0) will not execute.\nOutput: 1.\n•printf () is defined in the <stdio.h > header file.\n•It returns the number of characters it prints.\n•If an error occurs, it returns a negative number\n(usually -1).\n•Format specifiers like %s (for strings), %d (for\ninteger…\n[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p6:c10] lse.\nYou cannot  write else without if.\nelse {\n// statement;\n} // invalid, compiler give the error of wrong\nsyntax\nIf( )\nStatement;  // expression is mandatory in the if block\nIf(1)    –> this is perfect statements\nNote:  In C, if you do not use curly braces {} after an if\nstatement, only the very next single statement is\nconsidered part of the if…\n[p8:c12] s all the blocks condition are true. But we\ncheck first condition which is if(x > 10) and it comes\ntrue then we will not execute to the next level, even\nif the next blocks like else if(x>5), else(x>0) are true.\nValid syntax:\nfor (exp1; exp2; exp3) {\nStatements;\n}\nFlow:  exp1 →  exp2? → statements → exp3\nExpression inside the for loop are optional.…", "draft_gold_answer": "tf(\"I'll be rank 1\") && 0) But when we see the short -circuiting, (printf (\"I'll be rank 1\") && 0) will not execute. Output: 1. •printf () is defined in the <stdio.h > header file. •It returns the number of characters it prints. •If an error occurs, it returns…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Provide one short quote (1–2 sentences) from the notes that best represents the topic.", "gold_answer": "Scanf in C Functions A function is a block of code that performs a specific task. It promotes code reusability and modular programming . •scanf () is defined in the <stdio.h> header file. •It is used to read input from the user. •scanf () returns the number of…", "gold_evidence": "[p11:c17] Scanf in C\nFunctions\nA function  is a block of code that performs a specific\ntask. It promotes code reusability  and modular\nprogramming . •scanf () is defined in the <stdio.h>  header file.\n•It is used to read input from the user.\n•scanf () returns the number of input it ems\nsuccessfully assigned.\n•If the input fails (like wrong format or EOF),\nit…\n[p18:c33] tive difference of ASCII\nvalues where mismatch occurs\nStructure in C\nA structure is a user-defined data type in C.\nIt allows you to group different types of variables under one name.\nby default, structure contains the 0 or null values.\nUseful for representing real -world entities (e.g.,\nstudent, book,\nemployee, etc.). Note: \"hello\" is a  string lit…\n[p4:c5] Bitwise Operators\nLogical AND (&&)\n(Expression 1 && expression 2)\nReturns:\n•true (1) if both conditions are true\n•false (0) if either condition is false\nIt has the short circuiting, means if the first operand\noutput is 0 or false then second expression will not be\nevaluated.\nLogical OR ( | | )\n(Expression 1 || expression 2)\nReturns:\n•false (0) if b…\n[p15:c24] Array\nPointers\n•Array name represents the address of its first\nelement.\nint arr [5];\nprintf (\"%p\", arr); // Prints address of arr [0]);\narr means &arr[0]\n•Array name is constant, so it can’t be the left\nvalue.\narr = value; → Invalid\n•Array size must be a constant or fixed expressio n\n(at compile time).\nint arr[10]; valid\nint size; int arr[size]; in…", "draft_gold_evidence": "[p11:c17] Scanf in C\nFunctions\nA function  is a block of code that performs a specific\ntask. It promotes code reusability  and modular\nprogramming . •scanf () is defined in the <stdio.h>  header file.\n•It is used to read input from the user.\n•scanf () returns the number of input it ems\nsuccessfully assigned.\n•If the input fails (like wrong format or EOF),\nit…\n[p18:c33] tive difference of ASCII\nvalues where mismatch occurs\nStructure in C\nA structure is a user-defined data type in C.\nIt allows you to group different types of variables under one name.\nby default, structure contains the 0 or null values.\nUseful for representing real -world entities (e.g.,\nstudent, book,\nemployee, etc.). Note: \"hello\" is a  string lit…\n[p4:c5] Bitwise Operators\nLogical AND (&&)\n(Expression 1 && expression 2)\nReturns:\n•true (1) if both conditions are true\n•false (0) if either condition is false\nIt has the short circuiting, means if the first operand\noutput is 0 or false then second expression will not be\nevaluated.\nLogical OR ( | | )\n(Expression 1 || expression 2)\nReturns:\n•false (0) if b…\n[p15:c24] Array\nPointers\n•Array name represents the address of its first\nelement.\nint arr [5];\nprintf (\"%p\", arr); // Prints address of arr [0]);\narr means &arr[0]\n•Array name is constant, so it can’t be the left\nvalue.\narr = value; → Invalid\n•Array size must be a constant or fixed expressio n\n(at compile time).\nint arr[10]; valid\nint size; int arr[size]; in…", "draft_gold_answer": "Scanf in C Functions A function is a block of code that performs a specific task. It promotes code reusability and modular programming . •scanf () is defined in the <stdio.h> header file. •It is used to read input from the user. •scanf () returns the number of…"}
{"doc_id": "30d67c73bad36bf8", "pdf_path": "eval/pdfs/public/C-PROGRAMMING_SHORT_NOTES-_compressed-.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one abbreviation/acronym expanded in the notes? If none, answer 'Not found in the document.'", "gold_answer": "tf(\"I'll be rank 1\") && 0) But when we see the short -circuiting, (printf (\"I'll be rank 1\") && 0) will not execute. Output: 1. •printf () is defined in the <stdio.h > header file. •It returns the number of characters it prints. •If an error occurs, it returns…", "gold_evidence": "[p10:c16] tf(\"I'll be rank 1\") && 0)\nBut when we see the short -circuiting, (printf (\"I'll\nbe rank 1\") && 0) will not execute.\nOutput: 1.\n•printf () is defined in the <stdio.h > header file.\n•It returns the number of characters it prints.\n•If an error occurs, it returns a negative number\n(usually -1).\n•Format specifiers like %s (for strings), %d (for\ninteger…\n[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p6:c10] lse.\nYou cannot  write else without if.\nelse {\n// statement;\n} // invalid, compiler give the error of wrong\nsyntax\nIf( )\nStatement;  // expression is mandatory in the if block\nIf(1)    –> this is perfect statements\nNote:  In C, if you do not use curly braces {} after an if\nstatement, only the very next single statement is\nconsidered part of the if…\n[p8:c12] s all the blocks condition are true. But we\ncheck first condition which is if(x > 10) and it comes\ntrue then we will not execute to the next level, even\nif the next blocks like else if(x>5), else(x>0) are true.\nValid syntax:\nfor (exp1; exp2; exp3) {\nStatements;\n}\nFlow:  exp1 →  exp2? → statements → exp3\nExpression inside the for loop are optional.…", "draft_gold_evidence": "[p10:c16] tf(\"I'll be rank 1\") && 0)\nBut when we see the short -circuiting, (printf (\"I'll\nbe rank 1\") && 0) will not execute.\nOutput: 1.\n•printf () is defined in the <stdio.h > header file.\n•It returns the number of characters it prints.\n•If an error occurs, it returns a negative number\n(usually -1).\n•Format specifiers like %s (for strings), %d (for\ninteger…\n[p11:c18] prototype declares a\nfunction's name, return type, and parameters to\nthe compiler before its definition, enabling type\nchecking and early function calls.\nint add (int, int);  // Function prototype\nNote:\n•If you do not specify a return type, the\ndefault return type is considered as int.\n•If the definition or call mismatches the\nprototype, the compil…\n[p6:c10] lse.\nYou cannot  write else without if.\nelse {\n// statement;\n} // invalid, compiler give the error of wrong\nsyntax\nIf( )\nStatement;  // expression is mandatory in the if block\nIf(1)    –> this is perfect statements\nNote:  In C, if you do not use curly braces {} after an if\nstatement, only the very next single statement is\nconsidered part of the if…\n[p8:c12] s all the blocks condition are true. But we\ncheck first condition which is if(x > 10) and it comes\ntrue then we will not execute to the next level, even\nif the next blocks like else if(x>5), else(x>0) are true.\nValid syntax:\nfor (exp1; exp2; exp3) {\nStatements;\n}\nFlow:  exp1 →  exp2? → statements → exp3\nExpression inside the for loop are optional.…", "draft_gold_answer": "tf(\"I'll be rank 1\") && 0) But when we see the short -circuiting, (printf (\"I'll be rank 1\") && 0) will not execute. Output: 1. •printf () is defined in the <stdio.h > header file. •It returns the number of characters it prints. •If an error occurs, it returns…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the main topic of these notes?", "gold_answer": "1.INTRODUCTION TO COMPILER ●A compiler is a type of translator that converts a program written in a high- level language (called source language) into a low -level language (called machine or object language). ●If there is any mistake in the code, the compiler…", "gold_evidence": "[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p12:c25] ●LALR(1) is less powerful than CLR(1) but\nmore powerful than SLR(1)  and LR(0).\n●Every LALR(1) grammar is also CLR(1) .\nBut CLR(1) grammar is not LALR(1) .\n●Parsing table size is the same as SLR(1),\nwhich  makes LALR(1) efficient and practical .\nParser Comparison :\n●OPP = Operator Precedence Parser\n●LL(1) = Top -down parser\n●LR(0), SLR(1), LALR(1),…\n[p14:c31] multiple machines  from the\nsame compiler.\n➢ It helps in optimization  (because this code is\neasier to analyze).\n➢ Also used in error detection  and debugging .\nTypes of Intermediate Representations:\nIntermediate code can be represented i n two main\nforms: 1. Linear Form:\nInstructions are written one after another (like\nassembly code)\nA.Postfix cod…\n[p14:c29] Syntax Directed Definition (SDD) :\nIt is of two types.\n1. S-attributed SDD :\n○Uses only synthesized attributes .\n○The semantic actions (or computations) are\nplaced at the end of the production rules.\n○Evaluation follows a bottom-up approach .\nExam ple:\nFor the rule:\nA → BC { A.i = f(B.i or C.i) }\nHere, A.i depends on B.i  or C.i (children of the no…", "draft_gold_evidence": "[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p12:c25] ●LALR(1) is less powerful than CLR(1) but\nmore powerful than SLR(1)  and LR(0).\n●Every LALR(1) grammar is also CLR(1) .\nBut CLR(1) grammar is not LALR(1) .\n●Parsing table size is the same as SLR(1),\nwhich  makes LALR(1) efficient and practical .\nParser Comparison :\n●OPP = Operator Precedence Parser\n●LL(1) = Top -down parser\n●LR(0), SLR(1), LALR(1),…\n[p14:c31] multiple machines  from the\nsame compiler.\n➢ It helps in optimization  (because this code is\neasier to analyze).\n➢ Also used in error detection  and debugging .\nTypes of Intermediate Representations:\nIntermediate code can be represented i n two main\nforms: 1. Linear Form:\nInstructions are written one after another (like\nassembly code)\nA.Postfix cod…\n[p14:c29] Syntax Directed Definition (SDD) :\nIt is of two types.\n1. S-attributed SDD :\n○Uses only synthesized attributes .\n○The semantic actions (or computations) are\nplaced at the end of the production rules.\n○Evaluation follows a bottom-up approach .\nExam ple:\nFor the rule:\nA → BC { A.i = f(B.i or C.i) }\nHere, A.i depends on B.i  or C.i (children of the no…", "draft_gold_answer": "1.INTRODUCTION TO COMPILER ●A compiler is a type of translator that converts a program written in a high- level language (called source language) into a low -level language (called machine or object language). ●If there is any mistake in the code, the compiler…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 5 key concepts covered.", "gold_answer": ". 5.Executable Code: Final code which runs on the machine. So the final output is the executable file that we can run. Page No:- 02 COMPILER DESIGN GATE फर्रे", "gold_evidence": "[p3:c4] .\n5.Executable Code:\nFinal code which runs on the machine.\nSo the final output is the executable file that we can run.\nPage No:- 02\nCOMPILER DESIGN\nGATE फर्रे\n[p4:c7] rals – values like 5 , \"hello\"\n●Punctuation/Special Symbols – like ;, (), {}\nExample: int sum = a + 5;\nTokens in this line:\n1.int, 2. sum, 3.  =, 4. a, 5. +, 6. 5,  7. ;\nTotal tokens = 7\nNote : Spaces are not counted as tokens.\nPage No:- 03\nCOMPILER DESIGN\nGATE फर्रे\n[p17:c38] ter-procedural  optimization.Optimization Techniques:\n1.Constant Folding\n2.Copy Propagation\n3.Strength Reduction\n4.Dead Code Elimination\n5.Common Sub-expression Elimination\n6.Loop Optimizati on\n7.Peephole Optimization\nConstant Folding\n●Evaluate constant expressions at compiletime.\nExample:\nx = 2 * 3 + y →x = 6 + y (Folding done)\nBut if a variable i…\n[p4:c6] ributes .\nImportant Definitions\n➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern.\nExample: x, +, 123\n➢ Token : A structured representation of a lexeme,\nusually as a pair:\n<token -type, attribute> .\nExample: <IDENTIFIER, name> , <NUMBER,\nvalue>➢ Attribute : Extra information associated with the\ntoken, such as the actual…", "draft_gold_evidence": "[p3:c4] .\n5.Executable Code:\nFinal code which runs on the machine.\nSo the final output is the executable file that we can run.\nPage No:- 02\nCOMPILER DESIGN\nGATE फर्रे\n[p4:c7] rals – values like 5 , \"hello\"\n●Punctuation/Special Symbols – like ;, (), {}\nExample: int sum = a + 5;\nTokens in this line:\n1.int, 2. sum, 3.  =, 4. a, 5. +, 6. 5,  7. ;\nTotal tokens = 7\nNote : Spaces are not counted as tokens.\nPage No:- 03\nCOMPILER DESIGN\nGATE फर्रे\n[p17:c38] ter-procedural  optimization.Optimization Techniques:\n1.Constant Folding\n2.Copy Propagation\n3.Strength Reduction\n4.Dead Code Elimination\n5.Common Sub-expression Elimination\n6.Loop Optimizati on\n7.Peephole Optimization\nConstant Folding\n●Evaluate constant expressions at compiletime.\nExample:\nx = 2 * 3 + y →x = 6 + y (Folding done)\nBut if a variable i…\n[p4:c6] ributes .\nImportant Definitions\n➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern.\nExample: x, +, 123\n➢ Token : A structured representation of a lexeme,\nusually as a pair:\n<token -type, attribute> .\nExample: <IDENTIFIER, name> , <NUMBER,\nvalue>➢ Attribute : Extra information associated with the\ntoken, such as the actual…", "draft_gold_answer": ". 5.Executable Code: Final code which runs on the machine. So the final output is the executable file that we can run. Page No:- 02 COMPILER DESIGN GATE फर्रे"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Define two important terms exactly as stated in the notes.", "gold_answer": "2.LEXICAL ANALYSIS Introduction to Lexical Analysis ➢ Lexical Analysis is the first phase of a compiler . ➢ It reads the source code character bycharacter and converts it into tokens . ➢ The lexical analyzer is also called scanner or token recognizer . ➢ It al…", "gold_evidence": "[p4:c5] 2.LEXICAL ANALYSIS\nIntroduction to Lexical Analysis\n➢ Lexical Analysis is the first phase of a\ncompiler .\n➢ It reads the source code character bycharacter  and converts it into tokens .\n➢ The lexical analyzer is also called scanner or\ntoken recognizer .\n➢ It also detects lexical errors , such as invalid\ncharacters.\nFunctions of Lexical Analyzer\n➢ R…\n[p4:c6] ributes .\nImportant Definitions\n➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern.\nExample: x, +, 123\n➢ Token : A structured representation of a lexeme,\nusually as a pair:\n<token -type, attribute> .\nExample: <IDENTIFIER, name> , <NUMBER,\nvalue>➢ Attribute : Extra information associated with the\ntoken, such as the actual…\n[p10:c24] rlapping lookaheads, RR conflict\nmay occur.\nConfl icts in LALR(1):\n●No SR conflict  occurs after merging.\n●But RR conflict  can occur when two reduce\nactions  are possible for the same lookahead\nsymbol .\nExam ple:\nA → α ·, a | t₁ → reduce A →  α\nB → γ ·, a | t₂ → reduce B → γ\n❖If lookahead a  is common in both ( t₁ ∩ t₂ ≠\n∅), then RR conflict  happ…\n[p5:c8] 3. Syntax Analysis\n➢ Syntax analyzer  is also known as parser .\n➢ The syntax  (structure) of a programming\nlanguage is defined using context-free\ngrammar (CFG) .\n➢ A parser  takes the stream of tokens  (whic h are\ngenerated by the lexical analyzer) and checks\nwhether they follow the correct syntax of the\nlanguage or not.\n➢ Grammatical errors in a p…", "draft_gold_evidence": "[p4:c5] 2.LEXICAL ANALYSIS\nIntroduction to Lexical Analysis\n➢ Lexical Analysis is the first phase of a\ncompiler .\n➢ It reads the source code character bycharacter  and converts it into tokens .\n➢ The lexical analyzer is also called scanner or\ntoken recognizer .\n➢ It also detects lexical errors , such as invalid\ncharacters.\nFunctions of Lexical Analyzer\n➢ R…\n[p4:c6] ributes .\nImportant Definitions\n➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern.\nExample: x, +, 123\n➢ Token : A structured representation of a lexeme,\nusually as a pair:\n<token -type, attribute> .\nExample: <IDENTIFIER, name> , <NUMBER,\nvalue>➢ Attribute : Extra information associated with the\ntoken, such as the actual…\n[p10:c24] rlapping lookaheads, RR conflict\nmay occur.\nConfl icts in LALR(1):\n●No SR conflict  occurs after merging.\n●But RR conflict  can occur when two reduce\nactions  are possible for the same lookahead\nsymbol .\nExam ple:\nA → α ·, a | t₁ → reduce A →  α\nB → γ ·, a | t₂ → reduce B → γ\n❖If lookahead a  is common in both ( t₁ ∩ t₂ ≠\n∅), then RR conflict  happ…\n[p5:c8] 3. Syntax Analysis\n➢ Syntax analyzer  is also known as parser .\n➢ The syntax  (structure) of a programming\nlanguage is defined using context-free\ngrammar (CFG) .\n➢ A parser  takes the stream of tokens  (whic h are\ngenerated by the lexical analyzer) and checks\nwhether they follow the correct syntax of the\nlanguage or not.\n➢ Grammatical errors in a p…", "draft_gold_answer": "2.LEXICAL ANALYSIS Introduction to Lexical Analysis ➢ Lexical Analysis is the first phase of a compiler . ➢ It reads the source code character bycharacter and converts it into tokens . ➢ The lexical analyzer is also called scanner or token recognizer . ➢ It al…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Write one formula/equation mentioned in the notes (as written).", "gold_answer": "1.INTRODUCTION TO COMPILER ●A compiler is a type of translator that converts a program written in a high- level language (called source language) into a low -level language (called machine or object language). ●If there is any mistake in the code, the compiler…", "gold_evidence": "[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p10:c22] ➢ Each item is written as:\nA → α·β ,a\nwhere a is the lookahead symbol .\n➢ CLR(1) can handle a larger class of grammars\nthan LR(0) and SLR(1), but the size of theparsing table is very large .\nCLR(1) Parsing Table Construction:\ni) Table construction is the same as SL R(1) for shift\nand goto entries.\nii) If state I ᵢ contains a reduce item like A → a·…\n[p4:c6] ributes .\nImportant Definitions\n➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern.\nExample: x, +, 123\n➢ Token : A structured representation of a lexeme,\nusually as a pair:\n<token -type, attribute> .\nExample: <IDENTIFIER, name> , <NUMBER,\nvalue>➢ Attribute : Extra information associated with the\ntoken, such as the actual…\n[p8:c18] the\nLR items .\n○Closure()  adds  more items to a state,\nexpanding it.\n○Goto()  moves  from one state to another,\nfollowing transitions.\nPage No:- 07\nCOMPILER DESIGN\nGATE फर्रे", "draft_gold_evidence": "[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p10:c22] ➢ Each item is written as:\nA → α·β ,a\nwhere a is the lookahead symbol .\n➢ CLR(1) can handle a larger class of grammars\nthan LR(0) and SLR(1), but the size of theparsing table is very large .\nCLR(1) Parsing Table Construction:\ni) Table construction is the same as SL R(1) for shift\nand goto entries.\nii) If state I ᵢ contains a reduce item like A → a·…\n[p4:c6] ributes .\nImportant Definitions\n➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern.\nExample: x, +, 123\n➢ Token : A structured representation of a lexeme,\nusually as a pair:\n<token -type, attribute> .\nExample: <IDENTIFIER, name> , <NUMBER,\nvalue>➢ Attribute : Extra information associated with the\ntoken, such as the actual…\n[p8:c18] the\nLR items .\n○Closure()  adds  more items to a state,\nexpanding it.\n○Goto()  moves  from one state to another,\nfollowing transitions.\nPage No:- 07\nCOMPILER DESIGN\nGATE फर्रे", "draft_gold_answer": "1.INTRODUCTION TO COMPILER ●A compiler is a type of translator that converts a program written in a high- level language (called source language) into a low -level language (called machine or object language). ●If there is any mistake in the code, the compiler…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List the steps of one algorithm/procedure described in the notes.", "gold_answer": "-reduce parser. ★ Can be used for ambiguous and unambiguous grammars. ★ It simulates the reverse of rightmost derivation . ★ More powerful than top -down parsing techniques. ★ Time complexity: O(n³) in the general case. Page No:- 06 COMPILER DESIGN GATE फर्रे", "gold_evidence": "[p7:c15] -reduce parser.\n★ Can be used for ambiguous and\nunambiguous grammars.\n★ It simulates the reverse of rightmost\nderivation .\n★ More powerful  than top -down parsing\ntechniques.\n★ Time complexity: O(n³) in the general case.\nPage No:- 06\nCOMPILER DESIGN\nGATE फर्रे\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…\n[p10:c23] , a₁\nB → γ · , a₂\n★ If a₁ ∩ a₂ ≠ ∅, conflict occurs.\nNOT E:\n❖CLR(1) is the most powerful parser.\n❖CLR(1) can handle all LR(0), SLR(1), and\nLALR(1) grammars.\n❖But it is not commonly used  due to the large\ntable size.❖CLR(1) forms the basis for the LALR(1)parser.\nLookahead LR(1) Parser or (LALR(1))\n➢ LALR(1) is made by merging states  in CLR(1)\nwhich…", "draft_gold_evidence": "[p7:c15] -reduce parser.\n★ Can be used for ambiguous and\nunambiguous grammars.\n★ It simulates the reverse of rightmost\nderivation .\n★ More powerful  than top -down parsing\ntechniques.\n★ Time complexity: O(n³) in the general case.\nPage No:- 06\nCOMPILER DESIGN\nGATE फर्रे\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…\n[p10:c23] , a₁\nB → γ · , a₂\n★ If a₁ ∩ a₂ ≠ ∅, conflict occurs.\nNOT E:\n❖CLR(1) is the most powerful parser.\n❖CLR(1) can handle all LR(0), SLR(1), and\nLALR(1) grammars.\n❖But it is not commonly used  due to the large\ntable size.❖CLR(1) forms the basis for the LALR(1)parser.\nLookahead LR(1) Parser or (LALR(1))\n➢ LALR(1) is made by merging states  in CLR(1)\nwhich…", "draft_gold_answer": "-reduce parser. ★ Can be used for ambiguous and unambiguous grammars. ★ It simulates the reverse of rightmost derivation . ★ More powerful than top -down parsing techniques. ★ Time complexity: O(n³) in the general case. Page No:- 06 COMPILER DESIGN GATE फर्रे"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Compare two related concepts/methods mentioned (give at least one difference).", "gold_answer": "1.INTRODUCTION TO COMPILER ●A compiler is a type of translator that converts a program written in a high- level language (called source language) into a low -level language (called machine or object language). ●If there is any mistake in the code, the compiler…", "gold_evidence": "[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p14:c31] multiple machines  from the\nsame compiler.\n➢ It helps in optimization  (because this code is\neasier to analyze).\n➢ Also used in error detection  and debugging .\nTypes of Intermediate Representations:\nIntermediate code can be represented i n two main\nforms: 1. Linear Form:\nInstructions are written one after another (like\nassembly code)\nA.Postfix cod…\n[p13:c28] values for mathemat ical expressions.\n★ An annotated parse tree  shows the attributes for\neach node in the parse tree. This helps us\nunderstand the meaning of the program and theintermediate values at each step.\nAttrib utes:\nIt is of two types.\n1.Inherited Attribute (RHS) : The value of an\ninherited attribute is calculated based on theparent or sib…\n[p10:c23] , a₁\nB → γ · , a₂\n★ If a₁ ∩ a₂ ≠ ∅, conflict occurs.\nNOT E:\n❖CLR(1) is the most powerful parser.\n❖CLR(1) can handle all LR(0), SLR(1), and\nLALR(1) grammars.\n❖But it is not commonly used  due to the large\ntable size.❖CLR(1) forms the basis for the LALR(1)parser.\nLookahead LR(1) Parser or (LALR(1))\n➢ LALR(1) is made by merging states  in CLR(1)\nwhich…", "draft_gold_evidence": "[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p14:c31] multiple machines  from the\nsame compiler.\n➢ It helps in optimization  (because this code is\neasier to analyze).\n➢ Also used in error detection  and debugging .\nTypes of Intermediate Representations:\nIntermediate code can be represented i n two main\nforms: 1. Linear Form:\nInstructions are written one after another (like\nassembly code)\nA.Postfix cod…\n[p13:c28] values for mathemat ical expressions.\n★ An annotated parse tree  shows the attributes for\neach node in the parse tree. This helps us\nunderstand the meaning of the program and theintermediate values at each step.\nAttrib utes:\nIt is of two types.\n1.Inherited Attribute (RHS) : The value of an\ninherited attribute is calculated based on theparent or sib…\n[p10:c23] , a₁\nB → γ · , a₂\n★ If a₁ ∩ a₂ ≠ ∅, conflict occurs.\nNOT E:\n❖CLR(1) is the most powerful parser.\n❖CLR(1) can handle all LR(0), SLR(1), and\nLALR(1) grammars.\n❖But it is not commonly used  due to the large\ntable size.❖CLR(1) forms the basis for the LALR(1)parser.\nLookahead LR(1) Parser or (LALR(1))\n➢ LALR(1) is made by merging states  in CLR(1)\nwhich…", "draft_gold_answer": "1.INTRODUCTION TO COMPILER ●A compiler is a type of translator that converts a program written in a high- level language (called source language) into a low -level language (called machine or object language). ●If there is any mistake in the code, the compiler…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List any assumptions, prerequisites, or constraints mentioned.", "gold_answer": "hich the string of a variable starts. ○It never contains a variable but cancontain the empty string ( ε). ○The First Set can always be determined for any variable. Follow Set: ●The Follow Set contains terminals and the special symbol $ (end of input). ●It neve…", "gold_evidence": "[p6:c12] hich the string of a  variable\nstarts.\n○It never contains a variable but cancontain the empty string ( ε).\n○The First Set can always be\ndetermined for any variable.\nFollow Set:\n●The Follow Set contains terminals  and the\nspecial symbol $ (end of input).\n●It never contains  variab les or the empty\nstring (ε).\n●How to Find the Follow Set:\n1.Include $…\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…\n[p9:c19] LR(0) Parsing Table Construction:\nWhile creating the parsing table :\n1.If GOTO (I ₖ, a) = Iⱼ, set the action as shift: [i,\na] = Sⱼ.\n2.If GOTO (I ₖ, A) = Iⱼ, set the action as state\nentry : [i, A] = j .\n3.If Iᵢ contains A → α· (reduced production),\nset the action as reduce : [i, all entries] = R ₚ.\nWhere P is the production number  and A →\nα is the…", "draft_gold_evidence": "[p6:c12] hich the string of a  variable\nstarts.\n○It never contains a variable but cancontain the empty string ( ε).\n○The First Set can always be\ndetermined for any variable.\nFollow Set:\n●The Follow Set contains terminals  and the\nspecial symbol $ (end of input).\n●It never contains  variab les or the empty\nstring (ε).\n●How to Find the Follow Set:\n1.Include $…\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…\n[p9:c19] LR(0) Parsing Table Construction:\nWhile creating the parsing table :\n1.If GOTO (I ₖ, a) = Iⱼ, set the action as shift: [i,\na] = Sⱼ.\n2.If GOTO (I ₖ, A) = Iⱼ, set the action as state\nentry : [i, A] = j .\n3.If Iᵢ contains A → α· (reduced production),\nset the action as reduce : [i, all entries] = R ₚ.\nWhere P is the production number  and A →\nα is the…", "draft_gold_answer": "hich the string of a variable starts. ○It never contains a variable but cancontain the empty string ( ε). ○The First Set can always be determined for any variable. Follow Set: ●The Follow Set contains terminals and the special symbol $ (end of input). ●It neve…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Give one example mentioned in the notes.", "gold_answer": "ributes . Important Definitions ➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern. Example: x, +, 123 ➢ Token : A structured representation of a lexeme, usually as a pair: <token -type, attribute> . Example: <IDENTIFIER, name> , <NU…", "gold_evidence": "[p4:c6] ributes .\nImportant Definitions\n➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern.\nExample: x, +, 123\n➢ Token : A structured representation of a lexeme,\nusually as a pair:\n<token -type, attribute> .\nExample: <IDENTIFIER, name> , <NUMBER,\nvalue>➢ Attribute : Extra information associated with the\ntoken, such as the actual…\n[p8:c17] te.Conf licts in LR(0) Parser:\n1. Shift-Reduce (SR) Conflict:\n●This happens when, in one state, both shiftand reduce  actions are possible.\n○Shift means moving to the nextsymbol.\n○Reduce  means applying a rule to\nreduce part of the string.\n●The parser doesn’t know whether to shift or\nreduce , causing a conflict.\nExample :\n○If you have A → α·xβ (shi…\n[p8:c18] the\nLR items .\n○Closure()  adds  more items to a state,\nexpanding it.\n○Goto()  moves  from one state to another,\nfollowing transitions.\nPage No:- 07\nCOMPILER DESIGN\nGATE फर्रे\n[p14:c31] multiple machines  from the\nsame compiler.\n➢ It helps in optimization  (because this code is\neasier to analyze).\n➢ Also used in error detection  and debugging .\nTypes of Intermediate Representations:\nIntermediate code can be represented i n two main\nforms: 1. Linear Form:\nInstructions are written one after another (like\nassembly code)\nA.Postfix cod…", "draft_gold_evidence": "[p4:c6] ributes .\nImportant Definitions\n➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern.\nExample: x, +, 123\n➢ Token : A structured representation of a lexeme,\nusually as a pair:\n<token -type, attribute> .\nExample: <IDENTIFIER, name> , <NUMBER,\nvalue>➢ Attribute : Extra information associated with the\ntoken, such as the actual…\n[p8:c17] te.Conf licts in LR(0) Parser:\n1. Shift-Reduce (SR) Conflict:\n●This happens when, in one state, both shiftand reduce  actions are possible.\n○Shift means moving to the nextsymbol.\n○Reduce  means applying a rule to\nreduce part of the string.\n●The parser doesn’t know whether to shift or\nreduce , causing a conflict.\nExample :\n○If you have A → α·xβ (shi…\n[p8:c18] the\nLR items .\n○Closure()  adds  more items to a state,\nexpanding it.\n○Goto()  moves  from one state to another,\nfollowing transitions.\nPage No:- 07\nCOMPILER DESIGN\nGATE फर्रे\n[p14:c31] multiple machines  from the\nsame compiler.\n➢ It helps in optimization  (because this code is\neasier to analyze).\n➢ Also used in error detection  and debugging .\nTypes of Intermediate Representations:\nIntermediate code can be represented i n two main\nforms: 1. Linear Form:\nInstructions are written one after another (like\nassembly code)\nA.Postfix cod…", "draft_gold_answer": "ributes . Important Definitions ➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern. Example: x, +, 123 ➢ Token : A structured representation of a lexeme, usually as a pair: <token -type, attribute> . Example: <IDENTIFIER, name> , <NU…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What are the advantages and limitations of the main method/topic (as stated)?", "gold_answer": "★ Handle pruning is the main source of overhead. ★ Capable of handling left recursion and common prefixes . ★ Some unambiguous grammars may still not have any bottom- up parser. Types of Bottom -Up Parsers Bottom -up parsers include various LR -based parsers ,…", "gold_evidence": "[p8:c16] ★ Handle pruning  is the main source of\noverhead.\n★ Capable of handling left recursion  and\ncommon prefixes .\n★ Some unambiguous grammars  may still not\nhave any bottom- up parser.\nTypes of Bottom -Up Parsers\nBottom -up parsers include various LR -based\nparsers , such as:\n1.LR(0)\n2.SLR(1) – Simple LR\n3.LR(1)  – Canonical LR\n4.LALR(1) – Look -Ahead…\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p4:c6] ributes .\nImportant Definitions\n➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern.\nExample: x, +, 123\n➢ Token : A structured representation of a lexeme,\nusually as a pair:\n<token -type, attribute> .\nExample: <IDENTIFIER, name> , <NUMBER,\nvalue>➢ Attribute : Extra information associated with the\ntoken, such as the actual…\n[p8:c17] te.Conf licts in LR(0) Parser:\n1. Shift-Reduce (SR) Conflict:\n●This happens when, in one state, both shiftand reduce  actions are possible.\n○Shift means moving to the nextsymbol.\n○Reduce  means applying a rule to\nreduce part of the string.\n●The parser doesn’t know whether to shift or\nreduce , causing a conflict.\nExample :\n○If you have A → α·xβ (shi…", "draft_gold_evidence": "[p8:c16] ★ Handle pruning  is the main source of\noverhead.\n★ Capable of handling left recursion  and\ncommon prefixes .\n★ Some unambiguous grammars  may still not\nhave any bottom- up parser.\nTypes of Bottom -Up Parsers\nBottom -up parsers include various LR -based\nparsers , such as:\n1.LR(0)\n2.SLR(1) – Simple LR\n3.LR(1)  – Canonical LR\n4.LALR(1) – Look -Ahead…\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p4:c6] ributes .\nImportant Definitions\n➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern.\nExample: x, +, 123\n➢ Token : A structured representation of a lexeme,\nusually as a pair:\n<token -type, attribute> .\nExample: <IDENTIFIER, name> , <NUMBER,\nvalue>➢ Attribute : Extra information associated with the\ntoken, such as the actual…\n[p8:c17] te.Conf licts in LR(0) Parser:\n1. Shift-Reduce (SR) Conflict:\n●This happens when, in one state, both shiftand reduce  actions are possible.\n○Shift means moving to the nextsymbol.\n○Reduce  means applying a rule to\nreduce part of the string.\n●The parser doesn’t know whether to shift or\nreduce , causing a conflict.\nExample :\n○If you have A → α·xβ (shi…", "draft_gold_answer": "★ Handle pruning is the main source of overhead. ★ Capable of handling left recursion and common prefixes . ★ Some unambiguous grammars may still not have any bottom- up parser. Types of Bottom -Up Parsers Bottom -up parsers include various LR -based parsers ,…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Summarize the key takeaways in 3 bullet points.", "gold_answer": "constructed in a similar way to LR(0) except for the reduced entries . 2.If a state Iᵢ contains a reduced production like A → α·, we find the FOLLOW(A) set. For every element in FOLLOW(A), we set the action [i, a] = Rₚ where P is the production number. Impo rt…", "gold_evidence": "[p9:c21] constructed in a similar way\nto LR(0)  except for the reduced entries .\n2.If a state Iᵢ  contains a reduced production like\nA → α·, we find the FOLLOW(A)  set. For\nevery element in FOLLOW(A), we set the\naction [i, a] = Rₚ  where P is the production\nnumber.\nImpo rtant Points on SLR(1):\n1.SLR(1) is more powerful than LR(0) because\nit can handle a wid…\n[p19:c42] ally.\n○Managed by garbage collector.\n○Uses heap- based memory.Activation Records\n●A block of memory used during the executionof a procedure.\n●Created when a procedure is called anddestroyed when it returns.\nContents of Activation Record:\n1.Return Value\n2.Static Link\n3.Dynamic Link\n4.Stack Pointer (SP) – Points to top of the stack\n5.Return Address\n6…\n[p6:c12] hich the string of a  variable\nstarts.\n○It never contains a variable but cancontain the empty string ( ε).\n○The First Set can always be\ndetermined for any variable.\nFollow Set:\n●The Follow Set contains terminals  and the\nspecial symbol $ (end of input).\n●It never contains  variab les or the empty\nstring (ε).\n●How to Find the Follow Set:\n1.Include $…\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…", "draft_gold_evidence": "[p9:c21] constructed in a similar way\nto LR(0)  except for the reduced entries .\n2.If a state Iᵢ  contains a reduced production like\nA → α·, we find the FOLLOW(A)  set. For\nevery element in FOLLOW(A), we set the\naction [i, a] = Rₚ  where P is the production\nnumber.\nImpo rtant Points on SLR(1):\n1.SLR(1) is more powerful than LR(0) because\nit can handle a wid…\n[p19:c42] ally.\n○Managed by garbage collector.\n○Uses heap- based memory.Activation Records\n●A block of memory used during the executionof a procedure.\n●Created when a procedure is called anddestroyed when it returns.\nContents of Activation Record:\n1.Return Value\n2.Static Link\n3.Dynamic Link\n4.Stack Pointer (SP) – Points to top of the stack\n5.Return Address\n6…\n[p6:c12] hich the string of a  variable\nstarts.\n○It never contains a variable but cancontain the empty string ( ε).\n○The First Set can always be\ndetermined for any variable.\nFollow Set:\n●The Follow Set contains terminals  and the\nspecial symbol $ (end of input).\n●It never contains  variab les or the empty\nstring (ε).\n●How to Find the Follow Set:\n1.Include $…\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…", "draft_gold_answer": "constructed in a similar way to LR(0) except for the reduced entries . 2.If a state Iᵢ contains a reduced production like A → α·, we find the FOLLOW(A) set. For every element in FOLLOW(A), we set the action [i, a] = Rₚ where P is the production number. Impo rt…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Is there any deadline/submission instruction in the document? If not, answer 'Not found in the document.'", "gold_answer": "hich the string of a variable starts. ○It never contains a variable but cancontain the empty string ( ε). ○The First Set can always be determined for any variable. Follow Set: ●The Follow Set contains terminals and the special symbol $ (end of input). ●It neve…", "gold_evidence": "[p6:c12] hich the string of a  variable\nstarts.\n○It never contains a variable but cancontain the empty string ( ε).\n○The First Set can always be\ndetermined for any variable.\nFollow Set:\n●The Follow Set contains terminals  and the\nspecial symbol $ (end of input).\n●It never contains  variab les or the empty\nstring (ε).\n●How to Find the Follow Set:\n1.Include $…\n[p10:c24] rlapping lookaheads, RR conflict\nmay occur.\nConfl icts in LALR(1):\n●No SR conflict  occurs after merging.\n●But RR conflict  can occur when two reduce\nactions  are possible for the same lookahead\nsymbol .\nExam ple:\nA → α ·, a | t₁ → reduce A →  α\nB → γ ·, a | t₂ → reduce B → γ\n❖If lookahead a  is common in both ( t₁ ∩ t₂ ≠\n∅), then RR conflict  happ…\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…", "draft_gold_evidence": "[p6:c12] hich the string of a  variable\nstarts.\n○It never contains a variable but cancontain the empty string ( ε).\n○The First Set can always be\ndetermined for any variable.\nFollow Set:\n●The Follow Set contains terminals  and the\nspecial symbol $ (end of input).\n●It never contains  variab les or the empty\nstring (ε).\n●How to Find the Follow Set:\n1.Include $…\n[p10:c24] rlapping lookaheads, RR conflict\nmay occur.\nConfl icts in LALR(1):\n●No SR conflict  occurs after merging.\n●But RR conflict  can occur when two reduce\nactions  are possible for the same lookahead\nsymbol .\nExam ple:\nA → α ·, a | t₁ → reduce A →  α\nB → γ ·, a | t₂ → reduce B → γ\n❖If lookahead a  is common in both ( t₁ ∩ t₂ ≠\n∅), then RR conflict  happ…\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…", "draft_gold_answer": "hich the string of a variable starts. ○It never contains a variable but cancontain the empty string ( ε). ○The First Set can always be determined for any variable. Follow Set: ●The Follow Set contains terminals and the special symbol $ (end of input). ●It neve…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one definition stated in the notes? Quote it exactly if present; otherwise answer 'Not found in the document.'", "gold_answer": ", a₁ B → γ · , a₂ ★ If a₁ ∩ a₂ ≠ ∅, conflict occurs. NOT E: ❖CLR(1) is the most powerful parser. ❖CLR(1) can handle all LR(0), SLR(1), and LALR(1) grammars. ❖But it is not commonly used due to the large table size.❖CLR(1) forms the basis for the LALR(1)parser.…", "gold_evidence": "[p10:c23] , a₁\nB → γ · , a₂\n★ If a₁ ∩ a₂ ≠ ∅, conflict occurs.\nNOT E:\n❖CLR(1) is the most powerful parser.\n❖CLR(1) can handle all LR(0), SLR(1), and\nLALR(1) grammars.\n❖But it is not commonly used  due to the large\ntable size.❖CLR(1) forms the basis for the LALR(1)parser.\nLookahead LR(1) Parser or (LALR(1))\n➢ LALR(1) is made by merging states  in CLR(1)\nwhich…\n[p10:c24] rlapping lookaheads, RR conflict\nmay occur.\nConfl icts in LALR(1):\n●No SR conflict  occurs after merging.\n●But RR conflict  can occur when two reduce\nactions  are possible for the same lookahead\nsymbol .\nExam ple:\nA → α ·, a | t₁ → reduce A →  α\nB → γ ·, a | t₂ → reduce B → γ\n❖If lookahead a  is common in both ( t₁ ∩ t₂ ≠\n∅), then RR conflict  happ…\n[p9:c21] constructed in a similar way\nto LR(0)  except for the reduced entries .\n2.If a state Iᵢ  contains a reduced production like\nA → α·, we find the FOLLOW(A)  set. For\nevery element in FOLLOW(A), we set the\naction [i, a] = Rₚ  where P is the production\nnumber.\nImpo rtant Points on SLR(1):\n1.SLR(1) is more powerful than LR(0) because\nit can handle a wid…\n[p8:c17] te.Conf licts in LR(0) Parser:\n1. Shift-Reduce (SR) Conflict:\n●This happens when, in one state, both shiftand reduce  actions are possible.\n○Shift means moving to the nextsymbol.\n○Reduce  means applying a rule to\nreduce part of the string.\n●The parser doesn’t know whether to shift or\nreduce , causing a conflict.\nExample :\n○If you have A → α·xβ (shi…", "draft_gold_evidence": "[p10:c23] , a₁\nB → γ · , a₂\n★ If a₁ ∩ a₂ ≠ ∅, conflict occurs.\nNOT E:\n❖CLR(1) is the most powerful parser.\n❖CLR(1) can handle all LR(0), SLR(1), and\nLALR(1) grammars.\n❖But it is not commonly used  due to the large\ntable size.❖CLR(1) forms the basis for the LALR(1)parser.\nLookahead LR(1) Parser or (LALR(1))\n➢ LALR(1) is made by merging states  in CLR(1)\nwhich…\n[p10:c24] rlapping lookaheads, RR conflict\nmay occur.\nConfl icts in LALR(1):\n●No SR conflict  occurs after merging.\n●But RR conflict  can occur when two reduce\nactions  are possible for the same lookahead\nsymbol .\nExam ple:\nA → α ·, a | t₁ → reduce A →  α\nB → γ ·, a | t₂ → reduce B → γ\n❖If lookahead a  is common in both ( t₁ ∩ t₂ ≠\n∅), then RR conflict  happ…\n[p9:c21] constructed in a similar way\nto LR(0)  except for the reduced entries .\n2.If a state Iᵢ  contains a reduced production like\nA → α·, we find the FOLLOW(A)  set. For\nevery element in FOLLOW(A), we set the\naction [i, a] = Rₚ  where P is the production\nnumber.\nImpo rtant Points on SLR(1):\n1.SLR(1) is more powerful than LR(0) because\nit can handle a wid…\n[p8:c17] te.Conf licts in LR(0) Parser:\n1. Shift-Reduce (SR) Conflict:\n●This happens when, in one state, both shiftand reduce  actions are possible.\n○Shift means moving to the nextsymbol.\n○Reduce  means applying a rule to\nreduce part of the string.\n●The parser doesn’t know whether to shift or\nreduce , causing a conflict.\nExample :\n○If you have A → α·xβ (shi…", "draft_gold_answer": ", a₁ B → γ · , a₂ ★ If a₁ ∩ a₂ ≠ ∅, conflict occurs. NOT E: ❖CLR(1) is the most powerful parser. ❖CLR(1) can handle all LR(0), SLR(1), and LALR(1) grammars. ❖But it is not commonly used due to the large table size.❖CLR(1) forms the basis for the LALR(1)parser.…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the time complexity of one algorithm mentioned (as stated)? If not present, answer 'Not found in the document.'", "gold_answer": "-reduce parser. ★ Can be used for ambiguous and unambiguous grammars. ★ It simulates the reverse of rightmost derivation . ★ More powerful than top -down parsing techniques. ★ Time complexity: O(n³) in the general case. Page No:- 06 COMPILER DESIGN GATE फर्रे", "gold_evidence": "[p7:c15] -reduce parser.\n★ Can be used for ambiguous and\nunambiguous grammars.\n★ It simulates the reverse of rightmost\nderivation .\n★ More powerful  than top -down parsing\ntechniques.\n★ Time complexity: O(n³) in the general case.\nPage No:- 06\nCOMPILER DESIGN\nGATE फर्रे\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…\n[p9:c21] constructed in a similar way\nto LR(0)  except for the reduced entries .\n2.If a state Iᵢ  contains a reduced production like\nA → α·, we find the FOLLOW(A)  set. For\nevery element in FOLLOW(A), we set the\naction [i, a] = Rₚ  where P is the production\nnumber.\nImpo rtant Points on SLR(1):\n1.SLR(1) is more powerful than LR(0) because\nit can handle a wid…\n[p10:c22] ➢ Each item is written as:\nA → α·β ,a\nwhere a is the lookahead symbol .\n➢ CLR(1) can handle a larger class of grammars\nthan LR(0) and SLR(1), but the size of theparsing table is very large .\nCLR(1) Parsing Table Construction:\ni) Table construction is the same as SL R(1) for shift\nand goto entries.\nii) If state I ᵢ contains a reduce item like A → a·…", "draft_gold_evidence": "[p7:c15] -reduce parser.\n★ Can be used for ambiguous and\nunambiguous grammars.\n★ It simulates the reverse of rightmost\nderivation .\n★ More powerful  than top -down parsing\ntechniques.\n★ Time complexity: O(n³) in the general case.\nPage No:- 06\nCOMPILER DESIGN\nGATE फर्रे\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…\n[p9:c21] constructed in a similar way\nto LR(0)  except for the reduced entries .\n2.If a state Iᵢ  contains a reduced production like\nA → α·, we find the FOLLOW(A)  set. For\nevery element in FOLLOW(A), we set the\naction [i, a] = Rₚ  where P is the production\nnumber.\nImpo rtant Points on SLR(1):\n1.SLR(1) is more powerful than LR(0) because\nit can handle a wid…\n[p10:c22] ➢ Each item is written as:\nA → α·β ,a\nwhere a is the lookahead symbol .\n➢ CLR(1) can handle a larger class of grammars\nthan LR(0) and SLR(1), but the size of theparsing table is very large .\nCLR(1) Parsing Table Construction:\ni) Table construction is the same as SL R(1) for shift\nand goto entries.\nii) If state I ᵢ contains a reduce item like A → a·…", "draft_gold_answer": "-reduce parser. ★ Can be used for ambiguous and unambiguous grammars. ★ It simulates the reverse of rightmost derivation . ★ More powerful than top -down parsing techniques. ★ Time complexity: O(n³) in the general case. Page No:- 06 COMPILER DESIGN GATE फर्रे"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 3 important keywords/terms that appear in the notes.", "gold_answer": "ributes . Important Definitions ➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern. Example: x, +, 123 ➢ Token : A structured representation of a lexeme, usually as a pair: <token -type, attribute> . Example: <IDENTIFIER, name> , <NU…", "gold_evidence": "[p4:c6] ributes .\nImportant Definitions\n➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern.\nExample: x, +, 123\n➢ Token : A structured representation of a lexeme,\nusually as a pair:\n<token -type, attribute> .\nExample: <IDENTIFIER, name> , <NUMBER,\nvalue>➢ Attribute : Extra information associated with the\ntoken, such as the actual…\n[p9:c19] LR(0) Parsing Table Construction:\nWhile creating the parsing table :\n1.If GOTO (I ₖ, a) = Iⱼ, set the action as shift: [i,\na] = Sⱼ.\n2.If GOTO (I ₖ, A) = Iⱼ, set the action as state\nentry : [i, A] = j .\n3.If Iᵢ contains A → α· (reduced production),\nset the action as reduce : [i, all entries] = R ₚ.\nWhere P is the production number  and A →\nα is the…\n[p4:c5] 2.LEXICAL ANALYSIS\nIntroduction to Lexical Analysis\n➢ Lexical Analysis is the first phase of a\ncompiler .\n➢ It reads the source code character bycharacter  and converts it into tokens .\n➢ The lexical analyzer is also called scanner or\ntoken recognizer .\n➢ It also detects lexical errors , such as invalid\ncharacters.\nFunctions of Lexical Analyzer\n➢ R…\n[p3:c4] .\n5.Executable Code:\nFinal code which runs on the machine.\nSo the final output is the executable file that we can run.\nPage No:- 02\nCOMPILER DESIGN\nGATE फर्रे", "draft_gold_evidence": "[p4:c6] ributes .\nImportant Definitions\n➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern.\nExample: x, +, 123\n➢ Token : A structured representation of a lexeme,\nusually as a pair:\n<token -type, attribute> .\nExample: <IDENTIFIER, name> , <NUMBER,\nvalue>➢ Attribute : Extra information associated with the\ntoken, such as the actual…\n[p9:c19] LR(0) Parsing Table Construction:\nWhile creating the parsing table :\n1.If GOTO (I ₖ, a) = Iⱼ, set the action as shift: [i,\na] = Sⱼ.\n2.If GOTO (I ₖ, A) = Iⱼ, set the action as state\nentry : [i, A] = j .\n3.If Iᵢ contains A → α· (reduced production),\nset the action as reduce : [i, all entries] = R ₚ.\nWhere P is the production number  and A →\nα is the…\n[p4:c5] 2.LEXICAL ANALYSIS\nIntroduction to Lexical Analysis\n➢ Lexical Analysis is the first phase of a\ncompiler .\n➢ It reads the source code character bycharacter  and converts it into tokens .\n➢ The lexical analyzer is also called scanner or\ntoken recognizer .\n➢ It also detects lexical errors , such as invalid\ncharacters.\nFunctions of Lexical Analyzer\n➢ R…\n[p3:c4] .\n5.Executable Code:\nFinal code which runs on the machine.\nSo the final output is the executable file that we can run.\nPage No:- 02\nCOMPILER DESIGN\nGATE फर्रे", "draft_gold_answer": "ributes . Important Definitions ➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern. Example: x, +, 123 ➢ Token : A structured representation of a lexeme, usually as a pair: <token -type, attribute> . Example: <IDENTIFIER, name> , <NU…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one theorem/lemma/property stated? If not present, answer 'Not found in the document.'", "gold_answer": "rlapping lookaheads, RR conflict may occur. Confl icts in LALR(1): ●No SR conflict occurs after merging. ●But RR conflict can occur when two reduce actions are possible for the same lookahead symbol . Exam ple: A → α ·, a | t₁ → reduce A → α B → γ ·, a | t₂ →…", "gold_evidence": "[p10:c24] rlapping lookaheads, RR conflict\nmay occur.\nConfl icts in LALR(1):\n●No SR conflict  occurs after merging.\n●But RR conflict  can occur when two reduce\nactions  are possible for the same lookahead\nsymbol .\nExam ple:\nA → α ·, a | t₁ → reduce A →  α\nB → γ ·, a | t₂ → reduce B → γ\n❖If lookahead a  is common in both ( t₁ ∩ t₂ ≠\n∅), then RR conflict  happ…\n[p10:c23] , a₁\nB → γ · , a₂\n★ If a₁ ∩ a₂ ≠ ∅, conflict occurs.\nNOT E:\n❖CLR(1) is the most powerful parser.\n❖CLR(1) can handle all LR(0), SLR(1), and\nLALR(1) grammars.\n❖But it is not commonly used  due to the large\ntable size.❖CLR(1) forms the basis for the LALR(1)parser.\nLookahead LR(1) Parser or (LALR(1))\n➢ LALR(1) is made by merging states  in CLR(1)\nwhich…\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…", "draft_gold_evidence": "[p10:c24] rlapping lookaheads, RR conflict\nmay occur.\nConfl icts in LALR(1):\n●No SR conflict  occurs after merging.\n●But RR conflict  can occur when two reduce\nactions  are possible for the same lookahead\nsymbol .\nExam ple:\nA → α ·, a | t₁ → reduce A →  α\nB → γ ·, a | t₂ → reduce B → γ\n❖If lookahead a  is common in both ( t₁ ∩ t₂ ≠\n∅), then RR conflict  happ…\n[p10:c23] , a₁\nB → γ · , a₂\n★ If a₁ ∩ a₂ ≠ ∅, conflict occurs.\nNOT E:\n❖CLR(1) is the most powerful parser.\n❖CLR(1) can handle all LR(0), SLR(1), and\nLALR(1) grammars.\n❖But it is not commonly used  due to the large\ntable size.❖CLR(1) forms the basis for the LALR(1)parser.\nLookahead LR(1) Parser or (LALR(1))\n➢ LALR(1) is made by merging states  in CLR(1)\nwhich…\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…", "draft_gold_answer": "rlapping lookaheads, RR conflict may occur. Confl icts in LALR(1): ●No SR conflict occurs after merging. ●But RR conflict can occur when two reduce actions are possible for the same lookahead symbol . Exam ple: A → α ·, a | t₁ → reduce A → α B → γ ·, a | t₂ →…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Describe one table/list mentioned (what items are compared or listed). If none, answer 'Not found in the document.'", "gold_answer": ", a₁ B → γ · , a₂ ★ If a₁ ∩ a₂ ≠ ∅, conflict occurs. NOT E: ❖CLR(1) is the most powerful parser. ❖CLR(1) can handle all LR(0), SLR(1), and LALR(1) grammars. ❖But it is not commonly used due to the large table size.❖CLR(1) forms the basis for the LALR(1)parser.…", "gold_evidence": "[p10:c23] , a₁\nB → γ · , a₂\n★ If a₁ ∩ a₂ ≠ ∅, conflict occurs.\nNOT E:\n❖CLR(1) is the most powerful parser.\n❖CLR(1) can handle all LR(0), SLR(1), and\nLALR(1) grammars.\n❖But it is not commonly used  due to the large\ntable size.❖CLR(1) forms the basis for the LALR(1)parser.\nLookahead LR(1) Parser or (LALR(1))\n➢ LALR(1) is made by merging states  in CLR(1)\nwhich…\n[p8:c17] te.Conf licts in LR(0) Parser:\n1. Shift-Reduce (SR) Conflict:\n●This happens when, in one state, both shiftand reduce  actions are possible.\n○Shift means moving to the nextsymbol.\n○Reduce  means applying a rule to\nreduce part of the string.\n●The parser doesn’t know whether to shift or\nreduce , causing a conflict.\nExample :\n○If you have A → α·xβ (shi…\n[p10:c24] rlapping lookaheads, RR conflict\nmay occur.\nConfl icts in LALR(1):\n●No SR conflict  occurs after merging.\n●But RR conflict  can occur when two reduce\nactions  are possible for the same lookahead\nsymbol .\nExam ple:\nA → α ·, a | t₁ → reduce A →  α\nB → γ ·, a | t₂ → reduce B → γ\n❖If lookahead a  is common in both ( t₁ ∩ t₂ ≠\n∅), then RR conflict  happ…\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…", "draft_gold_evidence": "[p10:c23] , a₁\nB → γ · , a₂\n★ If a₁ ∩ a₂ ≠ ∅, conflict occurs.\nNOT E:\n❖CLR(1) is the most powerful parser.\n❖CLR(1) can handle all LR(0), SLR(1), and\nLALR(1) grammars.\n❖But it is not commonly used  due to the large\ntable size.❖CLR(1) forms the basis for the LALR(1)parser.\nLookahead LR(1) Parser or (LALR(1))\n➢ LALR(1) is made by merging states  in CLR(1)\nwhich…\n[p8:c17] te.Conf licts in LR(0) Parser:\n1. Shift-Reduce (SR) Conflict:\n●This happens when, in one state, both shiftand reduce  actions are possible.\n○Shift means moving to the nextsymbol.\n○Reduce  means applying a rule to\nreduce part of the string.\n●The parser doesn’t know whether to shift or\nreduce , causing a conflict.\nExample :\n○If you have A → α·xβ (shi…\n[p10:c24] rlapping lookaheads, RR conflict\nmay occur.\nConfl icts in LALR(1):\n●No SR conflict  occurs after merging.\n●But RR conflict  can occur when two reduce\nactions  are possible for the same lookahead\nsymbol .\nExam ple:\nA → α ·, a | t₁ → reduce A →  α\nB → γ ·, a | t₂ → reduce B → γ\n❖If lookahead a  is common in both ( t₁ ∩ t₂ ≠\n∅), then RR conflict  happ…\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…", "draft_gold_answer": ", a₁ B → γ · , a₂ ★ If a₁ ∩ a₂ ≠ ∅, conflict occurs. NOT E: ❖CLR(1) is the most powerful parser. ❖CLR(1) can handle all LR(0), SLR(1), and LALR(1) grammars. ❖But it is not commonly used due to the large table size.❖CLR(1) forms the basis for the LALR(1)parser.…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one stated limitation/constraint? If none, answer 'Not found in the document.'", "gold_answer": "rlapping lookaheads, RR conflict may occur. Confl icts in LALR(1): ●No SR conflict occurs after merging. ●But RR conflict can occur when two reduce actions are possible for the same lookahead symbol . Exam ple: A → α ·, a | t₁ → reduce A → α B → γ ·, a | t₂ →…", "gold_evidence": "[p10:c24] rlapping lookaheads, RR conflict\nmay occur.\nConfl icts in LALR(1):\n●No SR conflict  occurs after merging.\n●But RR conflict  can occur when two reduce\nactions  are possible for the same lookahead\nsymbol .\nExam ple:\nA → α ·, a | t₁ → reduce A →  α\nB → γ ·, a | t₂ → reduce B → γ\n❖If lookahead a  is common in both ( t₁ ∩ t₂ ≠\n∅), then RR conflict  happ…\n[p10:c23] , a₁\nB → γ · , a₂\n★ If a₁ ∩ a₂ ≠ ∅, conflict occurs.\nNOT E:\n❖CLR(1) is the most powerful parser.\n❖CLR(1) can handle all LR(0), SLR(1), and\nLALR(1) grammars.\n❖But it is not commonly used  due to the large\ntable size.❖CLR(1) forms the basis for the LALR(1)parser.\nLookahead LR(1) Parser or (LALR(1))\n➢ LALR(1) is made by merging states  in CLR(1)\nwhich…\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…", "draft_gold_evidence": "[p10:c24] rlapping lookaheads, RR conflict\nmay occur.\nConfl icts in LALR(1):\n●No SR conflict  occurs after merging.\n●But RR conflict  can occur when two reduce\nactions  are possible for the same lookahead\nsymbol .\nExam ple:\nA → α ·, a | t₁ → reduce A →  α\nB → γ ·, a | t₂ → reduce B → γ\n❖If lookahead a  is common in both ( t₁ ∩ t₂ ≠\n∅), then RR conflict  happ…\n[p10:c23] , a₁\nB → γ · , a₂\n★ If a₁ ∩ a₂ ≠ ∅, conflict occurs.\nNOT E:\n❖CLR(1) is the most powerful parser.\n❖CLR(1) can handle all LR(0), SLR(1), and\nLALR(1) grammars.\n❖But it is not commonly used  due to the large\ntable size.❖CLR(1) forms the basis for the LALR(1)parser.\nLookahead LR(1) Parser or (LALR(1))\n➢ LALR(1) is made by merging states  in CLR(1)\nwhich…\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…", "draft_gold_answer": "rlapping lookaheads, RR conflict may occur. Confl icts in LALR(1): ●No SR conflict occurs after merging. ●But RR conflict can occur when two reduce actions are possible for the same lookahead symbol . Exam ple: A → α ·, a | t₁ → reduce A → α B → γ ·, a | t₂ →…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one stated advantage/benefit? If none, answer 'Not found in the document.'", "gold_answer": "rlapping lookaheads, RR conflict may occur. Confl icts in LALR(1): ●No SR conflict occurs after merging. ●But RR conflict can occur when two reduce actions are possible for the same lookahead symbol . Exam ple: A → α ·, a | t₁ → reduce A → α B → γ ·, a | t₂ →…", "gold_evidence": "[p10:c24] rlapping lookaheads, RR conflict\nmay occur.\nConfl icts in LALR(1):\n●No SR conflict  occurs after merging.\n●But RR conflict  can occur when two reduce\nactions  are possible for the same lookahead\nsymbol .\nExam ple:\nA → α ·, a | t₁ → reduce A →  α\nB → γ ·, a | t₂ → reduce B → γ\n❖If lookahead a  is common in both ( t₁ ∩ t₂ ≠\n∅), then RR conflict  happ…\n[p10:c23] , a₁\nB → γ · , a₂\n★ If a₁ ∩ a₂ ≠ ∅, conflict occurs.\nNOT E:\n❖CLR(1) is the most powerful parser.\n❖CLR(1) can handle all LR(0), SLR(1), and\nLALR(1) grammars.\n❖But it is not commonly used  due to the large\ntable size.❖CLR(1) forms the basis for the LALR(1)parser.\nLookahead LR(1) Parser or (LALR(1))\n➢ LALR(1) is made by merging states  in CLR(1)\nwhich…\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…", "draft_gold_evidence": "[p10:c24] rlapping lookaheads, RR conflict\nmay occur.\nConfl icts in LALR(1):\n●No SR conflict  occurs after merging.\n●But RR conflict  can occur when two reduce\nactions  are possible for the same lookahead\nsymbol .\nExam ple:\nA → α ·, a | t₁ → reduce A →  α\nB → γ ·, a | t₂ → reduce B → γ\n❖If lookahead a  is common in both ( t₁ ∩ t₂ ≠\n∅), then RR conflict  happ…\n[p10:c23] , a₁\nB → γ · , a₂\n★ If a₁ ∩ a₂ ≠ ∅, conflict occurs.\nNOT E:\n❖CLR(1) is the most powerful parser.\n❖CLR(1) can handle all LR(0), SLR(1), and\nLALR(1) grammars.\n❖But it is not commonly used  due to the large\ntable size.❖CLR(1) forms the basis for the LALR(1)parser.\nLookahead LR(1) Parser or (LALR(1))\n➢ LALR(1) is made by merging states  in CLR(1)\nwhich…\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…", "draft_gold_answer": "rlapping lookaheads, RR conflict may occur. Confl icts in LALR(1): ●No SR conflict occurs after merging. ●But RR conflict can occur when two reduce actions are possible for the same lookahead symbol . Exam ple: A → α ·, a | t₁ → reduce A → α B → γ ·, a | t₂ →…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Provide one short quote (1–2 sentences) from the notes that best represents the topic.", "gold_answer": "ktracking ■Examples: ■Recursive Descent Parser ■Non-Recursive Descent Parser ( LL(1) Parser / Predictive Parser) 2.Bottom -Up Parsing ○Starts from leaves and moves towards the root of the parse tree. ○Types of Bottom -Up Parsers:■LR(0) ■SLR(1) ■LALR(1) ■CLR(1)…", "gold_evidence": "[p5:c9] ktracking\n■Examples:\n■Recursive Descent Parser\n■Non-Recursive Descent Parser ( LL(1) Parser /\nPredictive Parser)\n2.Bottom -Up Parsing\n○Starts from leaves and moves towards the\nroot of the parse tree.\n○Types of Bottom -Up Parsers:■LR(0)\n■SLR(1)\n■LALR(1)\n■CLR(1)  or LR(1)  → This is the most\npowerful parser\nAmbiguous Grammar:\nIf a single input string…\n[p8:c18] the\nLR items .\n○Closure()  adds  more items to a state,\nexpanding it.\n○Goto()  moves  from one state to another,\nfollowing transitions.\nPage No:- 07\nCOMPILER DESIGN\nGATE फर्रे\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p4:c6] ributes .\nImportant Definitions\n➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern.\nExample: x, +, 123\n➢ Token : A structured representation of a lexeme,\nusually as a pair:\n<token -type, attribute> .\nExample: <IDENTIFIER, name> , <NUMBER,\nvalue>➢ Attribute : Extra information associated with the\ntoken, such as the actual…", "draft_gold_evidence": "[p5:c9] ktracking\n■Examples:\n■Recursive Descent Parser\n■Non-Recursive Descent Parser ( LL(1) Parser /\nPredictive Parser)\n2.Bottom -Up Parsing\n○Starts from leaves and moves towards the\nroot of the parse tree.\n○Types of Bottom -Up Parsers:■LR(0)\n■SLR(1)\n■LALR(1)\n■CLR(1)  or LR(1)  → This is the most\npowerful parser\nAmbiguous Grammar:\nIf a single input string…\n[p8:c18] the\nLR items .\n○Closure()  adds  more items to a state,\nexpanding it.\n○Goto()  moves  from one state to another,\nfollowing transitions.\nPage No:- 07\nCOMPILER DESIGN\nGATE फर्रे\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p4:c6] ributes .\nImportant Definitions\n➢ Lexeme: A sequence of characters in sourcecode that matches a token pattern.\nExample: x, +, 123\n➢ Token : A structured representation of a lexeme,\nusually as a pair:\n<token -type, attribute> .\nExample: <IDENTIFIER, name> , <NUMBER,\nvalue>➢ Attribute : Extra information associated with the\ntoken, such as the actual…", "draft_gold_answer": "ktracking ■Examples: ■Recursive Descent Parser ■Non-Recursive Descent Parser ( LL(1) Parser / Predictive Parser) 2.Bottom -Up Parsing ○Starts from leaves and moves towards the root of the parse tree. ○Types of Bottom -Up Parsers:■LR(0) ■SLR(1) ■LALR(1) ■CLR(1)…"}
{"doc_id": "cbc0028f3322e9c9", "pdf_path": "eval/pdfs/public/CD_ShortNotes2025-_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one abbreviation/acronym expanded in the notes? If none, answer 'Not found in the document.'", "gold_answer": "rlapping lookaheads, RR conflict may occur. Confl icts in LALR(1): ●No SR conflict occurs after merging. ●But RR conflict can occur when two reduce actions are possible for the same lookahead symbol . Exam ple: A → α ·, a | t₁ → reduce A → α B → γ ·, a | t₂ →…", "gold_evidence": "[p10:c24] rlapping lookaheads, RR conflict\nmay occur.\nConfl icts in LALR(1):\n●No SR conflict  occurs after merging.\n●But RR conflict  can occur when two reduce\nactions  are possible for the same lookahead\nsymbol .\nExam ple:\nA → α ·, a | t₁ → reduce A →  α\nB → γ ·, a | t₂ → reduce B → γ\n❖If lookahead a  is common in both ( t₁ ∩ t₂ ≠\n∅), then RR conflict  happ…\n[p10:c23] , a₁\nB → γ · , a₂\n★ If a₁ ∩ a₂ ≠ ∅, conflict occurs.\nNOT E:\n❖CLR(1) is the most powerful parser.\n❖CLR(1) can handle all LR(0), SLR(1), and\nLALR(1) grammars.\n❖But it is not commonly used  due to the large\ntable size.❖CLR(1) forms the basis for the LALR(1)parser.\nLookahead LR(1) Parser or (LALR(1))\n➢ LALR(1) is made by merging states  in CLR(1)\nwhich…\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…", "draft_gold_evidence": "[p10:c24] rlapping lookaheads, RR conflict\nmay occur.\nConfl icts in LALR(1):\n●No SR conflict  occurs after merging.\n●But RR conflict  can occur when two reduce\nactions  are possible for the same lookahead\nsymbol .\nExam ple:\nA → α ·, a | t₁ → reduce A →  α\nB → γ ·, a | t₂ → reduce B → γ\n❖If lookahead a  is common in both ( t₁ ∩ t₂ ≠\n∅), then RR conflict  happ…\n[p10:c23] , a₁\nB → γ · , a₂\n★ If a₁ ∩ a₂ ≠ ∅, conflict occurs.\nNOT E:\n❖CLR(1) is the most powerful parser.\n❖CLR(1) can handle all LR(0), SLR(1), and\nLALR(1) grammars.\n❖But it is not commonly used  due to the large\ntable size.❖CLR(1) forms the basis for the LALR(1)parser.\nLookahead LR(1) Parser or (LALR(1))\n➢ LALR(1) is made by merging states  in CLR(1)\nwhich…\n[p2:c0] 1.INTRODUCTION TO COMPILER\n●A compiler is a type of translator that converts\na program written in a high- level language\n(called source language) into a low -level\nlanguage (called machine or object language).\n●If there is any mistake in the code, the\ncompiler gives a compilation error.\n●High -level languages can perform more than\none operation in…\n[p7:c13] Example of First and Folow Set\nAlgorithm to Construct Parsing Table:\nRemo ve Left Recursion  (if any).\n1.Left Factor  (remove common prefixes in\nproductions).\n2.Find First and Follow Sets .\n3.Construct the Parsing Table  using First and\nFollow sets.\n4.Increase Look -Ahead Symbol  if necessary\nfor better accuracy.\nLL(1) Parsing Table Construction\n1.…", "draft_gold_answer": "rlapping lookaheads, RR conflict may occur. Confl icts in LALR(1): ●No SR conflict occurs after merging. ●But RR conflict can occur when two reduce actions are possible for the same lookahead symbol . Exam ple: A → α ·, a | t₁ → reduce A → α B → γ ·, a | t₂ →…"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the main topic of these notes?", "gold_answer": "6.1. What Is Pipelining? ●Pipelining is a technique of overlappin g the execution of multiple instructions by dividing the processor’s datapath into stages, each handling a part of the instruction. ●It increases instruction throughputwithout reducing the execu…", "gold_evidence": "[p21:c42] 6.1. What Is Pipelining?\n●Pipelining is a technique of overlappin g\nthe execution of multiple instructions by\ndividing the processor’s datapath into\nstages, each handling a part of the\ninstruction.\n●It increases instruction throughputwithout reducing the execution time of\nindividual instructions.\nCOA\nGATE फर्रे\nPage No:-16\n[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08\n[p23:c47] stage pipeline:\n●Stage EX is finishing Instruction 1\n●Stage FO is loading the operand forInstruction 2\n●Stage DA is decoding Instruction 3\n●Stage FI is fetching Instruction 4\nNow suppose Instruction 3 turns out to be a\nbranch . As soon as it’s decoded in DA (still in\ncycle 4), we stop feeding any new instn from\nFI into DA until we know where the  b…\n[p15:c26] 3.5.4. Registers & Initialization\nRegister  Width  Initial Content\nA n-bit 0…0\nQ n-bit Multiplier\nM n-bit Multiplicand\nQ-1 1 bit 0\nn - Number of bits in\nQ and M\nACC = [A (n bits) | Q (n bits) | Q -1(1 bit)]\nstarts as [0…0 | Q initial | 0]\n3.5.5. Step ‑by‑ Step Algorithm\n1.Initialize A = 0, Q = multiplier, Q₋ ₁  =  0,\ncount = n.\n2.Repeat until count…", "draft_gold_evidence": "[p21:c42] 6.1. What Is Pipelining?\n●Pipelining is a technique of overlappin g\nthe execution of multiple instructions by\ndividing the processor’s datapath into\nstages, each handling a part of the\ninstruction.\n●It increases instruction throughputwithout reducing the execution time of\nindividual instructions.\nCOA\nGATE फर्रे\nPage No:-16\n[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08\n[p23:c47] stage pipeline:\n●Stage EX is finishing Instruction 1\n●Stage FO is loading the operand forInstruction 2\n●Stage DA is decoding Instruction 3\n●Stage FI is fetching Instruction 4\nNow suppose Instruction 3 turns out to be a\nbranch . As soon as it’s decoded in DA (still in\ncycle 4), we stop feeding any new instn from\nFI into DA until we know where the  b…\n[p15:c26] 3.5.4. Registers & Initialization\nRegister  Width  Initial Content\nA n-bit 0…0\nQ n-bit Multiplier\nM n-bit Multiplicand\nQ-1 1 bit 0\nn - Number of bits in\nQ and M\nACC = [A (n bits) | Q (n bits) | Q -1(1 bit)]\nstarts as [0…0 | Q initial | 0]\n3.5.5. Step ‑by‑ Step Algorithm\n1.Initialize A = 0, Q = multiplier, Q₋ ₁  =  0,\ncount = n.\n2.Repeat until count…", "draft_gold_answer": "6.1. What Is Pipelining? ●Pipelining is a technique of overlappin g the execution of multiple instructions by dividing the processor’s datapath into stages, each handling a part of the instruction. ●It increases instruction throughputwithout reducing the execu…"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 5 key concepts covered.", "gold_answer": "so that maximum number of additions and subtractions are required. 3.5.3. Key Idea ➢Exam ine pairs of bits of the multiplier (current LSB and an extra “previous ” bit); decide whether to add, subtract, or do nothing with the multiplicand. ➢Shift right each cyc…", "gold_evidence": "[p13:c25] so that maximum number of\nadditions and subtractions are required.\n3.5.3. Key Idea\n➢Exam ine pairs of bits of the multiplier\n(current LSB and an extra “previous ”\nbit); decide whether to add, subtract, or\ndo nothing with the multiplicand.\n➢Shift right each cycle, accumulating thepartial product in a combined register.\nCOA\nGATE फर्रे\nPage No:-10\n[p13:c24] (signals directly driven).\n3.4.4.2. Vertical Microprogrammi ng\n●Control Word: Encoded fields (k -bits select 2ᵏ\nsignals).\n●Word Width: Narrower, but requiresdecoders.\n●Parallelism: Limited (typically one grou p\nexecuted per cycle).\n3.5. Booth’s Algorithm\n3.5.1. Goal:  Efficie ntly multiply two signed\nbinary integers (tw o’s-complement) with fewer a…\n[p20:c39] 1/cycle time\n2.Multiplication table for 2, n -bit unsign ed\nnumber = 22n * 2n bits\n3.Addition table for 2, n -bit unsign ed\nnumber = 22n * (n + 1) bits\n5.5. Locality Principles\n5.5.1. Temporal Locality: Recently\naccessed data likely to be reused soon.\n5.5.2. Spatial Locality: Data near recently accessed addresses likely to be accessed soon.\nNote: C…\n[p18:c37] -\nAddressable) Memory\n●Retrieves data by content rather than byspecific address\n●All words are compared simultaneous ly;\nmatching word(s) are returned.\n●Example: Translation Lookaside Buffer(TLB) in virtual memory.\n●Use Case: Fast lookups (e.g., cache tags,\nTLB), where search key determines th e\nfetch.\nCOA\nGATE फर्रे\nPage No:-14", "draft_gold_evidence": "[p13:c25] so that maximum number of\nadditions and subtractions are required.\n3.5.3. Key Idea\n➢Exam ine pairs of bits of the multiplier\n(current LSB and an extra “previous ”\nbit); decide whether to add, subtract, or\ndo nothing with the multiplicand.\n➢Shift right each cycle, accumulating thepartial product in a combined register.\nCOA\nGATE फर्रे\nPage No:-10\n[p13:c24] (signals directly driven).\n3.4.4.2. Vertical Microprogrammi ng\n●Control Word: Encoded fields (k -bits select 2ᵏ\nsignals).\n●Word Width: Narrower, but requiresdecoders.\n●Parallelism: Limited (typically one grou p\nexecuted per cycle).\n3.5. Booth’s Algorithm\n3.5.1. Goal:  Efficie ntly multiply two signed\nbinary integers (tw o’s-complement) with fewer a…\n[p20:c39] 1/cycle time\n2.Multiplication table for 2, n -bit unsign ed\nnumber = 22n * 2n bits\n3.Addition table for 2, n -bit unsign ed\nnumber = 22n * (n + 1) bits\n5.5. Locality Principles\n5.5.1. Temporal Locality: Recently\naccessed data likely to be reused soon.\n5.5.2. Spatial Locality: Data near recently accessed addresses likely to be accessed soon.\nNote: C…\n[p18:c37] -\nAddressable) Memory\n●Retrieves data by content rather than byspecific address\n●All words are compared simultaneous ly;\nmatching word(s) are returned.\n●Example: Translation Lookaside Buffer(TLB) in virtual memory.\n●Use Case: Fast lookups (e.g., cache tags,\nTLB), where search key determines th e\nfetch.\nCOA\nGATE फर्रे\nPage No:-14", "draft_gold_answer": "so that maximum number of additions and subtractions are required. 3.5.3. Key Idea ➢Exam ine pairs of bits of the multiplier (current LSB and an extra “previous ” bit); decide whether to add, subtract, or do nothing with the multiplicand. ➢Shift right each cyc…"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Define two important terms exactly as stated in the notes.", "gold_answer": "n among the registers and instructs the ALU as to which operation toperform. b.The function of the control unit in a digital computer is to initiate sequences of micro - operations. COA GATE फर्रे Page No:-08", "gold_evidence": "[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08\n[p5:c8] ormat is that it results in short programs when evaluating arithmetic expressions.\n2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One…\n[p11:c19] (double buses,more multiplexers).\n○Still limited: only one ALU operation per\ncycle.c.Three bus datapath\n●Structure:\n○Three dist inct internal buses (Bus A, Bu s\nB, Bus C).\n○Two source operands and one destinationcan be driven simultaneously.\n●Operation:\n○Enables two reads and one write toregisters in a single cycle.\n○E.g., read R ₁ → B us A, R ₁ →…\n[p13:c24] (signals directly driven).\n3.4.4.2. Vertical Microprogrammi ng\n●Control Word: Encoded fields (k -bits select 2ᵏ\nsignals).\n●Word Width: Narrower, but requiresdecoders.\n●Parallelism: Limited (typically one grou p\nexecuted per cycle).\n3.5. Booth’s Algorithm\n3.5.1. Goal:  Efficie ntly multiply two signed\nbinary integers (tw o’s-complement) with fewer a…", "draft_gold_evidence": "[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08\n[p5:c8] ormat is that it results in short programs when evaluating arithmetic expressions.\n2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One…\n[p11:c19] (double buses,more multiplexers).\n○Still limited: only one ALU operation per\ncycle.c.Three bus datapath\n●Structure:\n○Three dist inct internal buses (Bus A, Bu s\nB, Bus C).\n○Two source operands and one destinationcan be driven simultaneously.\n●Operation:\n○Enables two reads and one write toregisters in a single cycle.\n○E.g., read R ₁ → B us A, R ₁ →…\n[p13:c24] (signals directly driven).\n3.4.4.2. Vertical Microprogrammi ng\n●Control Word: Encoded fields (k -bits select 2ᵏ\nsignals).\n●Word Width: Narrower, but requiresdecoders.\n●Parallelism: Limited (typically one grou p\nexecuted per cycle).\n3.5. Booth’s Algorithm\n3.5.1. Goal:  Efficie ntly multiply two signed\nbinary integers (tw o’s-complement) with fewer a…", "draft_gold_answer": "n among the registers and instructs the ALU as to which operation toperform. b.The function of the control unit in a digital computer is to initiate sequences of micro - operations. COA GATE फर्रे Page No:-08"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Write one formula/equation mentioned in the notes (as written).", "gold_answer": "n among the registers and instructs the ALU as to which operation toperform. b.The function of the control unit in a digital computer is to initiate sequences of micro - operations. COA GATE फर्रे Page No:-08", "gold_evidence": "[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08\n[p11:c19] (double buses,more multiplexers).\n○Still limited: only one ALU operation per\ncycle.c.Three bus datapath\n●Structure:\n○Three dist inct internal buses (Bus A, Bu s\nB, Bus C).\n○Two source operands and one destinationcan be driven simultaneously.\n●Operation:\n○Enables two reads and one write toregisters in a single cycle.\n○E.g., read R ₁ → B us A, R ₁ →…\n[p5:c8] ormat is that it results in short programs when evaluating arithmetic expressions.\n2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One…\n[p25:c51] 6.6.2.3. Delayed load/No operation\nDelayed Load is a compiler technique that\navoids a pipeline s tall after a load instruction   by reordering subsequent instructions or\ninserting a “no- op” slot before using the\nloaded data.\n6.6.2.4. Data Hazard Classifications\nAssume 2 instn i & j ➢RAW (Read After Write)\ni: R1 ← R 2 + R 3\nj: R 5 ← R1 + R 4\nIf j r…", "draft_gold_evidence": "[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08\n[p11:c19] (double buses,more multiplexers).\n○Still limited: only one ALU operation per\ncycle.c.Three bus datapath\n●Structure:\n○Three dist inct internal buses (Bus A, Bu s\nB, Bus C).\n○Two source operands and one destinationcan be driven simultaneously.\n●Operation:\n○Enables two reads and one write toregisters in a single cycle.\n○E.g., read R ₁ → B us A, R ₁ →…\n[p5:c8] ormat is that it results in short programs when evaluating arithmetic expressions.\n2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One…\n[p25:c51] 6.6.2.3. Delayed load/No operation\nDelayed Load is a compiler technique that\navoids a pipeline s tall after a load instruction   by reordering subsequent instructions or\ninserting a “no- op” slot before using the\nloaded data.\n6.6.2.4. Data Hazard Classifications\nAssume 2 instn i & j ➢RAW (Read After Write)\ni: R1 ← R 2 + R 3\nj: R 5 ← R1 + R 4\nIf j r…", "draft_gold_answer": "n among the registers and instructs the ALU as to which operation toperform. b.The function of the control unit in a digital computer is to initiate sequences of micro - operations. COA GATE फर्रे Page No:-08"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List the steps of one algorithm/procedure described in the notes.", "gold_answer": "n among the registers and instructs the ALU as to which operation toperform. b.The function of the control unit in a digital computer is to initiate sequences of micro - operations. COA GATE फर्रे Page No:-08", "gold_evidence": "[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08\n[p7:c11] In this mode the effective address is equal to\nthe address part of the instruction. The\noperand resides in memory and its address is given directly by the address field of the\ninstruction. In a b ranch -type instruction the\naddress field specifies the actual branch\naddress.\n2.3.4. Indirect Address Mode\nIn this mode the address field of the\ninstruct…\n[p13:c24] (signals directly driven).\n3.4.4.2. Vertical Microprogrammi ng\n●Control Word: Encoded fields (k -bits select 2ᵏ\nsignals).\n●Word Width: Narrower, but requiresdecoders.\n●Parallelism: Limited (typically one grou p\nexecuted per cycle).\n3.5. Booth’s Algorithm\n3.5.1. Goal:  Efficie ntly multiply two signed\nbinary integers (tw o’s-complement) with fewer a…\n[p9:c15] ands\nin memory\nRISC (Reduced Instruction Set\nCompute r)\n●Relatively few instructions\n●Relatively few addressing modes\n●Memory access limited to load an d\nstore instructions\n●All operations done within th e\nregisters of the CPU\n●Fixed -length, easily decode d\ninstruction format\nCOA\nGATE फर्रे\nPage No:-06", "draft_gold_evidence": "[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08\n[p7:c11] In this mode the effective address is equal to\nthe address part of the instruction. The\noperand resides in memory and its address is given directly by the address field of the\ninstruction. In a b ranch -type instruction the\naddress field specifies the actual branch\naddress.\n2.3.4. Indirect Address Mode\nIn this mode the address field of the\ninstruct…\n[p13:c24] (signals directly driven).\n3.4.4.2. Vertical Microprogrammi ng\n●Control Word: Encoded fields (k -bits select 2ᵏ\nsignals).\n●Word Width: Narrower, but requiresdecoders.\n●Parallelism: Limited (typically one grou p\nexecuted per cycle).\n3.5. Booth’s Algorithm\n3.5.1. Goal:  Efficie ntly multiply two signed\nbinary integers (tw o’s-complement) with fewer a…\n[p9:c15] ands\nin memory\nRISC (Reduced Instruction Set\nCompute r)\n●Relatively few instructions\n●Relatively few addressing modes\n●Memory access limited to load an d\nstore instructions\n●All operations done within th e\nregisters of the CPU\n●Fixed -length, easily decode d\ninstruction format\nCOA\nGATE फर्रे\nPage No:-06", "draft_gold_answer": "n among the registers and instructs the ALU as to which operation toperform. b.The function of the control unit in a digital computer is to initiate sequences of micro - operations. COA GATE फर्रे Page No:-08"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Compare two related concepts/methods mentioned (give at least one difference).", "gold_answer": "etween internal storage and external I/O devices. There are 3 ways that computer buses canbe used to communicate with memory andI/O: 1.Use two separate buses, one for memory and the other for I/O. 2.Use one common bus for both memory and IO but have separat ec…", "gold_evidence": "[p27:c56] etween internal\nstorage and external I/O devices.\nThere are 3 ways that computer buses canbe used to communicate with memory andI/O:\n1.Use two separate buses, one for memory\nand the other for I/O.\n2.Use one common bus for both\nmemory and IO but have separat econtrol lines for each.\n3.Use one common bus for memory and I /O\nwith common cont rol lines…\n[p10:c17] are shown above connected to the internal processor bus via th e memory\ndata register  (MDR) and the memory\naddress register (MAR) respectively.\n3.2.1. Types of Datapath\na. One bus datapath\n●Structure: A single internal bus connects\nall registers, ALU inputs, and memory\ndata lines.\n●Operation:\n○Only one data transfer or ALU operation\ncan occur at a…\n[p5:c8] ormat is that it results in short programs when evaluating arithmetic expressions.\n2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One…\n[p7:c11] In this mode the effective address is equal to\nthe address part of the instruction. The\noperand resides in memory and its address is given directly by the address field of the\ninstruction. In a b ranch -type instruction the\naddress field specifies the actual branch\naddress.\n2.3.4. Indirect Address Mode\nIn this mode the address field of the\ninstruct…", "draft_gold_evidence": "[p27:c56] etween internal\nstorage and external I/O devices.\nThere are 3 ways that computer buses canbe used to communicate with memory andI/O:\n1.Use two separate buses, one for memory\nand the other for I/O.\n2.Use one common bus for both\nmemory and IO but have separat econtrol lines for each.\n3.Use one common bus for memory and I /O\nwith common cont rol lines…\n[p10:c17] are shown above connected to the internal processor bus via th e memory\ndata register  (MDR) and the memory\naddress register (MAR) respectively.\n3.2.1. Types of Datapath\na. One bus datapath\n●Structure: A single internal bus connects\nall registers, ALU inputs, and memory\ndata lines.\n●Operation:\n○Only one data transfer or ALU operation\ncan occur at a…\n[p5:c8] ormat is that it results in short programs when evaluating arithmetic expressions.\n2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One…\n[p7:c11] In this mode the effective address is equal to\nthe address part of the instruction. The\noperand resides in memory and its address is given directly by the address field of the\ninstruction. In a b ranch -type instruction the\naddress field specifies the actual branch\naddress.\n2.3.4. Indirect Address Mode\nIn this mode the address field of the\ninstruct…", "draft_gold_answer": "etween internal storage and external I/O devices. There are 3 ways that computer buses canbe used to communicate with memory andI/O: 1.Use two separate buses, one for memory and the other for I/O. 2.Use one common bus for both memory and IO but have separat ec…"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List any assumptions, prerequisites, or constraints mentioned.", "gold_answer": "are shown above connected to the internal processor bus via th e memory data register (MDR) and the memory address register (MAR) respectively. 3.2.1. Types of Datapath a. One bus datapath ●Structure: A single internal bus connects all registers, ALU inputs, a…", "gold_evidence": "[p10:c17] are shown above connected to the internal processor bus via th e memory\ndata register  (MDR) and the memory\naddress register (MAR) respectively.\n3.2.1. Types of Datapath\na. One bus datapath\n●Structure: A single internal bus connects\nall registers, ALU inputs, and memory\ndata lines.\n●Operation:\n○Only one data transfer or ALU operation\ncan occur at a…\n[p4:c5] forms the operation specified (e.g.,add, subtract, logical AND/OR, shift).\n●Address Calculation:  For me mory‐\nreference instructions, effective address\nis computed here.\nCOA\nGATE फर्रे\nPage No:-02\n[p15:c28] ntifies which memory block iscached.\n◆Index: Selects a cache set or line .\n◆Offset: Chooses the byte/word within\nthe cache line.\n➔Metadata:\n◆Valid Bit: Line contains valid data.\n◆Dirty Bit: Line has been written (forwrite-back).\nCOA\nGATE फर्रे\nPage No:-11\n[p16:c31] (k -input OR gate)\n4.4.3. Fully Associative Mapping\n➢ Number of comparators = Number of blocks i n\ncache\n➢ Size of comparator = Tag-bits\n➢ OR-gate = 1 (number of blocks -input OR gate)\nNote:  Hit Latency Time\n➢ Direct mapping = MUX delay + comparator delay\n➢ Set associative mapping = MUX delay  +\ncomparator delay + OR- gate delay\n➢ Fully ass ociati…", "draft_gold_evidence": "[p10:c17] are shown above connected to the internal processor bus via th e memory\ndata register  (MDR) and the memory\naddress register (MAR) respectively.\n3.2.1. Types of Datapath\na. One bus datapath\n●Structure: A single internal bus connects\nall registers, ALU inputs, and memory\ndata lines.\n●Operation:\n○Only one data transfer or ALU operation\ncan occur at a…\n[p4:c5] forms the operation specified (e.g.,add, subtract, logical AND/OR, shift).\n●Address Calculation:  For me mory‐\nreference instructions, effective address\nis computed here.\nCOA\nGATE फर्रे\nPage No:-02\n[p15:c28] ntifies which memory block iscached.\n◆Index: Selects a cache set or line .\n◆Offset: Chooses the byte/word within\nthe cache line.\n➔Metadata:\n◆Valid Bit: Line contains valid data.\n◆Dirty Bit: Line has been written (forwrite-back).\nCOA\nGATE फर्रे\nPage No:-11\n[p16:c31] (k -input OR gate)\n4.4.3. Fully Associative Mapping\n➢ Number of comparators = Number of blocks i n\ncache\n➢ Size of comparator = Tag-bits\n➢ OR-gate = 1 (number of blocks -input OR gate)\nNote:  Hit Latency Time\n➢ Direct mapping = MUX delay + comparator delay\n➢ Set associative mapping = MUX delay  +\ncomparator delay + OR- gate delay\n➢ Fully ass ociati…", "draft_gold_answer": "are shown above connected to the internal processor bus via th e memory data register (MDR) and the memory address register (MAR) respectively. 3.2.1. Types of Datapath a. One bus datapath ●Structure: A single internal bus connects all registers, ALU inputs, a…"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Give one example mentioned in the notes.", "gold_answer": "In this mode the effective address is equal to the address part of the instruction. The operand resides in memory and its address is given directly by the address field of the instruction. In a b ranch -type instruction the address field specifies the actual b…", "gold_evidence": "[p7:c11] In this mode the effective address is equal to\nthe address part of the instruction. The\noperand resides in memory and its address is given directly by the address field of the\ninstruction. In a b ranch -type instruction the\naddress field specifies the actual branch\naddress.\n2.3.4. Indirect Address Mode\nIn this mode the address field of the\ninstruct…\n[p5:c8] ormat is that it results in short programs when evaluating arithmetic expressions.\n2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One…\n[p7:c12] of 2\nk registers.\n2.3.6. Register Indirect Mode\nIn this mode the instruction specifies a\nregister in the CPU whose contents give the address of the operand in memory.\nThe advantage of a register indirect mode\ninstruction is that the address field of the\ninstruction uses fewer bits to select a register than a memory address directly.\n2.3.7. Autoincr…\n[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08", "draft_gold_evidence": "[p7:c11] In this mode the effective address is equal to\nthe address part of the instruction. The\noperand resides in memory and its address is given directly by the address field of the\ninstruction. In a b ranch -type instruction the\naddress field specifies the actual branch\naddress.\n2.3.4. Indirect Address Mode\nIn this mode the address field of the\ninstruct…\n[p5:c8] ormat is that it results in short programs when evaluating arithmetic expressions.\n2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One…\n[p7:c12] of 2\nk registers.\n2.3.6. Register Indirect Mode\nIn this mode the instruction specifies a\nregister in the CPU whose contents give the address of the operand in memory.\nThe advantage of a register indirect mode\ninstruction is that the address field of the\ninstruction uses fewer bits to select a register than a memory address directly.\n2.3.7. Autoincr…\n[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08", "draft_gold_answer": "In this mode the effective address is equal to the address part of the instruction. The operand resides in memory and its address is given directly by the address field of the instruction. In a b ranch -type instruction the address field specifies the actual b…"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What are the advantages and limitations of the main method/topic (as stated)?", "gold_answer": "n among the registers and instructs the ALU as to which operation toperform. b.The function of the control unit in a digital computer is to initiate sequences of micro - operations. COA GATE फर्रे Page No:-08", "gold_evidence": "[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08\n[p3:c2] e operation.\n03. Acc umulator\nTemporary storage location for arithmetic &logical operations\n04. MAR\nWorks with the memory bus to fetch/store\ndata at a specific address.\n05. MDRa.Temporarily holds data being transferred\nto/from memory. Contents of MBR are\ndirectly connected to the data bus.\nb. Acts as a buffer between CPU and\nmemory.\n1.2.2.  Memory…\n[p21:c41] ored\nby the CPU using a special flag orinstruction.\n●Used for lower -priority or non -critical\ntasks.\n●Eg. INTR in 8085, I/O completion.\n●Controlled By: Interrupt Enable/Disabl e\ninstructions (EI, DI)\n5.7.2.4. Non- Maskable Interrupts\n●Cannot be disabled by the CPU; always\ngets attention.\n●Used for critical events (e.g., powerfailure, hardware faul…\n[p3:c0] 1. Introduction to COA\n1.1. Types of computers\n●Embedded computers\n●Personal computers: desktop computers,workstation computers, portable\ncomputers etc.\n●Servers & Enterprise systems\n●Supercomputers\n1.2. Components of Computer\n1.2.1. CPU (Central Processing Unit)\n1.2.1.1. ALU (Arithmetic Logical Unit)\nALU performs the required micro-operations\nfor…", "draft_gold_evidence": "[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08\n[p3:c2] e operation.\n03. Acc umulator\nTemporary storage location for arithmetic &logical operations\n04. MAR\nWorks with the memory bus to fetch/store\ndata at a specific address.\n05. MDRa.Temporarily holds data being transferred\nto/from memory. Contents of MBR are\ndirectly connected to the data bus.\nb. Acts as a buffer between CPU and\nmemory.\n1.2.2.  Memory…\n[p21:c41] ored\nby the CPU using a special flag orinstruction.\n●Used for lower -priority or non -critical\ntasks.\n●Eg. INTR in 8085, I/O completion.\n●Controlled By: Interrupt Enable/Disabl e\ninstructions (EI, DI)\n5.7.2.4. Non- Maskable Interrupts\n●Cannot be disabled by the CPU; always\ngets attention.\n●Used for critical events (e.g., powerfailure, hardware faul…\n[p3:c0] 1. Introduction to COA\n1.1. Types of computers\n●Embedded computers\n●Personal computers: desktop computers,workstation computers, portable\ncomputers etc.\n●Servers & Enterprise systems\n●Supercomputers\n1.2. Components of Computer\n1.2.1. CPU (Central Processing Unit)\n1.2.1.1. ALU (Arithmetic Logical Unit)\nALU performs the required micro-operations\nfor…", "draft_gold_answer": "n among the registers and instructs the ALU as to which operation toperform. b.The function of the control unit in a digital computer is to initiate sequences of micro - operations. COA GATE फर्रे Page No:-08"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Summarize the key takeaways in 3 bullet points.", "gold_answer": "so that maximum number of additions and subtractions are required. 3.5.3. Key Idea ➢Exam ine pairs of bits of the multiplier (current LSB and an extra “previous ” bit); decide whether to add, subtract, or do nothing with the multiplicand. ➢Shift right each cyc…", "gold_evidence": "[p13:c25] so that maximum number of\nadditions and subtractions are required.\n3.5.3. Key Idea\n➢Exam ine pairs of bits of the multiplier\n(current LSB and an extra “previous ”\nbit); decide whether to add, subtract, or\ndo nothing with the multiplicand.\n➢Shift right each cycle, accumulating thepartial product in a combined register.\nCOA\nGATE फर्रे\nPage No:-10\n[p13:c24] (signals directly driven).\n3.4.4.2. Vertical Microprogrammi ng\n●Control Word: Encoded fields (k -bits select 2ᵏ\nsignals).\n●Word Width: Narrower, but requiresdecoders.\n●Parallelism: Limited (typically one grou p\nexecuted per cycle).\n3.5. Booth’s Algorithm\n3.5.1. Goal:  Efficie ntly multiply two signed\nbinary integers (tw o’s-complement) with fewer a…\n[p5:c8] ormat is that it results in short programs when evaluating arithmetic expressions.\n2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One…\n[p22:c45] essing is defin ed by the ratio, S =\n�×��\n(�+�−1)×��\n6.3.2.2. In ideal  conditions i.e. n>>>k, we\nignore (k -1), then S = ��\n��\n6.3.2.3. If we assume that the time it takes\nto process a task is the same in the pipeline\nand non- pipeline circuits , we will have t n =\nk*tp, then S = k\nIn this scenario, maximum speedup is\nachieved.\n6.4. Latency & Thro…", "draft_gold_evidence": "[p13:c25] so that maximum number of\nadditions and subtractions are required.\n3.5.3. Key Idea\n➢Exam ine pairs of bits of the multiplier\n(current LSB and an extra “previous ”\nbit); decide whether to add, subtract, or\ndo nothing with the multiplicand.\n➢Shift right each cycle, accumulating thepartial product in a combined register.\nCOA\nGATE फर्रे\nPage No:-10\n[p13:c24] (signals directly driven).\n3.4.4.2. Vertical Microprogrammi ng\n●Control Word: Encoded fields (k -bits select 2ᵏ\nsignals).\n●Word Width: Narrower, but requiresdecoders.\n●Parallelism: Limited (typically one grou p\nexecuted per cycle).\n3.5. Booth’s Algorithm\n3.5.1. Goal:  Efficie ntly multiply two signed\nbinary integers (tw o’s-complement) with fewer a…\n[p5:c8] ormat is that it results in short programs when evaluating arithmetic expressions.\n2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One…\n[p22:c45] essing is defin ed by the ratio, S =\n�×��\n(�+�−1)×��\n6.3.2.2. In ideal  conditions i.e. n>>>k, we\nignore (k -1), then S = ��\n��\n6.3.2.3. If we assume that the time it takes\nto process a task is the same in the pipeline\nand non- pipeline circuits , we will have t n =\nk*tp, then S = k\nIn this scenario, maximum speedup is\nachieved.\n6.4. Latency & Thro…", "draft_gold_answer": "so that maximum number of additions and subtractions are required. 3.5.3. Key Idea ➢Exam ine pairs of bits of the multiplier (current LSB and an extra “previous ” bit); decide whether to add, subtract, or do nothing with the multiplicand. ➢Shift right each cyc…"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Is there any deadline/submission instruction in the document? If not, answer 'Not found in the document.'", "gold_answer": "Solution of above figure: Introduce bubble/st all cycles which stalls the pipeline as in figure besides. At t4, I4 is not allowed to proceed, rather delayed. I t could have been allowed in t5, but again a clash with I2 RW. For the same reason, I4 is not allowe…", "gold_evidence": "[p24:c49] Solution of above figure:\nIntroduce bubble/st all cycles  which stalls the\npipeline as in figure besides.\nAt t4, I4 is not allowed to proceed, rather\ndelayed. I t could have been allowed in t5,\nbut again a clash with I2 RW. For the same reason, I4 is not allowed in t6 too. Finally, I4 could be allowed to proceed (stalled) in the pipe only at t7.  S…\n[p23:c47] stage pipeline:\n●Stage EX is finishing Instruction 1\n●Stage FO is loading the operand forInstruction 2\n●Stage DA is decoding Instruction 3\n●Stage FI is fetching Instruction 4\nNow suppose Instruction 3 turns out to be a\nbranch . As soon as it’s decoded in DA (still in\ncycle 4), we stop feeding any new instn from\nFI into DA until we know where the  b…\n[p24:c50] is produced or\nused by another instruction,creating a potential conflict in a pipeline.\nEg.\nIn the above case, ADD instruction writes\nthe result into the register R3 in t5. If stalls\nare not introduced to delay the next SUB instruction, all three instructions would be\nusing the wrong data from R3, which is\nearlier to ADD result. The program goes\nwr…\n[p7:c11] In this mode the effective address is equal to\nthe address part of the instruction. The\noperand resides in memory and its address is given directly by the address field of the\ninstruction. In a b ranch -type instruction the\naddress field specifies the actual branch\naddress.\n2.3.4. Indirect Address Mode\nIn this mode the address field of the\ninstruct…", "draft_gold_evidence": "[p24:c49] Solution of above figure:\nIntroduce bubble/st all cycles  which stalls the\npipeline as in figure besides.\nAt t4, I4 is not allowed to proceed, rather\ndelayed. I t could have been allowed in t5,\nbut again a clash with I2 RW. For the same reason, I4 is not allowed in t6 too. Finally, I4 could be allowed to proceed (stalled) in the pipe only at t7.  S…\n[p23:c47] stage pipeline:\n●Stage EX is finishing Instruction 1\n●Stage FO is loading the operand forInstruction 2\n●Stage DA is decoding Instruction 3\n●Stage FI is fetching Instruction 4\nNow suppose Instruction 3 turns out to be a\nbranch . As soon as it’s decoded in DA (still in\ncycle 4), we stop feeding any new instn from\nFI into DA until we know where the  b…\n[p24:c50] is produced or\nused by another instruction,creating a potential conflict in a pipeline.\nEg.\nIn the above case, ADD instruction writes\nthe result into the register R3 in t5. If stalls\nare not introduced to delay the next SUB instruction, all three instructions would be\nusing the wrong data from R3, which is\nearlier to ADD result. The program goes\nwr…\n[p7:c11] In this mode the effective address is equal to\nthe address part of the instruction. The\noperand resides in memory and its address is given directly by the address field of the\ninstruction. In a b ranch -type instruction the\naddress field specifies the actual branch\naddress.\n2.3.4. Indirect Address Mode\nIn this mode the address field of the\ninstruct…", "draft_gold_answer": "Solution of above figure: Introduce bubble/st all cycles which stalls the pipeline as in figure besides. At t4, I4 is not allowed to proceed, rather delayed. I t could have been allowed in t5, but again a clash with I2 RW. For the same reason, I4 is not allowe…"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one definition stated in the notes? Quote it exactly if present; otherwise answer 'Not found in the document.'", "gold_answer": "stage pipeline: ●Stage EX is finishing Instruction 1 ●Stage FO is loading the operand forInstruction 2 ●Stage DA is decoding Instruction 3 ●Stage FI is fetching Instruction 4 Now suppose Instruction 3 turns out to be a branch . As soon as it’s decoded in DA (s…", "gold_evidence": "[p23:c47] stage pipeline:\n●Stage EX is finishing Instruction 1\n●Stage FO is loading the operand forInstruction 2\n●Stage DA is decoding Instruction 3\n●Stage FI is fetching Instruction 4\nNow suppose Instruction 3 turns out to be a\nbranch . As soon as it’s decoded in DA (still in\ncycle 4), we stop feeding any new instn from\nFI into DA until we know where the  b…\n[p21:c42] 6.1. What Is Pipelining?\n●Pipelining is a technique of overlappin g\nthe execution of multiple instructions by\ndividing the processor’s datapath into\nstages, each handling a part of the\ninstruction.\n●It increases instruction throughputwithout reducing the execution time of\nindividual instructions.\nCOA\nGATE फर्रे\nPage No:-16\n[p24:c50] is produced or\nused by another instruction,creating a potential conflict in a pipeline.\nEg.\nIn the above case, ADD instruction writes\nthe result into the register R3 in t5. If stalls\nare not introduced to delay the next SUB instruction, all three instructions would be\nusing the wrong data from R3, which is\nearlier to ADD result. The program goes\nwr…\n[p5:c8] ormat is that it results in short programs when evaluating arithmetic expressions.\n2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One…", "draft_gold_evidence": "[p23:c47] stage pipeline:\n●Stage EX is finishing Instruction 1\n●Stage FO is loading the operand forInstruction 2\n●Stage DA is decoding Instruction 3\n●Stage FI is fetching Instruction 4\nNow suppose Instruction 3 turns out to be a\nbranch . As soon as it’s decoded in DA (still in\ncycle 4), we stop feeding any new instn from\nFI into DA until we know where the  b…\n[p21:c42] 6.1. What Is Pipelining?\n●Pipelining is a technique of overlappin g\nthe execution of multiple instructions by\ndividing the processor’s datapath into\nstages, each handling a part of the\ninstruction.\n●It increases instruction throughputwithout reducing the execution time of\nindividual instructions.\nCOA\nGATE फर्रे\nPage No:-16\n[p24:c50] is produced or\nused by another instruction,creating a potential conflict in a pipeline.\nEg.\nIn the above case, ADD instruction writes\nthe result into the register R3 in t5. If stalls\nare not introduced to delay the next SUB instruction, all three instructions would be\nusing the wrong data from R3, which is\nearlier to ADD result. The program goes\nwr…\n[p5:c8] ormat is that it results in short programs when evaluating arithmetic expressions.\n2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One…", "draft_gold_answer": "stage pipeline: ●Stage EX is finishing Instruction 1 ●Stage FO is loading the operand forInstruction 2 ●Stage DA is decoding Instruction 3 ●Stage FI is fetching Instruction 4 Now suppose Instruction 3 turns out to be a branch . As soon as it’s decoded in DA (s…"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the time complexity of one algorithm mentioned (as stated)? If not present, answer 'Not found in the document.'", "gold_answer": "n among the registers and instructs the ALU as to which operation toperform. b.The function of the control unit in a digital computer is to initiate sequences of micro - operations. COA GATE फर्रे Page No:-08", "gold_evidence": "[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08\n[p23:c47] stage pipeline:\n●Stage EX is finishing Instruction 1\n●Stage FO is loading the operand forInstruction 2\n●Stage DA is decoding Instruction 3\n●Stage FI is fetching Instruction 4\nNow suppose Instruction 3 turns out to be a\nbranch . As soon as it’s decoded in DA (still in\ncycle 4), we stop feeding any new instn from\nFI into DA until we know where the  b…\n[p21:c42] 6.1. What Is Pipelining?\n●Pipelining is a technique of overlappin g\nthe execution of multiple instructions by\ndividing the processor’s datapath into\nstages, each handling a part of the\ninstruction.\n●It increases instruction throughputwithout reducing the execution time of\nindividual instructions.\nCOA\nGATE फर्रे\nPage No:-16\n[p24:c49] Solution of above figure:\nIntroduce bubble/st all cycles  which stalls the\npipeline as in figure besides.\nAt t4, I4 is not allowed to proceed, rather\ndelayed. I t could have been allowed in t5,\nbut again a clash with I2 RW. For the same reason, I4 is not allowed in t6 too. Finally, I4 could be allowed to proceed (stalled) in the pipe only at t7.  S…", "draft_gold_evidence": "[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08\n[p23:c47] stage pipeline:\n●Stage EX is finishing Instruction 1\n●Stage FO is loading the operand forInstruction 2\n●Stage DA is decoding Instruction 3\n●Stage FI is fetching Instruction 4\nNow suppose Instruction 3 turns out to be a\nbranch . As soon as it’s decoded in DA (still in\ncycle 4), we stop feeding any new instn from\nFI into DA until we know where the  b…\n[p21:c42] 6.1. What Is Pipelining?\n●Pipelining is a technique of overlappin g\nthe execution of multiple instructions by\ndividing the processor’s datapath into\nstages, each handling a part of the\ninstruction.\n●It increases instruction throughputwithout reducing the execution time of\nindividual instructions.\nCOA\nGATE फर्रे\nPage No:-16\n[p24:c49] Solution of above figure:\nIntroduce bubble/st all cycles  which stalls the\npipeline as in figure besides.\nAt t4, I4 is not allowed to proceed, rather\ndelayed. I t could have been allowed in t5,\nbut again a clash with I2 RW. For the same reason, I4 is not allowed in t6 too. Finally, I4 could be allowed to proceed (stalled) in the pipe only at t7.  S…", "draft_gold_answer": "n among the registers and instructs the ALU as to which operation toperform. b.The function of the control unit in a digital computer is to initiate sequences of micro - operations. COA GATE फर्रे Page No:-08"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 3 important keywords/terms that appear in the notes.", "gold_answer": "so that maximum number of additions and subtractions are required. 3.5.3. Key Idea ➢Exam ine pairs of bits of the multiplier (current LSB and an extra “previous ” bit); decide whether to add, subtract, or do nothing with the multiplicand. ➢Shift right each cyc…", "gold_evidence": "[p13:c25] so that maximum number of\nadditions and subtractions are required.\n3.5.3. Key Idea\n➢Exam ine pairs of bits of the multiplier\n(current LSB and an extra “previous ”\nbit); decide whether to add, subtract, or\ndo nothing with the multiplicand.\n➢Shift right each cycle, accumulating thepartial product in a combined register.\nCOA\nGATE फर्रे\nPage No:-10\n[p5:c8] ormat is that it results in short programs when evaluating arithmetic expressions.\n2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One…\n[p22:c45] essing is defin ed by the ratio, S =\n�×��\n(�+�−1)×��\n6.3.2.2. In ideal  conditions i.e. n>>>k, we\nignore (k -1), then S = ��\n��\n6.3.2.3. If we assume that the time it takes\nto process a task is the same in the pipeline\nand non- pipeline circuits , we will have t n =\nk*tp, then S = k\nIn this scenario, maximum speedup is\nachieved.\n6.4. Latency & Thro…\n[p7:c11] In this mode the effective address is equal to\nthe address part of the instruction. The\noperand resides in memory and its address is given directly by the address field of the\ninstruction. In a b ranch -type instruction the\naddress field specifies the actual branch\naddress.\n2.3.4. Indirect Address Mode\nIn this mode the address field of the\ninstruct…", "draft_gold_evidence": "[p13:c25] so that maximum number of\nadditions and subtractions are required.\n3.5.3. Key Idea\n➢Exam ine pairs of bits of the multiplier\n(current LSB and an extra “previous ”\nbit); decide whether to add, subtract, or\ndo nothing with the multiplicand.\n➢Shift right each cycle, accumulating thepartial product in a combined register.\nCOA\nGATE फर्रे\nPage No:-10\n[p5:c8] ormat is that it results in short programs when evaluating arithmetic expressions.\n2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One…\n[p22:c45] essing is defin ed by the ratio, S =\n�×��\n(�+�−1)×��\n6.3.2.2. In ideal  conditions i.e. n>>>k, we\nignore (k -1), then S = ��\n��\n6.3.2.3. If we assume that the time it takes\nto process a task is the same in the pipeline\nand non- pipeline circuits , we will have t n =\nk*tp, then S = k\nIn this scenario, maximum speedup is\nachieved.\n6.4. Latency & Thro…\n[p7:c11] In this mode the effective address is equal to\nthe address part of the instruction. The\noperand resides in memory and its address is given directly by the address field of the\ninstruction. In a b ranch -type instruction the\naddress field specifies the actual branch\naddress.\n2.3.4. Indirect Address Mode\nIn this mode the address field of the\ninstruct…", "draft_gold_answer": "so that maximum number of additions and subtractions are required. 3.5.3. Key Idea ➢Exam ine pairs of bits of the multiplier (current LSB and an extra “previous ” bit); decide whether to add, subtract, or do nothing with the multiplicand. ➢Shift right each cyc…"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one theorem/lemma/property stated? If not present, answer 'Not found in the document.'", "gold_answer": "is produced or used by another instruction,creating a potential conflict in a pipeline. Eg. In the above case, ADD instruction writes the result into the register R3 in t5. If stalls are not introduced to delay the next SUB instruction, all three instructions…", "gold_evidence": "[p24:c50] is produced or\nused by another instruction,creating a potential conflict in a pipeline.\nEg.\nIn the above case, ADD instruction writes\nthe result into the register R3 in t5. If stalls\nare not introduced to delay the next SUB instruction, all three instructions would be\nusing the wrong data from R3, which is\nearlier to ADD result. The program goes\nwr…\n[p24:c49] Solution of above figure:\nIntroduce bubble/st all cycles  which stalls the\npipeline as in figure besides.\nAt t4, I4 is not allowed to proceed, rather\ndelayed. I t could have been allowed in t5,\nbut again a clash with I2 RW. For the same reason, I4 is not allowed in t6 too. Finally, I4 could be allowed to proceed (stalled) in the pipe only at t7.  S…\n[p23:c47] stage pipeline:\n●Stage EX is finishing Instruction 1\n●Stage FO is loading the operand forInstruction 2\n●Stage DA is decoding Instruction 3\n●Stage FI is fetching Instruction 4\nNow suppose Instruction 3 turns out to be a\nbranch . As soon as it’s decoded in DA (still in\ncycle 4), we stop feeding any new instn from\nFI into DA until we know where the  b…\n[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08", "draft_gold_evidence": "[p24:c50] is produced or\nused by another instruction,creating a potential conflict in a pipeline.\nEg.\nIn the above case, ADD instruction writes\nthe result into the register R3 in t5. If stalls\nare not introduced to delay the next SUB instruction, all three instructions would be\nusing the wrong data from R3, which is\nearlier to ADD result. The program goes\nwr…\n[p24:c49] Solution of above figure:\nIntroduce bubble/st all cycles  which stalls the\npipeline as in figure besides.\nAt t4, I4 is not allowed to proceed, rather\ndelayed. I t could have been allowed in t5,\nbut again a clash with I2 RW. For the same reason, I4 is not allowed in t6 too. Finally, I4 could be allowed to proceed (stalled) in the pipe only at t7.  S…\n[p23:c47] stage pipeline:\n●Stage EX is finishing Instruction 1\n●Stage FO is loading the operand forInstruction 2\n●Stage DA is decoding Instruction 3\n●Stage FI is fetching Instruction 4\nNow suppose Instruction 3 turns out to be a\nbranch . As soon as it’s decoded in DA (still in\ncycle 4), we stop feeding any new instn from\nFI into DA until we know where the  b…\n[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08", "draft_gold_answer": "is produced or used by another instruction,creating a potential conflict in a pipeline. Eg. In the above case, ADD instruction writes the result into the register R3 in t5. If stalls are not introduced to delay the next SUB instruction, all three instructions…"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Describe one table/list mentioned (what items are compared or listed). If none, answer 'Not found in the document.'", "gold_answer": "is produced or used by another instruction,creating a potential conflict in a pipeline. Eg. In the above case, ADD instruction writes the result into the register R3 in t5. If stalls are not introduced to delay the next SUB instruction, all three instructions…", "gold_evidence": "[p24:c50] is produced or\nused by another instruction,creating a potential conflict in a pipeline.\nEg.\nIn the above case, ADD instruction writes\nthe result into the register R3 in t5. If stalls\nare not introduced to delay the next SUB instruction, all three instructions would be\nusing the wrong data from R3, which is\nearlier to ADD result. The program goes\nwr…\n[p24:c49] Solution of above figure:\nIntroduce bubble/st all cycles  which stalls the\npipeline as in figure besides.\nAt t4, I4 is not allowed to proceed, rather\ndelayed. I t could have been allowed in t5,\nbut again a clash with I2 RW. For the same reason, I4 is not allowed in t6 too. Finally, I4 could be allowed to proceed (stalled) in the pipe only at t7.  S…\n[p5:c7] ons & Addressing\nModes2.1. Instructions Format\nA computer will usually have a variety of\ninstruction code formats. It is the function o f\nthe control unit within the CPU to interpre t\neach instruction code and provide the\nnecessary control functions needed t o\nprocess the instruction. The most common\nfields found in instruction formats are:1.An ope…\n[p13:c25] so that maximum number of\nadditions and subtractions are required.\n3.5.3. Key Idea\n➢Exam ine pairs of bits of the multiplier\n(current LSB and an extra “previous ”\nbit); decide whether to add, subtract, or\ndo nothing with the multiplicand.\n➢Shift right each cycle, accumulating thepartial product in a combined register.\nCOA\nGATE फर्रे\nPage No:-10", "draft_gold_evidence": "[p24:c50] is produced or\nused by another instruction,creating a potential conflict in a pipeline.\nEg.\nIn the above case, ADD instruction writes\nthe result into the register R3 in t5. If stalls\nare not introduced to delay the next SUB instruction, all three instructions would be\nusing the wrong data from R3, which is\nearlier to ADD result. The program goes\nwr…\n[p24:c49] Solution of above figure:\nIntroduce bubble/st all cycles  which stalls the\npipeline as in figure besides.\nAt t4, I4 is not allowed to proceed, rather\ndelayed. I t could have been allowed in t5,\nbut again a clash with I2 RW. For the same reason, I4 is not allowed in t6 too. Finally, I4 could be allowed to proceed (stalled) in the pipe only at t7.  S…\n[p5:c7] ons & Addressing\nModes2.1. Instructions Format\nA computer will usually have a variety of\ninstruction code formats. It is the function o f\nthe control unit within the CPU to interpre t\neach instruction code and provide the\nnecessary control functions needed t o\nprocess the instruction. The most common\nfields found in instruction formats are:1.An ope…\n[p13:c25] so that maximum number of\nadditions and subtractions are required.\n3.5.3. Key Idea\n➢Exam ine pairs of bits of the multiplier\n(current LSB and an extra “previous ”\nbit); decide whether to add, subtract, or\ndo nothing with the multiplicand.\n➢Shift right each cycle, accumulating thepartial product in a combined register.\nCOA\nGATE फर्रे\nPage No:-10", "draft_gold_answer": "is produced or used by another instruction,creating a potential conflict in a pipeline. Eg. In the above case, ADD instruction writes the result into the register R3 in t5. If stalls are not introduced to delay the next SUB instruction, all three instructions…"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one stated limitation/constraint? If none, answer 'Not found in the document.'", "gold_answer": "is produced or used by another instruction,creating a potential conflict in a pipeline. Eg. In the above case, ADD instruction writes the result into the register R3 in t5. If stalls are not introduced to delay the next SUB instruction, all three instructions…", "gold_evidence": "[p24:c50] is produced or\nused by another instruction,creating a potential conflict in a pipeline.\nEg.\nIn the above case, ADD instruction writes\nthe result into the register R3 in t5. If stalls\nare not introduced to delay the next SUB instruction, all three instructions would be\nusing the wrong data from R3, which is\nearlier to ADD result. The program goes\nwr…\n[p24:c49] Solution of above figure:\nIntroduce bubble/st all cycles  which stalls the\npipeline as in figure besides.\nAt t4, I4 is not allowed to proceed, rather\ndelayed. I t could have been allowed in t5,\nbut again a clash with I2 RW. For the same reason, I4 is not allowed in t6 too. Finally, I4 could be allowed to proceed (stalled) in the pipe only at t7.  S…\n[p23:c47] stage pipeline:\n●Stage EX is finishing Instruction 1\n●Stage FO is loading the operand forInstruction 2\n●Stage DA is decoding Instruction 3\n●Stage FI is fetching Instruction 4\nNow suppose Instruction 3 turns out to be a\nbranch . As soon as it’s decoded in DA (still in\ncycle 4), we stop feeding any new instn from\nFI into DA until we know where the  b…\n[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08", "draft_gold_evidence": "[p24:c50] is produced or\nused by another instruction,creating a potential conflict in a pipeline.\nEg.\nIn the above case, ADD instruction writes\nthe result into the register R3 in t5. If stalls\nare not introduced to delay the next SUB instruction, all three instructions would be\nusing the wrong data from R3, which is\nearlier to ADD result. The program goes\nwr…\n[p24:c49] Solution of above figure:\nIntroduce bubble/st all cycles  which stalls the\npipeline as in figure besides.\nAt t4, I4 is not allowed to proceed, rather\ndelayed. I t could have been allowed in t5,\nbut again a clash with I2 RW. For the same reason, I4 is not allowed in t6 too. Finally, I4 could be allowed to proceed (stalled) in the pipe only at t7.  S…\n[p23:c47] stage pipeline:\n●Stage EX is finishing Instruction 1\n●Stage FO is loading the operand forInstruction 2\n●Stage DA is decoding Instruction 3\n●Stage FI is fetching Instruction 4\nNow suppose Instruction 3 turns out to be a\nbranch . As soon as it’s decoded in DA (still in\ncycle 4), we stop feeding any new instn from\nFI into DA until we know where the  b…\n[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08", "draft_gold_answer": "is produced or used by another instruction,creating a potential conflict in a pipeline. Eg. In the above case, ADD instruction writes the result into the register R3 in t5. If stalls are not introduced to delay the next SUB instruction, all three instructions…"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one stated advantage/benefit? If none, answer 'Not found in the document.'", "gold_answer": "is produced or used by another instruction,creating a potential conflict in a pipeline. Eg. In the above case, ADD instruction writes the result into the register R3 in t5. If stalls are not introduced to delay the next SUB instruction, all three instructions…", "gold_evidence": "[p24:c50] is produced or\nused by another instruction,creating a potential conflict in a pipeline.\nEg.\nIn the above case, ADD instruction writes\nthe result into the register R3 in t5. If stalls\nare not introduced to delay the next SUB instruction, all three instructions would be\nusing the wrong data from R3, which is\nearlier to ADD result. The program goes\nwr…\n[p24:c49] Solution of above figure:\nIntroduce bubble/st all cycles  which stalls the\npipeline as in figure besides.\nAt t4, I4 is not allowed to proceed, rather\ndelayed. I t could have been allowed in t5,\nbut again a clash with I2 RW. For the same reason, I4 is not allowed in t6 too. Finally, I4 could be allowed to proceed (stalled) in the pipe only at t7.  S…\n[p23:c47] stage pipeline:\n●Stage EX is finishing Instruction 1\n●Stage FO is loading the operand forInstruction 2\n●Stage DA is decoding Instruction 3\n●Stage FI is fetching Instruction 4\nNow suppose Instruction 3 turns out to be a\nbranch . As soon as it’s decoded in DA (still in\ncycle 4), we stop feeding any new instn from\nFI into DA until we know where the  b…\n[p5:c7] ons & Addressing\nModes2.1. Instructions Format\nA computer will usually have a variety of\ninstruction code formats. It is the function o f\nthe control unit within the CPU to interpre t\neach instruction code and provide the\nnecessary control functions needed t o\nprocess the instruction. The most common\nfields found in instruction formats are:1.An ope…", "draft_gold_evidence": "[p24:c50] is produced or\nused by another instruction,creating a potential conflict in a pipeline.\nEg.\nIn the above case, ADD instruction writes\nthe result into the register R3 in t5. If stalls\nare not introduced to delay the next SUB instruction, all three instructions would be\nusing the wrong data from R3, which is\nearlier to ADD result. The program goes\nwr…\n[p24:c49] Solution of above figure:\nIntroduce bubble/st all cycles  which stalls the\npipeline as in figure besides.\nAt t4, I4 is not allowed to proceed, rather\ndelayed. I t could have been allowed in t5,\nbut again a clash with I2 RW. For the same reason, I4 is not allowed in t6 too. Finally, I4 could be allowed to proceed (stalled) in the pipe only at t7.  S…\n[p23:c47] stage pipeline:\n●Stage EX is finishing Instruction 1\n●Stage FO is loading the operand forInstruction 2\n●Stage DA is decoding Instruction 3\n●Stage FI is fetching Instruction 4\nNow suppose Instruction 3 turns out to be a\nbranch . As soon as it’s decoded in DA (still in\ncycle 4), we stop feeding any new instn from\nFI into DA until we know where the  b…\n[p5:c7] ons & Addressing\nModes2.1. Instructions Format\nA computer will usually have a variety of\ninstruction code formats. It is the function o f\nthe control unit within the CPU to interpre t\neach instruction code and provide the\nnecessary control functions needed t o\nprocess the instruction. The most common\nfields found in instruction formats are:1.An ope…", "draft_gold_answer": "is produced or used by another instruction,creating a potential conflict in a pipeline. Eg. In the above case, ADD instruction writes the result into the register R3 in t5. If stalls are not introduced to delay the next SUB instruction, all three instructions…"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Provide one short quote (1–2 sentences) from the notes that best represents the topic.", "gold_answer": "ormat is that it results in short programs when evaluating arithmetic expressions. 2.2.2. Two -Address Instructions Each address field can specify either a register or a word. The program to evaluate X = (A + B) * (C + D) is as follows Note: The MOV instructio…", "gold_evidence": "[p5:c8] ormat is that it results in short programs when evaluating arithmetic expressions.\n2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One…\n[p27:c56] etween internal\nstorage and external I/O devices.\nThere are 3 ways that computer buses canbe used to communicate with memory andI/O:\n1.Use two separate buses, one for memory\nand the other for I/O.\n2.Use one common bus for both\nmemory and IO but have separat econtrol lines for each.\n3.Use one common bus for memory and I /O\nwith common cont rol lines…\n[p5:c7] ons & Addressing\nModes2.1. Instructions Format\nA computer will usually have a variety of\ninstruction code formats. It is the function o f\nthe control unit within the CPU to interpre t\neach instruction code and provide the\nnecessary control functions needed t o\nprocess the instruction. The most common\nfields found in instruction formats are:1.An ope…\n[p24:c50] is produced or\nused by another instruction,creating a potential conflict in a pipeline.\nEg.\nIn the above case, ADD instruction writes\nthe result into the register R3 in t5. If stalls\nare not introduced to delay the next SUB instruction, all three instructions would be\nusing the wrong data from R3, which is\nearlier to ADD result. The program goes\nwr…", "draft_gold_evidence": "[p5:c8] ormat is that it results in short programs when evaluating arithmetic expressions.\n2.2.2. Two -Address Instructions\nEach address field can specify either a\nregister or a word. The program to evaluate X = (A + B) * (C + D) is as  follows\nNote: The MOV instruction moves or\ntransfers the operands to and from memory and processor registers.\n2.2.3. One…\n[p27:c56] etween internal\nstorage and external I/O devices.\nThere are 3 ways that computer buses canbe used to communicate with memory andI/O:\n1.Use two separate buses, one for memory\nand the other for I/O.\n2.Use one common bus for both\nmemory and IO but have separat econtrol lines for each.\n3.Use one common bus for memory and I /O\nwith common cont rol lines…\n[p5:c7] ons & Addressing\nModes2.1. Instructions Format\nA computer will usually have a variety of\ninstruction code formats. It is the function o f\nthe control unit within the CPU to interpre t\neach instruction code and provide the\nnecessary control functions needed t o\nprocess the instruction. The most common\nfields found in instruction formats are:1.An ope…\n[p24:c50] is produced or\nused by another instruction,creating a potential conflict in a pipeline.\nEg.\nIn the above case, ADD instruction writes\nthe result into the register R3 in t5. If stalls\nare not introduced to delay the next SUB instruction, all three instructions would be\nusing the wrong data from R3, which is\nearlier to ADD result. The program goes\nwr…", "draft_gold_answer": "ormat is that it results in short programs when evaluating arithmetic expressions. 2.2.2. Two -Address Instructions Each address field can specify either a register or a word. The program to evaluate X = (A + B) * (C + D) is as follows Note: The MOV instructio…"}
{"doc_id": "bde5d48fb69b6e4b", "pdf_path": "eval/pdfs/public/COA-SHORT-NOTES-_compressed_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one abbreviation/acronym expanded in the notes? If none, answer 'Not found in the document.'", "gold_answer": "is produced or used by another instruction,creating a potential conflict in a pipeline. Eg. In the above case, ADD instruction writes the result into the register R3 in t5. If stalls are not introduced to delay the next SUB instruction, all three instructions…", "gold_evidence": "[p24:c50] is produced or\nused by another instruction,creating a potential conflict in a pipeline.\nEg.\nIn the above case, ADD instruction writes\nthe result into the register R3 in t5. If stalls\nare not introduced to delay the next SUB instruction, all three instructions would be\nusing the wrong data from R3, which is\nearlier to ADD result. The program goes\nwr…\n[p24:c49] Solution of above figure:\nIntroduce bubble/st all cycles  which stalls the\npipeline as in figure besides.\nAt t4, I4 is not allowed to proceed, rather\ndelayed. I t could have been allowed in t5,\nbut again a clash with I2 RW. For the same reason, I4 is not allowed in t6 too. Finally, I4 could be allowed to proceed (stalled) in the pipe only at t7.  S…\n[p23:c47] stage pipeline:\n●Stage EX is finishing Instruction 1\n●Stage FO is loading the operand forInstruction 2\n●Stage DA is decoding Instruction 3\n●Stage FI is fetching Instruction 4\nNow suppose Instruction 3 turns out to be a\nbranch . As soon as it’s decoded in DA (still in\ncycle 4), we stop feeding any new instn from\nFI into DA until we know where the  b…\n[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08", "draft_gold_evidence": "[p24:c50] is produced or\nused by another instruction,creating a potential conflict in a pipeline.\nEg.\nIn the above case, ADD instruction writes\nthe result into the register R3 in t5. If stalls\nare not introduced to delay the next SUB instruction, all three instructions would be\nusing the wrong data from R3, which is\nearlier to ADD result. The program goes\nwr…\n[p24:c49] Solution of above figure:\nIntroduce bubble/st all cycles  which stalls the\npipeline as in figure besides.\nAt t4, I4 is not allowed to proceed, rather\ndelayed. I t could have been allowed in t5,\nbut again a clash with I2 RW. For the same reason, I4 is not allowed in t6 too. Finally, I4 could be allowed to proceed (stalled) in the pipe only at t7.  S…\n[p23:c47] stage pipeline:\n●Stage EX is finishing Instruction 1\n●Stage FO is loading the operand forInstruction 2\n●Stage DA is decoding Instruction 3\n●Stage FI is fetching Instruction 4\nNow suppose Instruction 3 turns out to be a\nbranch . As soon as it’s decoded in DA (still in\ncycle 4), we stop feeding any new instn from\nFI into DA until we know where the  b…\n[p11:c20] n among the registers  and\ninstructs the ALU as to which operation toperform.\nb.The function of the control unit in a digital\ncomputer  is to initiate sequences  of micro -\noperations.\nCOA\nGATE फर्रे\nPage No:-08", "draft_gold_answer": "is produced or used by another instruction,creating a potential conflict in a pipeline. Eg. In the above case, ADD instruction writes the result into the register R3 in t5. If stalls are not introduced to delay the next SUB instruction, all three instructions…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the main topic of these notes?", "gold_answer": "r. ●Directly interacts with the user andapplications.Main Functions : ●Provides network services to users (e.g. , email, file transfer, web browsing). ●Supports applications like Mail services, Fil e sharing, etc. ●Gives access to network- based apps (e.g. , b…", "gold_evidence": "[p37:c67] r.\n●Directly interacts with the user andapplications.Main Functions :\n●Provides network services to users (e.g. ,\nemail, file transfer, web browsing).\n●Supports applications like Mail services, Fil e\nsharing, etc.\n●Gives access to network- based apps (e.g. ,\nbrowser,  FTP client).\n●Represents what the user sees or uses.\nExamples of Services :\n●Emai…\n[p24:c39] ●It is a 2B field which specifies the length of\ndata field.\nData:\n●It is a variable- length field which contains t he\nactual data.\n●It is also called the payload field .\n●Range of size = (46B – 1500B).\nFrame Check Sequence (CRC) :\n●It is a 4B field that contains the CRC code fo r\nerror detection.\nCOMPUETR NETWORK\nGATE फर्रे\nPage No:- 21\n[p22:c36] ulnerable time in\nwhich collision may\noccur = 2∗ Tf(Tf−\nTransmission time for\nsingle frame ) Vulnerable time in which collision may\noccur = T\nf\nThroughput of pure\naloha =G∗e−2G Throughput of slotted\nAloha =G∗e−G\nMaximum throughput\nsmax =18.4% (When\nG = 1/2) Maximum throughput\nsmax =36.8% (When\nG = 1  )\nThe main advantage of pure aloha is it simplic…\n[p17:c27] 4. RST (Rese t):\nUsed to abruptly terminate a connection, often i n\nrespo nse to some error or invalid segment.\n5. SYN (Synchronize):\nUsed to initiate a connection during the TCP 3- way\nhandshake. It signals the beginning of a TCP\nconversation.\n6.FIN (Finish):\nUsed to terminate a TCP connection gracefully.\n➡ When a sender sets FIN, it indicates tha…", "draft_gold_evidence": "[p37:c67] r.\n●Directly interacts with the user andapplications.Main Functions :\n●Provides network services to users (e.g. ,\nemail, file transfer, web browsing).\n●Supports applications like Mail services, Fil e\nsharing, etc.\n●Gives access to network- based apps (e.g. ,\nbrowser,  FTP client).\n●Represents what the user sees or uses.\nExamples of Services :\n●Emai…\n[p24:c39] ●It is a 2B field which specifies the length of\ndata field.\nData:\n●It is a variable- length field which contains t he\nactual data.\n●It is also called the payload field .\n●Range of size = (46B – 1500B).\nFrame Check Sequence (CRC) :\n●It is a 4B field that contains the CRC code fo r\nerror detection.\nCOMPUETR NETWORK\nGATE फर्रे\nPage No:- 21\n[p22:c36] ulnerable time in\nwhich collision may\noccur = 2∗ Tf(Tf−\nTransmission time for\nsingle frame ) Vulnerable time in which collision may\noccur = T\nf\nThroughput of pure\naloha =G∗e−2G Throughput of slotted\nAloha =G∗e−G\nMaximum throughput\nsmax =18.4% (When\nG = 1/2) Maximum throughput\nsmax =36.8% (When\nG = 1  )\nThe main advantage of pure aloha is it simplic…\n[p17:c27] 4. RST (Rese t):\nUsed to abruptly terminate a connection, often i n\nrespo nse to some error or invalid segment.\n5. SYN (Synchronize):\nUsed to initiate a connection during the TCP 3- way\nhandshake. It signals the beginning of a TCP\nconversation.\n6.FIN (Finish):\nUsed to terminate a TCP connection gracefully.\n➡ When a sender sets FIN, it indicates tha…", "draft_gold_answer": "r. ●Directly interacts with the user andapplications.Main Functions : ●Provides network services to users (e.g. , email, file transfer, web browsing). ●Supports applications like Mail services, Fil e sharing, etc. ●Gives access to network- based apps (e.g. , b…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 5 key concepts covered.", "gold_answer": "a client -server protocol, and works o n port number 80 using TCP.3.HTTP is an In -Band protocol – both request and data are sent in the same connection. 4.HTTP is a stateless protocol, which means itdoes not remember anything about the user or past requests.…", "gold_evidence": "[p27:c47] a client -server protocol, and works o n\nport number 80 using TCP.3.HTTP is an In -Band protocol – both request\nand data are sent in the same connection.\n4.HTTP is a stateless protocol, which means itdoes not remember anything about the  user\nor past requests.\n5.There are 2 types of HTTP connections:\n○(i) Non -persistent (1.0)\n○(ii) Persistent (1.1…\n[p30:c56] ontrol share the same connection).POP3 VS IMAP4 -Key Differences\n🔸🔸 POP3 🔹🔹 IMAP 4\nMails can only be\naccessed from one\ndevice.  Mails can be accessed\nfrom multiple devices.\nEmails are downloaded\nand deleted from the\nserver.  Emails stay on the server\nand sync across devices.\nUsers cannot organize\nmails on the server.  Users can organize mails\nin fo…\n[p30:c55] Limitations:\n●Cannot preview mail before downloading –\nfull mail must be downloaded first.\n●Cannot organize emails on the mail server –no folder structure support.\nIMAP4 (Internet Mail Ac cess Protocol v4)\n1.IMAP4 is similar to POP3, but it has mo re\nfeatures, is more powerful, and a bit\ncomplex.\n2.It allows users to:\n○Check the email header befo r…\n[p27:c48] n doesn’t stay open.\nPersistent  (1.1)\nIn Persistent HTTP, the TCP connection is kept open for multiple requests.\nKey Points:\n1.The server keeps the connection ope n even\nafter sending the response.\n2.The connection is closed only when:\n○Client asks to close it, or\n○A timeout occurs.\nThis makes it faster and more efficient than non-persistent.\nCOMP…", "draft_gold_evidence": "[p27:c47] a client -server protocol, and works o n\nport number 80 using TCP.3.HTTP is an In -Band protocol – both request\nand data are sent in the same connection.\n4.HTTP is a stateless protocol, which means itdoes not remember anything about the  user\nor past requests.\n5.There are 2 types of HTTP connections:\n○(i) Non -persistent (1.0)\n○(ii) Persistent (1.1…\n[p30:c56] ontrol share the same connection).POP3 VS IMAP4 -Key Differences\n🔸🔸 POP3 🔹🔹 IMAP 4\nMails can only be\naccessed from one\ndevice.  Mails can be accessed\nfrom multiple devices.\nEmails are downloaded\nand deleted from the\nserver.  Emails stay on the server\nand sync across devices.\nUsers cannot organize\nmails on the server.  Users can organize mails\nin fo…\n[p30:c55] Limitations:\n●Cannot preview mail before downloading –\nfull mail must be downloaded first.\n●Cannot organize emails on the mail server –no folder structure support.\nIMAP4 (Internet Mail Ac cess Protocol v4)\n1.IMAP4 is similar to POP3, but it has mo re\nfeatures, is more powerful, and a bit\ncomplex.\n2.It allows users to:\n○Check the email header befo r…\n[p27:c48] n doesn’t stay open.\nPersistent  (1.1)\nIn Persistent HTTP, the TCP connection is kept open for multiple requests.\nKey Points:\n1.The server keeps the connection ope n even\nafter sending the response.\n2.The connection is closed only when:\n○Client asks to close it, or\n○A timeout occurs.\nThis makes it faster and more efficient than non-persistent.\nCOMP…", "draft_gold_answer": "a client -server protocol, and works o n port number 80 using TCP.3.HTTP is an In -Band protocol – both request and data are sent in the same connection. 4.HTTP is a stateless protocol, which means itdoes not remember anything about the user or past requests.…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Define two important terms exactly as stated in the notes.", "gold_answer": "verload i n the network. ●Connection Control – Supports bot h connection-oriented (TCP) and connectionless (UDP) communication. ●Multiplexing & Demultiplexing – Allows multiple applications to use the network atthe same time. Session Layer ●Layer 5 of OSI mode…", "gold_evidence": "[p36:c65] verload i n\nthe network.\n●Connection Control – Supports bot h\nconnection-oriented (TCP) and\nconnectionless (UDP) communication.\n●Multiplexing & Demultiplexing – Allows\nmultiple applications to use the network atthe same time.\nSession Layer\n●Layer 5 of OSI model.\n●Acts as a network dialog controller.\n●Starts, manages, and ends communicatio n\nsession…\n[p26:c44] ered as Destinatio n\nunrea chable.\n2.RIP uses UDP as its transport protocol with t he\nport number – 530\nIP Support Protocols\n1. ARP ( Address Resolution Protocol )\nFinds MAC address using an IP address.\nUsed when a  device knows the IP but needs t he\nphysi cal address to send data.\n2. ICMP Messages (Internet Control Messag e\nProtocol)\nICMP messages…\n[p5:c6] g distance between two strings ofequal length is the number of positions at\nwhich the corresponding symbols (0 or 1) a re\ndifferent.\n●Denoted by d(x, y).\nExamples:\n1.d(000, 101) = 2 hamming distance\n2.d(100, 011) = 3 hamming distance\n3.d(101, 110) = 2 hamming distance\n●Hamming distance can be found by applyingXOR operation ( ⊕) on  two codewords an…\n[p14:c22] → 06\nICMP>IGMP>UDP>TCP\nHeader Checksum (16 bits)\n●Calculated for header only.\n●Computed at each router  as headers ma y\nchange (e.g., TTL).\nSource Address (32 bits)\n●IPv4 address of sender.\nDestination Address (32 bits)\n●IPv4 address of receiver.\nOptions (0– 40 bytes)\nThe IPv4 datagram header consists of two parts :\n●A fixed part , which is always…", "draft_gold_evidence": "[p36:c65] verload i n\nthe network.\n●Connection Control – Supports bot h\nconnection-oriented (TCP) and\nconnectionless (UDP) communication.\n●Multiplexing & Demultiplexing – Allows\nmultiple applications to use the network atthe same time.\nSession Layer\n●Layer 5 of OSI model.\n●Acts as a network dialog controller.\n●Starts, manages, and ends communicatio n\nsession…\n[p26:c44] ered as Destinatio n\nunrea chable.\n2.RIP uses UDP as its transport protocol with t he\nport number – 530\nIP Support Protocols\n1. ARP ( Address Resolution Protocol )\nFinds MAC address using an IP address.\nUsed when a  device knows the IP but needs t he\nphysi cal address to send data.\n2. ICMP Messages (Internet Control Messag e\nProtocol)\nICMP messages…\n[p5:c6] g distance between two strings ofequal length is the number of positions at\nwhich the corresponding symbols (0 or 1) a re\ndifferent.\n●Denoted by d(x, y).\nExamples:\n1.d(000, 101) = 2 hamming distance\n2.d(100, 011) = 3 hamming distance\n3.d(101, 110) = 2 hamming distance\n●Hamming distance can be found by applyingXOR operation ( ⊕) on  two codewords an…\n[p14:c22] → 06\nICMP>IGMP>UDP>TCP\nHeader Checksum (16 bits)\n●Calculated for header only.\n●Computed at each router  as headers ma y\nchange (e.g., TTL).\nSource Address (32 bits)\n●IPv4 address of sender.\nDestination Address (32 bits)\n●IPv4 address of receiver.\nOptions (0– 40 bytes)\nThe IPv4 datagram header consists of two parts :\n●A fixed part , which is always…", "draft_gold_answer": "verload i n the network. ●Connection Control – Supports bot h connection-oriented (TCP) and connectionless (UDP) communication. ●Multiplexing & Demultiplexing – Allows multiple applications to use the network atthe same time. Session Layer ●Layer 5 of OSI mode…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Write one formula/equation mentioned in the notes (as written).", "gold_answer": "OSI AND TCP/IP PROTOCOLS STACK OSI Model 1.OSI stands for Open Systems Interconnection. 2.It was developed by ISO in 1984. 3.It is a standard model to divide a communication system into 7 layers. 4.Each layer has similar types of functions andcommunicates with…", "gold_evidence": "[p35:c61] OSI AND TCP/IP PROTOCOLS STACK\nOSI Model\n1.OSI stands for Open Systems\nInterconnection.\n2.It was developed by ISO in 1984.\n3.It is a standard model to divide a\ncommunication system into 7 layers.\n4.Each layer has similar types of functions andcommunicates with the layer above andbelow it.\n5.OSI model is mainly used as a reference fordesigning proto…\n[p2:c1] .y.z → Self loop address\n6. 255.255.255.255 → Limited broadcast\naddress.\nTypes of Communication:\ni) Unicast (1 to 1) →  one computer to anot her\ncomputer\nii)Broadcast (1 to all)\niii)Multicast (1 to many) → one computer to ma ny\ncomputers\nBroadcast Communication:\n●Limited Broadcast  → Transmitting data 1 to\nall in same n/w\n●Directed Broadcast  → Tra…\n[p36:c65] verload i n\nthe network.\n●Connection Control – Supports bot h\nconnection-oriented (TCP) and\nconnectionless (UDP) communication.\n●Multiplexing & Demultiplexing – Allows\nmultiple applications to use the network atthe same time.\nSession Layer\n●Layer 5 of OSI model.\n●Acts as a network dialog controller.\n●Starts, manages, and ends communicatio n\nsession…\n[p35:c62] ike voltage, data speed,\ndistance, and connection type.Data Link Layer\n●Works at Layer 2 of OSI model.\n●Transfers frames from one node (hop) to thenext.\n●Converts:\n○Bits ↔ Packets (Frames)\n●Uses Layer 1 (Physical Layer) to send bitstream.\nMain Functions:\n●Framing – Breaks bit stream into frames.\n●Error Control – Detects and handles errors in\ntransm…", "draft_gold_evidence": "[p35:c61] OSI AND TCP/IP PROTOCOLS STACK\nOSI Model\n1.OSI stands for Open Systems\nInterconnection.\n2.It was developed by ISO in 1984.\n3.It is a standard model to divide a\ncommunication system into 7 layers.\n4.Each layer has similar types of functions andcommunicates with the layer above andbelow it.\n5.OSI model is mainly used as a reference fordesigning proto…\n[p2:c1] .y.z → Self loop address\n6. 255.255.255.255 → Limited broadcast\naddress.\nTypes of Communication:\ni) Unicast (1 to 1) →  one computer to anot her\ncomputer\nii)Broadcast (1 to all)\niii)Multicast (1 to many) → one computer to ma ny\ncomputers\nBroadcast Communication:\n●Limited Broadcast  → Transmitting data 1 to\nall in same n/w\n●Directed Broadcast  → Tra…\n[p36:c65] verload i n\nthe network.\n●Connection Control – Supports bot h\nconnection-oriented (TCP) and\nconnectionless (UDP) communication.\n●Multiplexing & Demultiplexing – Allows\nmultiple applications to use the network atthe same time.\nSession Layer\n●Layer 5 of OSI model.\n●Acts as a network dialog controller.\n●Starts, manages, and ends communicatio n\nsession…\n[p35:c62] ike voltage, data speed,\ndistance, and connection type.Data Link Layer\n●Works at Layer 2 of OSI model.\n●Transfers frames from one node (hop) to thenext.\n●Converts:\n○Bits ↔ Packets (Frames)\n●Uses Layer 1 (Physical Layer) to send bitstream.\nMain Functions:\n●Framing – Breaks bit stream into frames.\n●Error Control – Detects and handles errors in\ntransm…", "draft_gold_answer": "OSI AND TCP/IP PROTOCOLS STACK OSI Model 1.OSI stands for Open Systems Interconnection. 2.It was developed by ISO in 1984. 3.It is a standard model to divide a communication system into 7 layers. 4.Each layer has similar types of functions andcommunicates with…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List the steps of one algorithm/procedure described in the notes.", "gold_answer": "ike voltage, data speed, distance, and connection type.Data Link Layer ●Works at Layer 2 of OSI model. ●Transfers frames from one node (hop) to thenext. ●Converts: ○Bits ↔ Packets (Frames) ●Uses Layer 1 (Physical Layer) to send bitstream. Main Functions: ●Fram…", "gold_evidence": "[p35:c62] ike voltage, data speed,\ndistance, and connection type.Data Link Layer\n●Works at Layer 2 of OSI model.\n●Transfers frames from one node (hop) to thenext.\n●Converts:\n○Bits ↔ Packets (Frames)\n●Uses Layer 1 (Physical Layer) to send bitstream.\nMain Functions:\n●Framing – Breaks bit stream into frames.\n●Error Control – Detects and handles errors in\ntransm…\n[p16:c24] TCP & UDP\nSource Port (16 bits)  Destination Port\n(16 bits)\nSequence number (32 bits)\nAcknowledgement number (32 bits)\nHeader\nLength\n(4 bits)  Reserved\nbits (6 bits) U\nR\nB A\nC K P\nS H R\nS T S\nY N F\nI N Window Size\n(Advertisement Window) (16 bits)\nCheck sum (16 bits)\nOptions (0 -40 bytes)\nHeader length: (4 bits)\n●Header length is a 4- bit field that…\n[p3:c2] Special Cases:\nNID HID\nvalid  all 0’s → N/w\nid of entire\nn/w\nvalid   All 1’s →\nDirected\nbroadcast\naddress (DBA)\nAll 1’s  all 1’s →\nLimited broadcast address (LBA)\n7.Subnetting : Subnetting is borrowing bit s\nfrom HID.\nSubnet mask : It helps to identify which portion of IP\nis network ID and which portion is host ID.\n●No. of 1’s = (NID + Subnet ID)\n●…\n[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…", "draft_gold_evidence": "[p35:c62] ike voltage, data speed,\ndistance, and connection type.Data Link Layer\n●Works at Layer 2 of OSI model.\n●Transfers frames from one node (hop) to thenext.\n●Converts:\n○Bits ↔ Packets (Frames)\n●Uses Layer 1 (Physical Layer) to send bitstream.\nMain Functions:\n●Framing – Breaks bit stream into frames.\n●Error Control – Detects and handles errors in\ntransm…\n[p16:c24] TCP & UDP\nSource Port (16 bits)  Destination Port\n(16 bits)\nSequence number (32 bits)\nAcknowledgement number (32 bits)\nHeader\nLength\n(4 bits)  Reserved\nbits (6 bits) U\nR\nB A\nC K P\nS H R\nS T S\nY N F\nI N Window Size\n(Advertisement Window) (16 bits)\nCheck sum (16 bits)\nOptions (0 -40 bytes)\nHeader length: (4 bits)\n●Header length is a 4- bit field that…\n[p3:c2] Special Cases:\nNID HID\nvalid  all 0’s → N/w\nid of entire\nn/w\nvalid   All 1’s →\nDirected\nbroadcast\naddress (DBA)\nAll 1’s  all 1’s →\nLimited broadcast address (LBA)\n7.Subnetting : Subnetting is borrowing bit s\nfrom HID.\nSubnet mask : It helps to identify which portion of IP\nis network ID and which portion is host ID.\n●No. of 1’s = (NID + Subnet ID)\n●…\n[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…", "draft_gold_answer": "ike voltage, data speed, distance, and connection type.Data Link Layer ●Works at Layer 2 of OSI model. ●Transfers frames from one node (hop) to thenext. ●Converts: ○Bits ↔ Packets (Frames) ●Uses Layer 1 (Physical Layer) to send bitstream. Main Functions: ●Fram…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Compare two related concepts/methods mentioned (give at least one difference).", "gold_answer": "Error Control ●Number of corrupted bits = Data rate × Noise duration ●Burst error is more likely to occur than singl e bit error. ●Error correction is more difficult than erro r detection. Error Control: ●Error Detection: If error found, discard and ask for re…", "gold_evidence": "[p5:c5] Error Control\n●Number of corrupted bits = Data rate ×\nNoise duration\n●Burst error is more likely to occur than singl e\nbit error.\n●Error correction is more difficult than erro r\ndetection.\nError Control:\n●Error Detection:  If error found, discard and\nask for retransmission.\n●Error Correction: If can correct error ,\nretransmission not required.\nMeth…\n[p5:c6] g distance between two strings ofequal length is the number of positions at\nwhich the corresponding symbols (0 or 1) a re\ndifferent.\n●Denoted by d(x, y).\nExamples:\n1.d(000, 101) = 2 hamming distance\n2.d(100, 011) = 3 hamming distance\n3.d(101, 110) = 2 hamming distance\n●Hamming distance can be found by applyingXOR operation ( ⊕) on  two codewords an…\n[p14:c22] → 06\nICMP>IGMP>UDP>TCP\nHeader Checksum (16 bits)\n●Calculated for header only.\n●Computed at each router  as headers ma y\nchange (e.g., TTL).\nSource Address (32 bits)\n●IPv4 address of sender.\nDestination Address (32 bits)\n●IPv4 address of receiver.\nOptions (0– 40 bytes)\nThe IPv4 datagram header consists of two parts :\n●A fixed part , which is always…\n[p35:c62] ike voltage, data speed,\ndistance, and connection type.Data Link Layer\n●Works at Layer 2 of OSI model.\n●Transfers frames from one node (hop) to thenext.\n●Converts:\n○Bits ↔ Packets (Frames)\n●Uses Layer 1 (Physical Layer) to send bitstream.\nMain Functions:\n●Framing – Breaks bit stream into frames.\n●Error Control – Detects and handles errors in\ntransm…", "draft_gold_evidence": "[p5:c5] Error Control\n●Number of corrupted bits = Data rate ×\nNoise duration\n●Burst error is more likely to occur than singl e\nbit error.\n●Error correction is more difficult than erro r\ndetection.\nError Control:\n●Error Detection:  If error found, discard and\nask for retransmission.\n●Error Correction: If can correct error ,\nretransmission not required.\nMeth…\n[p5:c6] g distance between two strings ofequal length is the number of positions at\nwhich the corresponding symbols (0 or 1) a re\ndifferent.\n●Denoted by d(x, y).\nExamples:\n1.d(000, 101) = 2 hamming distance\n2.d(100, 011) = 3 hamming distance\n3.d(101, 110) = 2 hamming distance\n●Hamming distance can be found by applyingXOR operation ( ⊕) on  two codewords an…\n[p14:c22] → 06\nICMP>IGMP>UDP>TCP\nHeader Checksum (16 bits)\n●Calculated for header only.\n●Computed at each router  as headers ma y\nchange (e.g., TTL).\nSource Address (32 bits)\n●IPv4 address of sender.\nDestination Address (32 bits)\n●IPv4 address of receiver.\nOptions (0– 40 bytes)\nThe IPv4 datagram header consists of two parts :\n●A fixed part , which is always…\n[p35:c62] ike voltage, data speed,\ndistance, and connection type.Data Link Layer\n●Works at Layer 2 of OSI model.\n●Transfers frames from one node (hop) to thenext.\n●Converts:\n○Bits ↔ Packets (Frames)\n●Uses Layer 1 (Physical Layer) to send bitstream.\nMain Functions:\n●Framing – Breaks bit stream into frames.\n●Error Control – Detects and handles errors in\ntransm…", "draft_gold_answer": "Error Control ●Number of corrupted bits = Data rate × Noise duration ●Burst error is more likely to occur than singl e bit error. ●Error correction is more difficult than erro r detection. Error Control: ●Error Detection: If error found, discard and ask for re…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List any assumptions, prerequisites, or constraints mentioned.", "gold_answer": "Types of Packet Switching 1.Datagram Packet Switching 2.Virtual Circuit Packet Switching Datagram Switching Virtual Circuit Switching No need to make a connection before sending data. Connection is made first, then data is sent. Each data packet can go from a…", "gold_evidence": "[p25:c40] Types of Packet Switching\n1.Datagram Packet Switching\n2.Virtual Circuit Packet Switching\nDatagram\nSwitching  Virtual Circuit\nSwitching\nNo need to make a\nconnection before\nsending data.  Connection is made first,\nthen data is sent.\nEach data packet can\ngo from a different\nroute.  All packets go through the\nsame fixed route.\nPackets can reach the\ndes…\n[p16:c25] r:\n●This is a 32- bit field defines the seq number\nof the first data byte.\n●Every byte is associated with one seq\nnumber.Data size at TL = Total Length (IP) - IP(H)\n-TCP(H)\n●Every packet is associated with one seq uence\nnumber.\n●TCP Suggests : Do not start with t he\nsequence number 0.\n➤ Always choose any random sequenc e\nnumber initially.\nAcknowled…\n[p26:c45] he packet’s header (info).\nRedirection  Suggests a better route for\nthe packet.\n2. Query or Request and Reply Messages\nThese are used for asking questions or sending\nrequests and getting replies.\nCOMPUETR NETWORK\nGATE फर्रे\nPage No:- 23\n[p27:c48] n doesn’t stay open.\nPersistent  (1.1)\nIn Persistent HTTP, the TCP connection is kept open for multiple requests.\nKey Points:\n1.The server keeps the connection ope n even\nafter sending the response.\n2.The connection is closed only when:\n○Client asks to close it, or\n○A timeout occurs.\nThis makes it faster and more efficient than non-persistent.\nCOMP…", "draft_gold_evidence": "[p25:c40] Types of Packet Switching\n1.Datagram Packet Switching\n2.Virtual Circuit Packet Switching\nDatagram\nSwitching  Virtual Circuit\nSwitching\nNo need to make a\nconnection before\nsending data.  Connection is made first,\nthen data is sent.\nEach data packet can\ngo from a different\nroute.  All packets go through the\nsame fixed route.\nPackets can reach the\ndes…\n[p16:c25] r:\n●This is a 32- bit field defines the seq number\nof the first data byte.\n●Every byte is associated with one seq\nnumber.Data size at TL = Total Length (IP) - IP(H)\n-TCP(H)\n●Every packet is associated with one seq uence\nnumber.\n●TCP Suggests : Do not start with t he\nsequence number 0.\n➤ Always choose any random sequenc e\nnumber initially.\nAcknowled…\n[p26:c45] he packet’s header (info).\nRedirection  Suggests a better route for\nthe packet.\n2. Query or Request and Reply Messages\nThese are used for asking questions or sending\nrequests and getting replies.\nCOMPUETR NETWORK\nGATE फर्रे\nPage No:- 23\n[p27:c48] n doesn’t stay open.\nPersistent  (1.1)\nIn Persistent HTTP, the TCP connection is kept open for multiple requests.\nKey Points:\n1.The server keeps the connection ope n even\nafter sending the response.\n2.The connection is closed only when:\n○Client asks to close it, or\n○A timeout occurs.\nThis makes it faster and more efficient than non-persistent.\nCOMP…", "draft_gold_answer": "Types of Packet Switching 1.Datagram Packet Switching 2.Virtual Circuit Packet Switching Datagram Switching Virtual Circuit Switching No need to make a connection before sending data. Connection is made first, then data is sent. Each data packet can go from a…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Give one example mentioned in the notes.", "gold_answer": "g distance between two strings ofequal length is the number of positions at which the corresponding symbols (0 or 1) a re different. ●Denoted by d(x, y). Examples: 1.d(000, 101) = 2 hamming distance 2.d(100, 011) = 3 hamming distance 3.d(101, 110) = 2 hamming…", "gold_evidence": "[p5:c6] g distance between two strings ofequal length is the number of positions at\nwhich the corresponding symbols (0 or 1) a re\ndifferent.\n●Denoted by d(x, y).\nExamples:\n1.d(000, 101) = 2 hamming distance\n2.d(100, 011) = 3 hamming distance\n3.d(101, 110) = 2 hamming distance\n●Hamming distance can be found by applyingXOR operation ( ⊕) on  two codewords an…\n[p35:c62] ike voltage, data speed,\ndistance, and connection type.Data Link Layer\n●Works at Layer 2 of OSI model.\n●Transfers frames from one node (hop) to thenext.\n●Converts:\n○Bits ↔ Packets (Frames)\n●Uses Layer 1 (Physical Layer) to send bitstream.\nMain Functions:\n●Framing – Breaks bit stream into frames.\n●Error Control – Detects and handles errors in\ntransm…\n[p16:c24] TCP & UDP\nSource Port (16 bits)  Destination Port\n(16 bits)\nSequence number (32 bits)\nAcknowledgement number (32 bits)\nHeader\nLength\n(4 bits)  Reserved\nbits (6 bits) U\nR\nB A\nC K P\nS H R\nS T S\nY N F\nI N Window Size\n(Advertisement Window) (16 bits)\nCheck sum (16 bits)\nOptions (0 -40 bytes)\nHeader length: (4 bits)\n●Header length is a 4- bit field that…\n[p3:c2] Special Cases:\nNID HID\nvalid  all 0’s → N/w\nid of entire\nn/w\nvalid   All 1’s →\nDirected\nbroadcast\naddress (DBA)\nAll 1’s  all 1’s →\nLimited broadcast address (LBA)\n7.Subnetting : Subnetting is borrowing bit s\nfrom HID.\nSubnet mask : It helps to identify which portion of IP\nis network ID and which portion is host ID.\n●No. of 1’s = (NID + Subnet ID)\n●…", "draft_gold_evidence": "[p5:c6] g distance between two strings ofequal length is the number of positions at\nwhich the corresponding symbols (0 or 1) a re\ndifferent.\n●Denoted by d(x, y).\nExamples:\n1.d(000, 101) = 2 hamming distance\n2.d(100, 011) = 3 hamming distance\n3.d(101, 110) = 2 hamming distance\n●Hamming distance can be found by applyingXOR operation ( ⊕) on  two codewords an…\n[p35:c62] ike voltage, data speed,\ndistance, and connection type.Data Link Layer\n●Works at Layer 2 of OSI model.\n●Transfers frames from one node (hop) to thenext.\n●Converts:\n○Bits ↔ Packets (Frames)\n●Uses Layer 1 (Physical Layer) to send bitstream.\nMain Functions:\n●Framing – Breaks bit stream into frames.\n●Error Control – Detects and handles errors in\ntransm…\n[p16:c24] TCP & UDP\nSource Port (16 bits)  Destination Port\n(16 bits)\nSequence number (32 bits)\nAcknowledgement number (32 bits)\nHeader\nLength\n(4 bits)  Reserved\nbits (6 bits) U\nR\nB A\nC K P\nS H R\nS T S\nY N F\nI N Window Size\n(Advertisement Window) (16 bits)\nCheck sum (16 bits)\nOptions (0 -40 bytes)\nHeader length: (4 bits)\n●Header length is a 4- bit field that…\n[p3:c2] Special Cases:\nNID HID\nvalid  all 0’s → N/w\nid of entire\nn/w\nvalid   All 1’s →\nDirected\nbroadcast\naddress (DBA)\nAll 1’s  all 1’s →\nLimited broadcast address (LBA)\n7.Subnetting : Subnetting is borrowing bit s\nfrom HID.\nSubnet mask : It helps to identify which portion of IP\nis network ID and which portion is host ID.\n●No. of 1’s = (NID + Subnet ID)\n●…", "draft_gold_answer": "g distance between two strings ofequal length is the number of positions at which the corresponding symbols (0 or 1) a re different. ●Denoted by d(x, y). Examples: 1.d(000, 101) = 2 hamming distance 2.d(100, 011) = 3 hamming distance 3.d(101, 110) = 2 hamming…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What are the advantages and limitations of the main method/topic (as stated)?", "gold_answer": "r. ●Directly interacts with the user andapplications.Main Functions : ●Provides network services to users (e.g. , email, file transfer, web browsing). ●Supports applications like Mail services, Fil e sharing, etc. ●Gives access to network- based apps (e.g. , b…", "gold_evidence": "[p37:c67] r.\n●Directly interacts with the user andapplications.Main Functions :\n●Provides network services to users (e.g. ,\nemail, file transfer, web browsing).\n●Supports applications like Mail services, Fil e\nsharing, etc.\n●Gives access to network- based apps (e.g. ,\nbrowser,  FTP client).\n●Represents what the user sees or uses.\nExamples of Services :\n●Emai…\n[p25:c40] Types of Packet Switching\n1.Datagram Packet Switching\n2.Virtual Circuit Packet Switching\nDatagram\nSwitching  Virtual Circuit\nSwitching\nNo need to make a\nconnection before\nsending data.  Connection is made first,\nthen data is sent.\nEach data packet can\ngo from a different\nroute.  All packets go through the\nsame fixed route.\nPackets can reach the\ndes…\n[p39:c69] TCP/IP Model\nThere are 5 layers of the TCP/IP model.\n1.Physical Layer\n2.Data Link Layer\n3.Network Layer\n4.Transport Layer\n5.Application Layer\nPhysical Layer\n●Lowest layer of TCP/IP model.\n●Deals with actual transmission of raw bit s\nover physical media (cables, wireless signals).\n●Defines electrical and mechanical\nspecifications like voltage, cable…\n[p26:c45] he packet’s header (info).\nRedirection  Suggests a better route for\nthe packet.\n2. Query or Request and Reply Messages\nThese are used for asking questions or sending\nrequests and getting replies.\nCOMPUETR NETWORK\nGATE फर्रे\nPage No:- 23", "draft_gold_evidence": "[p37:c67] r.\n●Directly interacts with the user andapplications.Main Functions :\n●Provides network services to users (e.g. ,\nemail, file transfer, web browsing).\n●Supports applications like Mail services, Fil e\nsharing, etc.\n●Gives access to network- based apps (e.g. ,\nbrowser,  FTP client).\n●Represents what the user sees or uses.\nExamples of Services :\n●Emai…\n[p25:c40] Types of Packet Switching\n1.Datagram Packet Switching\n2.Virtual Circuit Packet Switching\nDatagram\nSwitching  Virtual Circuit\nSwitching\nNo need to make a\nconnection before\nsending data.  Connection is made first,\nthen data is sent.\nEach data packet can\ngo from a different\nroute.  All packets go through the\nsame fixed route.\nPackets can reach the\ndes…\n[p39:c69] TCP/IP Model\nThere are 5 layers of the TCP/IP model.\n1.Physical Layer\n2.Data Link Layer\n3.Network Layer\n4.Transport Layer\n5.Application Layer\nPhysical Layer\n●Lowest layer of TCP/IP model.\n●Deals with actual transmission of raw bit s\nover physical media (cables, wireless signals).\n●Defines electrical and mechanical\nspecifications like voltage, cable…\n[p26:c45] he packet’s header (info).\nRedirection  Suggests a better route for\nthe packet.\n2. Query or Request and Reply Messages\nThese are used for asking questions or sending\nrequests and getting replies.\nCOMPUETR NETWORK\nGATE फर्रे\nPage No:- 23", "draft_gold_answer": "r. ●Directly interacts with the user andapplications.Main Functions : ●Provides network services to users (e.g. , email, file transfer, web browsing). ●Supports applications like Mail services, Fil e sharing, etc. ●Gives access to network- based apps (e.g. , b…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Summarize the key takeaways in 3 bullet points.", "gold_answer": "n doesn’t stay open. Persistent (1.1) In Persistent HTTP, the TCP connection is kept open for multiple requests. Key Points: 1.The server keeps the connection ope n even after sending the response. 2.The connection is closed only when: ○Client asks to close it…", "gold_evidence": "[p27:c48] n doesn’t stay open.\nPersistent  (1.1)\nIn Persistent HTTP, the TCP connection is kept open for multiple requests.\nKey Points:\n1.The server keeps the connection ope n even\nafter sending the response.\n2.The connection is closed only when:\n○Client asks to close it, or\n○A timeout occurs.\nThis makes it faster and more efficient than non-persistent.\nCOMP…\n[p27:c47] a client -server protocol, and works o n\nport number 80 using TCP.3.HTTP is an In -Band protocol – both request\nand data are sent in the same connection.\n4.HTTP is a stateless protocol, which means itdoes not remember anything about the  user\nor past requests.\n5.There are 2 types of HTTP connections:\n○(i) Non -persistent (1.0)\n○(ii) Persistent (1.1…\n[p32:c58] Types of DNS Severs\n1.Root Server – First-level server, points to TLD\nservers.\n2.TLD (Top Level Domain) Server – Handl es\ndomains like .com , .org, .i n, etc.\n3.Authoritative DNS Server – Stores the actual\nIP address of a domain name.\n4.Local DNS Resolver – Found in client- side\nnetworks, stores cached queries.\nMain Services of DNS\n●Name Tra nslati…\n[p30:c56] ontrol share the same connection).POP3 VS IMAP4 -Key Differences\n🔸🔸 POP3 🔹🔹 IMAP 4\nMails can only be\naccessed from one\ndevice.  Mails can be accessed\nfrom multiple devices.\nEmails are downloaded\nand deleted from the\nserver.  Emails stay on the server\nand sync across devices.\nUsers cannot organize\nmails on the server.  Users can organize mails\nin fo…", "draft_gold_evidence": "[p27:c48] n doesn’t stay open.\nPersistent  (1.1)\nIn Persistent HTTP, the TCP connection is kept open for multiple requests.\nKey Points:\n1.The server keeps the connection ope n even\nafter sending the response.\n2.The connection is closed only when:\n○Client asks to close it, or\n○A timeout occurs.\nThis makes it faster and more efficient than non-persistent.\nCOMP…\n[p27:c47] a client -server protocol, and works o n\nport number 80 using TCP.3.HTTP is an In -Band protocol – both request\nand data are sent in the same connection.\n4.HTTP is a stateless protocol, which means itdoes not remember anything about the  user\nor past requests.\n5.There are 2 types of HTTP connections:\n○(i) Non -persistent (1.0)\n○(ii) Persistent (1.1…\n[p32:c58] Types of DNS Severs\n1.Root Server – First-level server, points to TLD\nservers.\n2.TLD (Top Level Domain) Server – Handl es\ndomains like .com , .org, .i n, etc.\n3.Authoritative DNS Server – Stores the actual\nIP address of a domain name.\n4.Local DNS Resolver – Found in client- side\nnetworks, stores cached queries.\nMain Services of DNS\n●Name Tra nslati…\n[p30:c56] ontrol share the same connection).POP3 VS IMAP4 -Key Differences\n🔸🔸 POP3 🔹🔹 IMAP 4\nMails can only be\naccessed from one\ndevice.  Mails can be accessed\nfrom multiple devices.\nEmails are downloaded\nand deleted from the\nserver.  Emails stay on the server\nand sync across devices.\nUsers cannot organize\nmails on the server.  Users can organize mails\nin fo…", "draft_gold_answer": "n doesn’t stay open. Persistent (1.1) In Persistent HTTP, the TCP connection is kept open for multiple requests. Key Points: 1.The server keeps the connection ope n even after sending the response. 2.The connection is closed only when: ○Client asks to close it…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Is there any deadline/submission instruction in the document? If not, answer 'Not found in the document.'", "gold_answer": "Types of Packet Switching 1.Datagram Packet Switching 2.Virtual Circuit Packet Switching Datagram Switching Virtual Circuit Switching No need to make a connection before sending data. Connection is made first, then data is sent. Each data packet can go from a…", "gold_evidence": "[p25:c40] Types of Packet Switching\n1.Datagram Packet Switching\n2.Virtual Circuit Packet Switching\nDatagram\nSwitching  Virtual Circuit\nSwitching\nNo need to make a\nconnection before\nsending data.  Connection is made first,\nthen data is sent.\nEach data packet can\ngo from a different\nroute.  All packets go through the\nsame fixed route.\nPackets can reach the\ndes…\n[p18:c29] Retransmission in TCP:\n1.Retransmission after timeout timer\n2.Retransmission after 3 duplicate ACKs\nSilly Window Syndrome\n●When we use capacity of the network\ninefficiently (overhead >> data transfer)\n●Happens when:\n○Receiving capacity becomes 0\n○Produces only one byte at a time\n○Consumes only one byte at a time →leads to Silly Window Syndrome\nTCP…\n[p25:c41] ry\nshort info.\nIf there is no space,\npackets can be\ndropped midway.  Packets are never dropped;\nthey are queued or\nforwarded.\nUsed in IP networks\n(like the Internet). Used in ATM\n(Asynchronous Transfer\nMode).\nWorks mostly at\nNetwork Layer (Layer\n3). Works mostly at Data L ink\nLayer (Layer 2). Routing Algorithm\nRouting Algorithm\n/      \\\nStatic…\n[p27:c47] a client -server protocol, and works o n\nport number 80 using TCP.3.HTTP is an In -Band protocol – both request\nand data are sent in the same connection.\n4.HTTP is a stateless protocol, which means itdoes not remember anything about the  user\nor past requests.\n5.There are 2 types of HTTP connections:\n○(i) Non -persistent (1.0)\n○(ii) Persistent (1.1…", "draft_gold_evidence": "[p25:c40] Types of Packet Switching\n1.Datagram Packet Switching\n2.Virtual Circuit Packet Switching\nDatagram\nSwitching  Virtual Circuit\nSwitching\nNo need to make a\nconnection before\nsending data.  Connection is made first,\nthen data is sent.\nEach data packet can\ngo from a different\nroute.  All packets go through the\nsame fixed route.\nPackets can reach the\ndes…\n[p18:c29] Retransmission in TCP:\n1.Retransmission after timeout timer\n2.Retransmission after 3 duplicate ACKs\nSilly Window Syndrome\n●When we use capacity of the network\ninefficiently (overhead >> data transfer)\n●Happens when:\n○Receiving capacity becomes 0\n○Produces only one byte at a time\n○Consumes only one byte at a time →leads to Silly Window Syndrome\nTCP…\n[p25:c41] ry\nshort info.\nIf there is no space,\npackets can be\ndropped midway.  Packets are never dropped;\nthey are queued or\nforwarded.\nUsed in IP networks\n(like the Internet). Used in ATM\n(Asynchronous Transfer\nMode).\nWorks mostly at\nNetwork Layer (Layer\n3). Works mostly at Data L ink\nLayer (Layer 2). Routing Algorithm\nRouting Algorithm\n/      \\\nStatic…\n[p27:c47] a client -server protocol, and works o n\nport number 80 using TCP.3.HTTP is an In -Band protocol – both request\nand data are sent in the same connection.\n4.HTTP is a stateless protocol, which means itdoes not remember anything about the  user\nor past requests.\n5.There are 2 types of HTTP connections:\n○(i) Non -persistent (1.0)\n○(ii) Persistent (1.1…", "draft_gold_answer": "Types of Packet Switching 1.Datagram Packet Switching 2.Virtual Circuit Packet Switching Datagram Switching Virtual Circuit Switching No need to make a connection before sending data. Connection is made first, then data is sent. Each data packet can go from a…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one definition stated in the notes? Quote it exactly if present; otherwise answer 'Not found in the document.'", "gold_answer": "ervice (TOS)●Last bit = Not used Structure: P P P D T R C X ●P = Priority ●D = Min delay ●T = Max throughput ●R = High reliability ●C = Min cost Priority It is a 3 -bit subfield ranging from 0 to 7 (000 to 111 in binary). Priority field is needed if a router i…", "gold_evidence": "[p13:c20] ervice  (TOS)●Last bit = Not used\nStructure:\nP P P D T R C X\n●P = Priority\n●D = Min delay\n●T = Max throughput\n●R = High reliability\n●C = Min cost\nPriority\nIt is a 3 -bit subfield ranging from 0 to 7 (000\nto 111 in binary). Priority field is needed if a\nrouter is congested and need to discard some datagram, those datagrams which have the lowest prio…\n[p30:c57] Layer protocol.\n4.It uses UDP port 53 by default, and TCP port53 for large transfers (e.g., zone transfers).\n5.It is a pull protocol – client sends qu ery,\nserver re plies.\n6.DNS follows a client -server architecture.\n7.It uses a distributed database to store dat a\nin the form of resource records.\n8.DNS is a stateless protocol – it does not\nremembe…\n[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…\n[p18:c29] Retransmission in TCP:\n1.Retransmission after timeout timer\n2.Retransmission after 3 duplicate ACKs\nSilly Window Syndrome\n●When we use capacity of the network\ninefficiently (overhead >> data transfer)\n●Happens when:\n○Receiving capacity becomes 0\n○Produces only one byte at a time\n○Consumes only one byte at a time →leads to Silly Window Syndrome\nTCP…", "draft_gold_evidence": "[p13:c20] ervice  (TOS)●Last bit = Not used\nStructure:\nP P P D T R C X\n●P = Priority\n●D = Min delay\n●T = Max throughput\n●R = High reliability\n●C = Min cost\nPriority\nIt is a 3 -bit subfield ranging from 0 to 7 (000\nto 111 in binary). Priority field is needed if a\nrouter is congested and need to discard some datagram, those datagrams which have the lowest prio…\n[p30:c57] Layer protocol.\n4.It uses UDP port 53 by default, and TCP port53 for large transfers (e.g., zone transfers).\n5.It is a pull protocol – client sends qu ery,\nserver re plies.\n6.DNS follows a client -server architecture.\n7.It uses a distributed database to store dat a\nin the form of resource records.\n8.DNS is a stateless protocol – it does not\nremembe…\n[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…\n[p18:c29] Retransmission in TCP:\n1.Retransmission after timeout timer\n2.Retransmission after 3 duplicate ACKs\nSilly Window Syndrome\n●When we use capacity of the network\ninefficiently (overhead >> data transfer)\n●Happens when:\n○Receiving capacity becomes 0\n○Produces only one byte at a time\n○Consumes only one byte at a time →leads to Silly Window Syndrome\nTCP…", "draft_gold_answer": "ervice (TOS)●Last bit = Not used Structure: P P P D T R C X ●P = Priority ●D = Min delay ●T = Max throughput ●R = High reliability ●C = Min cost Priority It is a 3 -bit subfield ranging from 0 to 7 (000 to 111 in binary). Priority field is needed if a router i…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the time complexity of one algorithm mentioned (as stated)? If not present, answer 'Not found in the document.'", "gold_answer": "Flow Control Bandwidth: ●Bandwidth refers to maximum rate of data transfer across a network or internet connection. K, M, G are different for Data and Bandwidth: Unit Data Bandwidth K 2¹⁰ 10³ M 2²⁰ 10⁶ G 2³⁰ 10⁹ Delay in Computer Networks 1.Transmission Delay…", "gold_evidence": "[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…\n[p18:c29] Retransmission in TCP:\n1.Retransmission after timeout timer\n2.Retransmission after 3 duplicate ACKs\nSilly Window Syndrome\n●When we use capacity of the network\ninefficiently (overhead >> data transfer)\n●Happens when:\n○Receiving capacity becomes 0\n○Produces only one byte at a time\n○Consumes only one byte at a time →leads to Silly Window Syndrome\nTCP…\n[p25:c41] ry\nshort info.\nIf there is no space,\npackets can be\ndropped midway.  Packets are never dropped;\nthey are queued or\nforwarded.\nUsed in IP networks\n(like the Internet). Used in ATM\n(Asynchronous Transfer\nMode).\nWorks mostly at\nNetwork Layer (Layer\n3). Works mostly at Data L ink\nLayer (Layer 2). Routing Algorithm\nRouting Algorithm\n/      \\\nStatic…\n[p14:c21] Flags (3 bits)\n●Bit 1: Not used\n●Bit 2: DF = Don’t Fragment\n●Bit 3: MF = More Fragments\nFragment Offset (13 bits)\n●Indicates the position of the fragmentrelative to the original datagram.\n●Stored as offset/8 (scaling factor = 8).\nFragment Types:\n●FO = 0 → First fragment\n●FO  ≠ 0 → Middle OR LAST\n●FO ≠ 0, MF = 0 → Last fragment\n●FO = 0, MF = 0 → No…", "draft_gold_evidence": "[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…\n[p18:c29] Retransmission in TCP:\n1.Retransmission after timeout timer\n2.Retransmission after 3 duplicate ACKs\nSilly Window Syndrome\n●When we use capacity of the network\ninefficiently (overhead >> data transfer)\n●Happens when:\n○Receiving capacity becomes 0\n○Produces only one byte at a time\n○Consumes only one byte at a time →leads to Silly Window Syndrome\nTCP…\n[p25:c41] ry\nshort info.\nIf there is no space,\npackets can be\ndropped midway.  Packets are never dropped;\nthey are queued or\nforwarded.\nUsed in IP networks\n(like the Internet). Used in ATM\n(Asynchronous Transfer\nMode).\nWorks mostly at\nNetwork Layer (Layer\n3). Works mostly at Data L ink\nLayer (Layer 2). Routing Algorithm\nRouting Algorithm\n/      \\\nStatic…\n[p14:c21] Flags (3 bits)\n●Bit 1: Not used\n●Bit 2: DF = Don’t Fragment\n●Bit 3: MF = More Fragments\nFragment Offset (13 bits)\n●Indicates the position of the fragmentrelative to the original datagram.\n●Stored as offset/8 (scaling factor = 8).\nFragment Types:\n●FO = 0 → First fragment\n●FO  ≠ 0 → Middle OR LAST\n●FO ≠ 0, MF = 0 → Last fragment\n●FO = 0, MF = 0 → No…", "draft_gold_answer": "Flow Control Bandwidth: ●Bandwidth refers to maximum rate of data transfer across a network or internet connection. K, M, G are different for Data and Bandwidth: Unit Data Bandwidth K 2¹⁰ 10³ M 2²⁰ 10⁶ G 2³⁰ 10⁹ Delay in Computer Networks 1.Transmission Delay…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 3 important keywords/terms that appear in the notes.", "gold_answer": "4. RST (Rese t): Used to abruptly terminate a connection, often i n respo nse to some error or invalid segment. 5. SYN (Synchronize): Used to initiate a connection during the TCP 3- way handshake. It signals the beginning of a TCP conversation. 6.FIN (Finish):…", "gold_evidence": "[p17:c27] 4. RST (Rese t):\nUsed to abruptly terminate a connection, often i n\nrespo nse to some error or invalid segment.\n5. SYN (Synchronize):\nUsed to initiate a connection during the TCP 3- way\nhandshake. It signals the beginning of a TCP\nconversation.\n6.FIN (Finish):\nUsed to terminate a TCP connection gracefully.\n➡ When a sender sets FIN, it indicates tha…\n[p27:c47] a client -server protocol, and works o n\nport number 80 using TCP.3.HTTP is an In -Band protocol – both request\nand data are sent in the same connection.\n4.HTTP is a stateless protocol, which means itdoes not remember anything about the  user\nor past requests.\n5.There are 2 types of HTTP connections:\n○(i) Non -persistent (1.0)\n○(ii) Persistent (1.1…\n[p5:c6] g distance between two strings ofequal length is the number of positions at\nwhich the corresponding symbols (0 or 1) a re\ndifferent.\n●Denoted by d(x, y).\nExamples:\n1.d(000, 101) = 2 hamming distance\n2.d(100, 011) = 3 hamming distance\n3.d(101, 110) = 2 hamming distance\n●Hamming distance can be found by applyingXOR operation ( ⊕) on  two codewords an…\n[p29:c54] erver to Client)\nPOP3( Post office Protocol version -3)\n1.Message access protocol – used for\nreceiving emails from the mail server.\n2.It is a pull protocol – pulls mails from server\nto client.\n3.Works on TCP port 110.\n4.It is a connection- oriented protocol –\nconnection is required for communication.\n5.Uses persistent TCP connection – connectio n\ns…", "draft_gold_evidence": "[p17:c27] 4. RST (Rese t):\nUsed to abruptly terminate a connection, often i n\nrespo nse to some error or invalid segment.\n5. SYN (Synchronize):\nUsed to initiate a connection during the TCP 3- way\nhandshake. It signals the beginning of a TCP\nconversation.\n6.FIN (Finish):\nUsed to terminate a TCP connection gracefully.\n➡ When a sender sets FIN, it indicates tha…\n[p27:c47] a client -server protocol, and works o n\nport number 80 using TCP.3.HTTP is an In -Band protocol – both request\nand data are sent in the same connection.\n4.HTTP is a stateless protocol, which means itdoes not remember anything about the  user\nor past requests.\n5.There are 2 types of HTTP connections:\n○(i) Non -persistent (1.0)\n○(ii) Persistent (1.1…\n[p5:c6] g distance between two strings ofequal length is the number of positions at\nwhich the corresponding symbols (0 or 1) a re\ndifferent.\n●Denoted by d(x, y).\nExamples:\n1.d(000, 101) = 2 hamming distance\n2.d(100, 011) = 3 hamming distance\n3.d(101, 110) = 2 hamming distance\n●Hamming distance can be found by applyingXOR operation ( ⊕) on  two codewords an…\n[p29:c54] erver to Client)\nPOP3( Post office Protocol version -3)\n1.Message access protocol – used for\nreceiving emails from the mail server.\n2.It is a pull protocol – pulls mails from server\nto client.\n3.Works on TCP port 110.\n4.It is a connection- oriented protocol –\nconnection is required for communication.\n5.Uses persistent TCP connection – connectio n\ns…", "draft_gold_answer": "4. RST (Rese t): Used to abruptly terminate a connection, often i n respo nse to some error or invalid segment. 5. SYN (Synchronize): Used to initiate a connection during the TCP 3- way handshake. It signals the beginning of a TCP conversation. 6.FIN (Finish):…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one theorem/lemma/property stated? If not present, answer 'Not found in the document.'", "gold_answer": "Flow Control Bandwidth: ●Bandwidth refers to maximum rate of data transfer across a network or internet connection. K, M, G are different for Data and Bandwidth: Unit Data Bandwidth K 2¹⁰ 10³ M 2²⁰ 10⁶ G 2³⁰ 10⁹ Delay in Computer Networks 1.Transmission Delay…", "gold_evidence": "[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…\n[p18:c29] Retransmission in TCP:\n1.Retransmission after timeout timer\n2.Retransmission after 3 duplicate ACKs\nSilly Window Syndrome\n●When we use capacity of the network\ninefficiently (overhead >> data transfer)\n●Happens when:\n○Receiving capacity becomes 0\n○Produces only one byte at a time\n○Consumes only one byte at a time →leads to Silly Window Syndrome\nTCP…\n[p13:c20] ervice  (TOS)●Last bit = Not used\nStructure:\nP P P D T R C X\n●P = Priority\n●D = Min delay\n●T = Max throughput\n●R = High reliability\n●C = Min cost\nPriority\nIt is a 3 -bit subfield ranging from 0 to 7 (000\nto 111 in binary). Priority field is needed if a\nrouter is congested and need to discard some datagram, those datagrams which have the lowest prio…\n[p18:c30] on●Connection stays open for 2MSL to allow TCPto resend final ACK in case ACK is lost\n4.Timeout Timer\n●Starts after sending TCP segment\n●If ACK not received in time →\nRetransmission\n●Timeout timer = Retransmission Timer\n●Should adapt based on traffic:\n○Increase if traffic is high\n○Decrease if low traffic\nAlgorithms for Computing Timeout Timer\n1.Bas…", "draft_gold_evidence": "[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…\n[p18:c29] Retransmission in TCP:\n1.Retransmission after timeout timer\n2.Retransmission after 3 duplicate ACKs\nSilly Window Syndrome\n●When we use capacity of the network\ninefficiently (overhead >> data transfer)\n●Happens when:\n○Receiving capacity becomes 0\n○Produces only one byte at a time\n○Consumes only one byte at a time →leads to Silly Window Syndrome\nTCP…\n[p13:c20] ervice  (TOS)●Last bit = Not used\nStructure:\nP P P D T R C X\n●P = Priority\n●D = Min delay\n●T = Max throughput\n●R = High reliability\n●C = Min cost\nPriority\nIt is a 3 -bit subfield ranging from 0 to 7 (000\nto 111 in binary). Priority field is needed if a\nrouter is congested and need to discard some datagram, those datagrams which have the lowest prio…\n[p18:c30] on●Connection stays open for 2MSL to allow TCPto resend final ACK in case ACK is lost\n4.Timeout Timer\n●Starts after sending TCP segment\n●If ACK not received in time →\nRetransmission\n●Timeout timer = Retransmission Timer\n●Should adapt based on traffic:\n○Increase if traffic is high\n○Decrease if low traffic\nAlgorithms for Computing Timeout Timer\n1.Bas…", "draft_gold_answer": "Flow Control Bandwidth: ●Bandwidth refers to maximum rate of data transfer across a network or internet connection. K, M, G are different for Data and Bandwidth: Unit Data Bandwidth K 2¹⁰ 10³ M 2²⁰ 10⁶ G 2³⁰ 10⁹ Delay in Computer Networks 1.Transmission Delay…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Describe one table/list mentioned (what items are compared or listed). If none, answer 'Not found in the document.'", "gold_answer": "Flow Control Bandwidth: ●Bandwidth refers to maximum rate of data transfer across a network or internet connection. K, M, G are different for Data and Bandwidth: Unit Data Bandwidth K 2¹⁰ 10³ M 2²⁰ 10⁶ G 2³⁰ 10⁹ Delay in Computer Networks 1.Transmission Delay…", "gold_evidence": "[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…\n[p13:c20] ervice  (TOS)●Last bit = Not used\nStructure:\nP P P D T R C X\n●P = Priority\n●D = Min delay\n●T = Max throughput\n●R = High reliability\n●C = Min cost\nPriority\nIt is a 3 -bit subfield ranging from 0 to 7 (000\nto 111 in binary). Priority field is needed if a\nrouter is congested and need to discard some datagram, those datagrams which have the lowest prio…\n[p25:c40] Types of Packet Switching\n1.Datagram Packet Switching\n2.Virtual Circuit Packet Switching\nDatagram\nSwitching  Virtual Circuit\nSwitching\nNo need to make a\nconnection before\nsending data.  Connection is made first,\nthen data is sent.\nEach data packet can\ngo from a different\nroute.  All packets go through the\nsame fixed route.\nPackets can reach the\ndes…\n[p25:c41] ry\nshort info.\nIf there is no space,\npackets can be\ndropped midway.  Packets are never dropped;\nthey are queued or\nforwarded.\nUsed in IP networks\n(like the Internet). Used in ATM\n(Asynchronous Transfer\nMode).\nWorks mostly at\nNetwork Layer (Layer\n3). Works mostly at Data L ink\nLayer (Layer 2). Routing Algorithm\nRouting Algorithm\n/      \\\nStatic…", "draft_gold_evidence": "[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…\n[p13:c20] ervice  (TOS)●Last bit = Not used\nStructure:\nP P P D T R C X\n●P = Priority\n●D = Min delay\n●T = Max throughput\n●R = High reliability\n●C = Min cost\nPriority\nIt is a 3 -bit subfield ranging from 0 to 7 (000\nto 111 in binary). Priority field is needed if a\nrouter is congested and need to discard some datagram, those datagrams which have the lowest prio…\n[p25:c40] Types of Packet Switching\n1.Datagram Packet Switching\n2.Virtual Circuit Packet Switching\nDatagram\nSwitching  Virtual Circuit\nSwitching\nNo need to make a\nconnection before\nsending data.  Connection is made first,\nthen data is sent.\nEach data packet can\ngo from a different\nroute.  All packets go through the\nsame fixed route.\nPackets can reach the\ndes…\n[p25:c41] ry\nshort info.\nIf there is no space,\npackets can be\ndropped midway.  Packets are never dropped;\nthey are queued or\nforwarded.\nUsed in IP networks\n(like the Internet). Used in ATM\n(Asynchronous Transfer\nMode).\nWorks mostly at\nNetwork Layer (Layer\n3). Works mostly at Data L ink\nLayer (Layer 2). Routing Algorithm\nRouting Algorithm\n/      \\\nStatic…", "draft_gold_answer": "Flow Control Bandwidth: ●Bandwidth refers to maximum rate of data transfer across a network or internet connection. K, M, G are different for Data and Bandwidth: Unit Data Bandwidth K 2¹⁰ 10³ M 2²⁰ 10⁶ G 2³⁰ 10⁹ Delay in Computer Networks 1.Transmission Delay…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one stated limitation/constraint? If none, answer 'Not found in the document.'", "gold_answer": "Flow Control Bandwidth: ●Bandwidth refers to maximum rate of data transfer across a network or internet connection. K, M, G are different for Data and Bandwidth: Unit Data Bandwidth K 2¹⁰ 10³ M 2²⁰ 10⁶ G 2³⁰ 10⁹ Delay in Computer Networks 1.Transmission Delay…", "gold_evidence": "[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…\n[p18:c29] Retransmission in TCP:\n1.Retransmission after timeout timer\n2.Retransmission after 3 duplicate ACKs\nSilly Window Syndrome\n●When we use capacity of the network\ninefficiently (overhead >> data transfer)\n●Happens when:\n○Receiving capacity becomes 0\n○Produces only one byte at a time\n○Consumes only one byte at a time →leads to Silly Window Syndrome\nTCP…\n[p13:c20] ervice  (TOS)●Last bit = Not used\nStructure:\nP P P D T R C X\n●P = Priority\n●D = Min delay\n●T = Max throughput\n●R = High reliability\n●C = Min cost\nPriority\nIt is a 3 -bit subfield ranging from 0 to 7 (000\nto 111 in binary). Priority field is needed if a\nrouter is congested and need to discard some datagram, those datagrams which have the lowest prio…\n[p18:c30] on●Connection stays open for 2MSL to allow TCPto resend final ACK in case ACK is lost\n4.Timeout Timer\n●Starts after sending TCP segment\n●If ACK not received in time →\nRetransmission\n●Timeout timer = Retransmission Timer\n●Should adapt based on traffic:\n○Increase if traffic is high\n○Decrease if low traffic\nAlgorithms for Computing Timeout Timer\n1.Bas…", "draft_gold_evidence": "[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…\n[p18:c29] Retransmission in TCP:\n1.Retransmission after timeout timer\n2.Retransmission after 3 duplicate ACKs\nSilly Window Syndrome\n●When we use capacity of the network\ninefficiently (overhead >> data transfer)\n●Happens when:\n○Receiving capacity becomes 0\n○Produces only one byte at a time\n○Consumes only one byte at a time →leads to Silly Window Syndrome\nTCP…\n[p13:c20] ervice  (TOS)●Last bit = Not used\nStructure:\nP P P D T R C X\n●P = Priority\n●D = Min delay\n●T = Max throughput\n●R = High reliability\n●C = Min cost\nPriority\nIt is a 3 -bit subfield ranging from 0 to 7 (000\nto 111 in binary). Priority field is needed if a\nrouter is congested and need to discard some datagram, those datagrams which have the lowest prio…\n[p18:c30] on●Connection stays open for 2MSL to allow TCPto resend final ACK in case ACK is lost\n4.Timeout Timer\n●Starts after sending TCP segment\n●If ACK not received in time →\nRetransmission\n●Timeout timer = Retransmission Timer\n●Should adapt based on traffic:\n○Increase if traffic is high\n○Decrease if low traffic\nAlgorithms for Computing Timeout Timer\n1.Bas…", "draft_gold_answer": "Flow Control Bandwidth: ●Bandwidth refers to maximum rate of data transfer across a network or internet connection. K, M, G are different for Data and Bandwidth: Unit Data Bandwidth K 2¹⁰ 10³ M 2²⁰ 10⁶ G 2³⁰ 10⁹ Delay in Computer Networks 1.Transmission Delay…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one stated advantage/benefit? If none, answer 'Not found in the document.'", "gold_answer": "Flow Control Bandwidth: ●Bandwidth refers to maximum rate of data transfer across a network or internet connection. K, M, G are different for Data and Bandwidth: Unit Data Bandwidth K 2¹⁰ 10³ M 2²⁰ 10⁶ G 2³⁰ 10⁹ Delay in Computer Networks 1.Transmission Delay…", "gold_evidence": "[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…\n[p18:c29] Retransmission in TCP:\n1.Retransmission after timeout timer\n2.Retransmission after 3 duplicate ACKs\nSilly Window Syndrome\n●When we use capacity of the network\ninefficiently (overhead >> data transfer)\n●Happens when:\n○Receiving capacity becomes 0\n○Produces only one byte at a time\n○Consumes only one byte at a time →leads to Silly Window Syndrome\nTCP…\n[p13:c20] ervice  (TOS)●Last bit = Not used\nStructure:\nP P P D T R C X\n●P = Priority\n●D = Min delay\n●T = Max throughput\n●R = High reliability\n●C = Min cost\nPriority\nIt is a 3 -bit subfield ranging from 0 to 7 (000\nto 111 in binary). Priority field is needed if a\nrouter is congested and need to discard some datagram, those datagrams which have the lowest prio…\n[p18:c30] on●Connection stays open for 2MSL to allow TCPto resend final ACK in case ACK is lost\n4.Timeout Timer\n●Starts after sending TCP segment\n●If ACK not received in time →\nRetransmission\n●Timeout timer = Retransmission Timer\n●Should adapt based on traffic:\n○Increase if traffic is high\n○Decrease if low traffic\nAlgorithms for Computing Timeout Timer\n1.Bas…", "draft_gold_evidence": "[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…\n[p18:c29] Retransmission in TCP:\n1.Retransmission after timeout timer\n2.Retransmission after 3 duplicate ACKs\nSilly Window Syndrome\n●When we use capacity of the network\ninefficiently (overhead >> data transfer)\n●Happens when:\n○Receiving capacity becomes 0\n○Produces only one byte at a time\n○Consumes only one byte at a time →leads to Silly Window Syndrome\nTCP…\n[p13:c20] ervice  (TOS)●Last bit = Not used\nStructure:\nP P P D T R C X\n●P = Priority\n●D = Min delay\n●T = Max throughput\n●R = High reliability\n●C = Min cost\nPriority\nIt is a 3 -bit subfield ranging from 0 to 7 (000\nto 111 in binary). Priority field is needed if a\nrouter is congested and need to discard some datagram, those datagrams which have the lowest prio…\n[p18:c30] on●Connection stays open for 2MSL to allow TCPto resend final ACK in case ACK is lost\n4.Timeout Timer\n●Starts after sending TCP segment\n●If ACK not received in time →\nRetransmission\n●Timeout timer = Retransmission Timer\n●Should adapt based on traffic:\n○Increase if traffic is high\n○Decrease if low traffic\nAlgorithms for Computing Timeout Timer\n1.Bas…", "draft_gold_answer": "Flow Control Bandwidth: ●Bandwidth refers to maximum rate of data transfer across a network or internet connection. K, M, G are different for Data and Bandwidth: Unit Data Bandwidth K 2¹⁰ 10³ M 2²⁰ 10⁶ G 2³⁰ 10⁹ Delay in Computer Networks 1.Transmission Delay…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Provide one short quote (1–2 sentences) from the notes that best represents the topic.", "gold_answer": "r: ●This is a 32- bit field defines the seq number of the first data byte. ●Every byte is associated with one seq number.Data size at TL = Total Length (IP) - IP(H) -TCP(H) ●Every packet is associated with one seq uence number. ●TCP Suggests : Do not start wit…", "gold_evidence": "[p16:c25] r:\n●This is a 32- bit field defines the seq number\nof the first data byte.\n●Every byte is associated with one seq\nnumber.Data size at TL = Total Length (IP) - IP(H)\n-TCP(H)\n●Every packet is associated with one seq uence\nnumber.\n●TCP Suggests : Do not start with t he\nsequence number 0.\n➤ Always choose any random sequenc e\nnumber initially.\nAcknowled…\n[p35:c62] ike voltage, data speed,\ndistance, and connection type.Data Link Layer\n●Works at Layer 2 of OSI model.\n●Transfers frames from one node (hop) to thenext.\n●Converts:\n○Bits ↔ Packets (Frames)\n●Uses Layer 1 (Physical Layer) to send bitstream.\nMain Functions:\n●Framing – Breaks bit stream into frames.\n●Error Control – Detects and handles errors in\ntransm…\n[p3:c2] Special Cases:\nNID HID\nvalid  all 0’s → N/w\nid of entire\nn/w\nvalid   All 1’s →\nDirected\nbroadcast\naddress (DBA)\nAll 1’s  all 1’s →\nLimited broadcast address (LBA)\n7.Subnetting : Subnetting is borrowing bit s\nfrom HID.\nSubnet mask : It helps to identify which portion of IP\nis network ID and which portion is host ID.\n●No. of 1’s = (NID + Subnet ID)\n●…\n[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…", "draft_gold_evidence": "[p16:c25] r:\n●This is a 32- bit field defines the seq number\nof the first data byte.\n●Every byte is associated with one seq\nnumber.Data size at TL = Total Length (IP) - IP(H)\n-TCP(H)\n●Every packet is associated with one seq uence\nnumber.\n●TCP Suggests : Do not start with t he\nsequence number 0.\n➤ Always choose any random sequenc e\nnumber initially.\nAcknowled…\n[p35:c62] ike voltage, data speed,\ndistance, and connection type.Data Link Layer\n●Works at Layer 2 of OSI model.\n●Transfers frames from one node (hop) to thenext.\n●Converts:\n○Bits ↔ Packets (Frames)\n●Uses Layer 1 (Physical Layer) to send bitstream.\nMain Functions:\n●Framing – Breaks bit stream into frames.\n●Error Control – Detects and handles errors in\ntransm…\n[p3:c2] Special Cases:\nNID HID\nvalid  all 0’s → N/w\nid of entire\nn/w\nvalid   All 1’s →\nDirected\nbroadcast\naddress (DBA)\nAll 1’s  all 1’s →\nLimited broadcast address (LBA)\n7.Subnetting : Subnetting is borrowing bit s\nfrom HID.\nSubnet mask : It helps to identify which portion of IP\nis network ID and which portion is host ID.\n●No. of 1’s = (NID + Subnet ID)\n●…\n[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…", "draft_gold_answer": "r: ●This is a 32- bit field defines the seq number of the first data byte. ●Every byte is associated with one seq number.Data size at TL = Total Length (IP) - IP(H) -TCP(H) ●Every packet is associated with one seq uence number. ●TCP Suggests : Do not start wit…"}
{"doc_id": "3bd8fbfbf8cb68dd", "pdf_path": "eval/pdfs/public/Computer-Network--_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one abbreviation/acronym expanded in the notes? If none, answer 'Not found in the document.'", "gold_answer": "Flow Control Bandwidth: ●Bandwidth refers to maximum rate of data transfer across a network or internet connection. K, M, G are different for Data and Bandwidth: Unit Data Bandwidth K 2¹⁰ 10³ M 2²⁰ 10⁶ G 2³⁰ 10⁹ Delay in Computer Networks 1.Transmission Delay…", "gold_evidence": "[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…\n[p18:c29] Retransmission in TCP:\n1.Retransmission after timeout timer\n2.Retransmission after 3 duplicate ACKs\nSilly Window Syndrome\n●When we use capacity of the network\ninefficiently (overhead >> data transfer)\n●Happens when:\n○Receiving capacity becomes 0\n○Produces only one byte at a time\n○Consumes only one byte at a time →leads to Silly Window Syndrome\nTCP…\n[p13:c20] ervice  (TOS)●Last bit = Not used\nStructure:\nP P P D T R C X\n●P = Priority\n●D = Min delay\n●T = Max throughput\n●R = High reliability\n●C = Min cost\nPriority\nIt is a 3 -bit subfield ranging from 0 to 7 (000\nto 111 in binary). Priority field is needed if a\nrouter is congested and need to discard some datagram, those datagrams which have the lowest prio…\n[p18:c30] on●Connection stays open for 2MSL to allow TCPto resend final ACK in case ACK is lost\n4.Timeout Timer\n●Starts after sending TCP segment\n●If ACK not received in time →\nRetransmission\n●Timeout timer = Retransmission Timer\n●Should adapt based on traffic:\n○Increase if traffic is high\n○Decrease if low traffic\nAlgorithms for Computing Timeout Timer\n1.Bas…", "draft_gold_evidence": "[p9:c13] Flow Control\nBandwidth:\n●Bandwidth refers to maximum rate of data\ntransfer  across a network or internet\nconnection.\nK, M, G are different for Data and Bandwidth:\nUnit Data  Bandwidth\nK 2¹⁰ 10³\nM 2²⁰ 10⁶\nG 2³⁰ 10⁹\nDelay in Computer Networks\n1.Transmission Delay (Td)\n2.Propagation Delay (Pd)\n3.Queuing Delay (Qd)  (Considered if not\nnegligible)\n4.Pro…\n[p18:c29] Retransmission in TCP:\n1.Retransmission after timeout timer\n2.Retransmission after 3 duplicate ACKs\nSilly Window Syndrome\n●When we use capacity of the network\ninefficiently (overhead >> data transfer)\n●Happens when:\n○Receiving capacity becomes 0\n○Produces only one byte at a time\n○Consumes only one byte at a time →leads to Silly Window Syndrome\nTCP…\n[p13:c20] ervice  (TOS)●Last bit = Not used\nStructure:\nP P P D T R C X\n●P = Priority\n●D = Min delay\n●T = Max throughput\n●R = High reliability\n●C = Min cost\nPriority\nIt is a 3 -bit subfield ranging from 0 to 7 (000\nto 111 in binary). Priority field is needed if a\nrouter is congested and need to discard some datagram, those datagrams which have the lowest prio…\n[p18:c30] on●Connection stays open for 2MSL to allow TCPto resend final ACK in case ACK is lost\n4.Timeout Timer\n●Starts after sending TCP segment\n●If ACK not received in time →\nRetransmission\n●Timeout timer = Retransmission Timer\n●Should adapt based on traffic:\n○Increase if traffic is high\n○Decrease if low traffic\nAlgorithms for Computing Timeout Timer\n1.Bas…", "draft_gold_answer": "Flow Control Bandwidth: ●Bandwidth refers to maximum rate of data transfer across a network or internet connection. K, M, G are different for Data and Bandwidth: Unit Data Bandwidth K 2¹⁰ 10³ M 2²⁰ 10⁶ G 2³⁰ 10⁹ Delay in Computer Networks 1.Transmission Delay…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the main topic of these notes?", "gold_answer": "on the 1d array. Sparse Matrix A sparse matrix is a matrix in which most of the elements are zero . If the number of zero elements > number of non-zero elements, the matrix is sparse. Lower Triangular Matrix A lower triangular matrix is a square matrix where a…", "gold_evidence": "[p2:c1] on the 1d array.  Sparse Matrix\nA sparse matrix  is a matrix in which most of the\nelements are zero .\nIf the number of zero elements > number of non-zero\nelements, the matrix is sparse.\nLower Triangular Matrix\nA lower triangular matrix is a square matrix where\nall elements above the main diagonal are zero .\nA[i][j] = 0 for all i < j\nMust be square…\n[p3:c3] Tridiagonal matrix\nA tridiagonal matrix  is a square matrix where non-\nzero elements exist only on the main diagonal, just\nabove it , and just below it.\nA[i][j] ≠ 0 only if i == j, i == j+1, or i == j –1\nElse, A[i][j] = 0\nSum of all the element is 3n -2.\nA linked list  is a linear data structure where elements\n(called nodes ) are stored in non -con…\n[p6:c10] d from any node and its\ndescendants\n•Maximum Nodes in a Binary Tree of Hei ght\n'h' = 2ℎ+1 −1\n•Minimum nodes in a Binary tree= h+1\n•The minimum possible height for  N nodes\nis ⌊𝐥𝐥𝐥𝐥𝐥𝐥𝟐𝟐N⌋\n•Total number of unlabelled binary tree wi th n\nnode = 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1\n•Total  number of labelled binary tree = 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1 ×\n𝑛𝑛!\n•Total number of the binary tree wi…\n[p9:c15] Postorder\nLeft Subtree → Right Subtree → Node\nHeap\nA Heap is a special Complete Binary Tree where\nevery level is completely filled except possibly the last\nlevel, and nodes are as far left as possible.\nMin Heap\nThe value of each node is less than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| < | left tree, right tree|  Root = Minimum element\npostorder(node) {\ni…", "draft_gold_evidence": "[p2:c1] on the 1d array.  Sparse Matrix\nA sparse matrix  is a matrix in which most of the\nelements are zero .\nIf the number of zero elements > number of non-zero\nelements, the matrix is sparse.\nLower Triangular Matrix\nA lower triangular matrix is a square matrix where\nall elements above the main diagonal are zero .\nA[i][j] = 0 for all i < j\nMust be square…\n[p3:c3] Tridiagonal matrix\nA tridiagonal matrix  is a square matrix where non-\nzero elements exist only on the main diagonal, just\nabove it , and just below it.\nA[i][j] ≠ 0 only if i == j, i == j+1, or i == j –1\nElse, A[i][j] = 0\nSum of all the element is 3n -2.\nA linked list  is a linear data structure where elements\n(called nodes ) are stored in non -con…\n[p6:c10] d from any node and its\ndescendants\n•Maximum Nodes in a Binary Tree of Hei ght\n'h' = 2ℎ+1 −1\n•Minimum nodes in a Binary tree= h+1\n•The minimum possible height for  N nodes\nis ⌊𝐥𝐥𝐥𝐥𝐥𝐥𝟐𝟐N⌋\n•Total number of unlabelled binary tree wi th n\nnode = 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1\n•Total  number of labelled binary tree = 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1 ×\n𝑛𝑛!\n•Total number of the binary tree wi…\n[p9:c15] Postorder\nLeft Subtree → Right Subtree → Node\nHeap\nA Heap is a special Complete Binary Tree where\nevery level is completely filled except possibly the last\nlevel, and nodes are as far left as possible.\nMin Heap\nThe value of each node is less than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| < | left tree, right tree|  Root = Minimum element\npostorder(node) {\ni…", "draft_gold_answer": "on the 1d array. Sparse Matrix A sparse matrix is a matrix in which most of the elements are zero . If the number of zero elements > number of non-zero elements, the matrix is sparse. Lower Triangular Matrix A lower triangular matrix is a square matrix where a…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 5 key concepts covered.", "gold_answer": "'s not present, even though 24 is at index 5. •This happens because deletion breaks t he probing chain, causing search failure. •This may require the rehashing. • Separate chaining A collision resolution technique where each slot in the hash table stores a lin…", "gold_evidence": "[p14:c24] 's not present, even though 24 is at\nindex 5.\n•This happens because deletion breaks t he\nprobing chain, causing search failure.\n•This may require the rehashing.\n•\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (or tail) of…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p12:c19] he root (maximum) wi th the\nlast element.\noReduce the heap size by 1.\noHeapify  the root element to restor e\nthe m ax heap.\n3. The array will be sorted in ascending\norder.\nTime Complexity:\n•Build Heap: O(n)\n•Heapify (n times): O(n log n)\n•Overall: O(n log n)Heap Sort uses a Max Heap (for ascending order\nsorting).\nSteps:\n4.Build a Max Heap from the…\n[p13:c21] graph\nDepth -First Search (DFS)\n•Explores as deep as possible\n•Uses stack (explicit or recursion)\n•Backtracks when no unvisited neighbours\nAlgorithm:\n1.Mark current node visited\n2.Recursively visit all unvisited neighbours\nTime Complexity:\n•O (V + E)\nApplications:\n•Topological sorting (DAG)\n•Cycle detection\n•Strongly Connected Component s\n•Maze/pat…", "draft_gold_evidence": "[p14:c24] 's not present, even though 24 is at\nindex 5.\n•This happens because deletion breaks t he\nprobing chain, causing search failure.\n•This may require the rehashing.\n•\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (or tail) of…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p12:c19] he root (maximum) wi th the\nlast element.\noReduce the heap size by 1.\noHeapify  the root element to restor e\nthe m ax heap.\n3. The array will be sorted in ascending\norder.\nTime Complexity:\n•Build Heap: O(n)\n•Heapify (n times): O(n log n)\n•Overall: O(n log n)Heap Sort uses a Max Heap (for ascending order\nsorting).\nSteps:\n4.Build a Max Heap from the…\n[p13:c21] graph\nDepth -First Search (DFS)\n•Explores as deep as possible\n•Uses stack (explicit or recursion)\n•Backtracks when no unvisited neighbours\nAlgorithm:\n1.Mark current node visited\n2.Recursively visit all unvisited neighbours\nTime Complexity:\n•O (V + E)\nApplications:\n•Topological sorting (DAG)\n•Cycle detection\n•Strongly Connected Component s\n•Maze/pat…", "draft_gold_answer": "'s not present, even though 24 is at index 5. •This happens because deletion breaks t he probing chain, causing search failure. •This may require the rehashing. • Separate chaining A collision resolution technique where each slot in the hash table stores a lin…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Define two important terms exactly as stated in the notes.", "gold_answer": "ase 1: Node has no children (Leaf Node) oSimply remove the node. oNo tree structure change. 2.Case 2: Node has one ch ild oReplace the node with its only child . oMaintain the link with the parent. 3.Case 3: Node has two children oReplace the node with its: I…", "gold_evidence": "[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p6:c9] Binary tree\nK-ary Tree:\nA K-ary tree  is a tree in which every internal node ha s\neither 0 or exactly K children.\nLet:\n•N = Total number of nodes\n•L = Number of leaf nodes\n•I = Number of internal nodes\n•K = Maximum number of children per internal\nnode\nRelationship:\nEach internal node has exactly K children:\nN=K⋅ I+1\nAlso, total number of nodes is t…\n[p13:c20] Graph Representations  Graph Traversals\nGraph traversal refers to visiting all the vertices (and\noptionally edges) of a graph in a systematic way.\n•BFS (Queue): Level -order, shortest path i n\nunweighted graph\n•DFS (Stack/Recursion): Deepest first, used i n\ncycle detection, topological sort\nBreadth -First Search (BFS)\nLevel-wise traversal\nUses a qu…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…", "draft_gold_evidence": "[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p6:c9] Binary tree\nK-ary Tree:\nA K-ary tree  is a tree in which every internal node ha s\neither 0 or exactly K children.\nLet:\n•N = Total number of nodes\n•L = Number of leaf nodes\n•I = Number of internal nodes\n•K = Maximum number of children per internal\nnode\nRelationship:\nEach internal node has exactly K children:\nN=K⋅ I+1\nAlso, total number of nodes is t…\n[p13:c20] Graph Representations  Graph Traversals\nGraph traversal refers to visiting all the vertices (and\noptionally edges) of a graph in a systematic way.\n•BFS (Queue): Level -order, shortest path i n\nunweighted graph\n•DFS (Stack/Recursion): Deepest first, used i n\ncycle detection, topological sort\nBreadth -First Search (BFS)\nLevel-wise traversal\nUses a qu…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…", "draft_gold_answer": "ase 1: Node has no children (Leaf Node) oSimply remove the node. oNo tree structure change. 2.Case 2: Node has one ch ild oReplace the node with its only child . oMaintain the link with the parent. 3.Case 3: Node has two children oReplace the node with its: I…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Write one formula/equation mentioned in the notes (as written).", "gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…", "gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p2:c1] on the 1d array.  Sparse Matrix\nA sparse matrix  is a matrix in which most of the\nelements are zero .\nIf the number of zero elements > number of non-zero\nelements, the matrix is sparse.\nLower Triangular Matrix\nA lower triangular matrix is a square matrix where\nall elements above the main diagonal are zero .\nA[i][j] = 0 for all i < j\nMust be square…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…", "draft_gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p2:c1] on the 1d array.  Sparse Matrix\nA sparse matrix  is a matrix in which most of the\nelements are zero .\nIf the number of zero elements > number of non-zero\nelements, the matrix is sparse.\nLower Triangular Matrix\nA lower triangular matrix is a square matrix where\nall elements above the main diagonal are zero .\nA[i][j] = 0 for all i < j\nMust be square…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…", "draft_gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List the steps of one algorithm/procedure described in the notes.", "gold_answer": "'s not present, even though 24 is at index 5. •This happens because deletion breaks t he probing chain, causing search failure. •This may require the rehashing. • Separate chaining A collision resolution technique where each slot in the hash table stores a lin…", "gold_evidence": "[p14:c24] 's not present, even though 24 is at\nindex 5.\n•This happens because deletion breaks t he\nprobing chain, causing search failure.\n•This may require the rehashing.\n•\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (or tail) of…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p13:c20] Graph Representations  Graph Traversals\nGraph traversal refers to visiting all the vertices (and\noptionally edges) of a graph in a systematic way.\n•BFS (Queue): Level -order, shortest path i n\nunweighted graph\n•DFS (Stack/Recursion): Deepest first, used i n\ncycle detection, topological sort\nBreadth -First Search (BFS)\nLevel-wise traversal\nUses a qu…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…", "draft_gold_evidence": "[p14:c24] 's not present, even though 24 is at\nindex 5.\n•This happens because deletion breaks t he\nprobing chain, causing search failure.\n•This may require the rehashing.\n•\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (or tail) of…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p13:c20] Graph Representations  Graph Traversals\nGraph traversal refers to visiting all the vertices (and\noptionally edges) of a graph in a systematic way.\n•BFS (Queue): Level -order, shortest path i n\nunweighted graph\n•DFS (Stack/Recursion): Deepest first, used i n\ncycle detection, topological sort\nBreadth -First Search (BFS)\nLevel-wise traversal\nUses a qu…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…", "draft_gold_answer": "'s not present, even though 24 is at index 5. •This happens because deletion breaks t he probing chain, causing search failure. •This may require the rehashing. • Separate chaining A collision resolution technique where each slot in the hash table stores a lin…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Compare two related concepts/methods mentioned (give at least one difference).", "gold_answer": "ase 1: Node has no children (Leaf Node) oSimply remove the node. oNo tree structure change. 2.Case 2: Node has one ch ild oReplace the node with its only child . oMaintain the link with the parent. 3.Case 3: Node has two children oReplace the node with its: I…", "gold_evidence": "[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…", "draft_gold_evidence": "[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…", "draft_gold_answer": "ase 1: Node has no children (Leaf Node) oSimply remove the node. oNo tree structure change. 2.Case 2: Node has one ch ild oReplace the node with its only child . oMaintain the link with the parent. 3.Case 3: Node has two children oReplace the node with its: I…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List any assumptions, prerequisites, or constraints mentioned.", "gold_answer": "'s not present, even though 24 is at index 5. •This happens because deletion breaks t he probing chain, causing search failure. •This may require the rehashing. • Separate chaining A collision resolution technique where each slot in the hash table stores a lin…", "gold_evidence": "[p14:c24] 's not present, even though 24 is at\nindex 5.\n•This happens because deletion breaks t he\nprobing chain, causing search failure.\n•This may require the rehashing.\n•\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (or tail) of…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p6:c9] Binary tree\nK-ary Tree:\nA K-ary tree  is a tree in which every internal node ha s\neither 0 or exactly K children.\nLet:\n•N = Total number of nodes\n•L = Number of leaf nodes\n•I = Number of internal nodes\n•K = Maximum number of children per internal\nnode\nRelationship:\nEach internal node has exactly K children:\nN=K⋅ I+1\nAlso, total number of nodes is t…\n[p13:c21] graph\nDepth -First Search (DFS)\n•Explores as deep as possible\n•Uses stack (explicit or recursion)\n•Backtracks when no unvisited neighbours\nAlgorithm:\n1.Mark current node visited\n2.Recursively visit all unvisited neighbours\nTime Complexity:\n•O (V + E)\nApplications:\n•Topological sorting (DAG)\n•Cycle detection\n•Strongly Connected Component s\n•Maze/pat…", "draft_gold_evidence": "[p14:c24] 's not present, even though 24 is at\nindex 5.\n•This happens because deletion breaks t he\nprobing chain, causing search failure.\n•This may require the rehashing.\n•\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (or tail) of…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p6:c9] Binary tree\nK-ary Tree:\nA K-ary tree  is a tree in which every internal node ha s\neither 0 or exactly K children.\nLet:\n•N = Total number of nodes\n•L = Number of leaf nodes\n•I = Number of internal nodes\n•K = Maximum number of children per internal\nnode\nRelationship:\nEach internal node has exactly K children:\nN=K⋅ I+1\nAlso, total number of nodes is t…\n[p13:c21] graph\nDepth -First Search (DFS)\n•Explores as deep as possible\n•Uses stack (explicit or recursion)\n•Backtracks when no unvisited neighbours\nAlgorithm:\n1.Mark current node visited\n2.Recursively visit all unvisited neighbours\nTime Complexity:\n•O (V + E)\nApplications:\n•Topological sorting (DAG)\n•Cycle detection\n•Strongly Connected Component s\n•Maze/pat…", "draft_gold_answer": "'s not present, even though 24 is at index 5. •This happens because deletion breaks t he probing chain, causing search failure. •This may require the rehashing. • Separate chaining A collision resolution technique where each slot in the hash table stores a lin…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Give one example mentioned in the notes.", "gold_answer": "ase 1: Node has no children (Leaf Node) oSimply remove the node. oNo tree structure change. 2.Case 2: Node has one ch ild oReplace the node with its only child . oMaintain the link with the parent. 3.Case 3: Node has two children oReplace the node with its: I…", "gold_evidence": "[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p5:c8] the last (left to right)\nPerfect Binary\nTree  All internal nodes have 2\nchildren & all leaves are at the\nsame level\nBalanced Tree  Height ≈ log(n), e.g. AVL tree\nBinary Search\nTree (B ST) Left < root < right\nAVL Tree  Height -balanced BST\nHeap  Complete binary tree (used in\nPQ)\nB-Tree  / B+\nTreeMulti -way trees for disk -based\nsearch\nDATA STRUCTURE…", "draft_gold_evidence": "[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p5:c8] the last (left to right)\nPerfect Binary\nTree  All internal nodes have 2\nchildren & all leaves are at the\nsame level\nBalanced Tree  Height ≈ log(n), e.g. AVL tree\nBinary Search\nTree (B ST) Left < root < right\nAVL Tree  Height -balanced BST\nHeap  Complete binary tree (used in\nPQ)\nB-Tree  / B+\nTreeMulti -way trees for disk -based\nsearch\nDATA STRUCTURE…", "draft_gold_answer": "ase 1: Node has no children (Leaf Node) oSimply remove the node. oNo tree structure change. 2.Case 2: Node has one ch ild oReplace the node with its only child . oMaintain the link with the parent. 3.Case 3: Node has two children oReplace the node with its: I…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What are the advantages and limitations of the main method/topic (as stated)?", "gold_answer": "Postorder Left Subtree → Right Subtree → Node Heap A Heap is a special Complete Binary Tree where every level is completely filled except possibly the last level, and nodes are as far left as possible. Min Heap The value of each node is less than or equal to i…", "gold_evidence": "[p9:c15] Postorder\nLeft Subtree → Right Subtree → Node\nHeap\nA Heap is a special Complete Binary Tree where\nevery level is completely filled except possibly the last\nlevel, and nodes are as far left as possible.\nMin Heap\nThe value of each node is less than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| < | left tree, right tree|  Root = Minimum element\npostorder(node) {\ni…\n[p3:c3] Tridiagonal matrix\nA tridiagonal matrix  is a square matrix where non-\nzero elements exist only on the main diagonal, just\nabove it , and just below it.\nA[i][j] ≠ 0 only if i == j, i == j+1, or i == j –1\nElse, A[i][j] = 0\nSum of all the element is 3n -2.\nA linked list  is a linear data structure where elements\n(called nodes ) are stored in non -con…\n[p2:c1] on the 1d array.  Sparse Matrix\nA sparse matrix  is a matrix in which most of the\nelements are zero .\nIf the number of zero elements > number of non-zero\nelements, the matrix is sparse.\nLower Triangular Matrix\nA lower triangular matrix is a square matrix where\nall elements above the main diagonal are zero .\nA[i][j] = 0 for all i < j\nMust be square…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…", "draft_gold_evidence": "[p9:c15] Postorder\nLeft Subtree → Right Subtree → Node\nHeap\nA Heap is a special Complete Binary Tree where\nevery level is completely filled except possibly the last\nlevel, and nodes are as far left as possible.\nMin Heap\nThe value of each node is less than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| < | left tree, right tree|  Root = Minimum element\npostorder(node) {\ni…\n[p3:c3] Tridiagonal matrix\nA tridiagonal matrix  is a square matrix where non-\nzero elements exist only on the main diagonal, just\nabove it , and just below it.\nA[i][j] ≠ 0 only if i == j, i == j+1, or i == j –1\nElse, A[i][j] = 0\nSum of all the element is 3n -2.\nA linked list  is a linear data structure where elements\n(called nodes ) are stored in non -con…\n[p2:c1] on the 1d array.  Sparse Matrix\nA sparse matrix  is a matrix in which most of the\nelements are zero .\nIf the number of zero elements > number of non-zero\nelements, the matrix is sparse.\nLower Triangular Matrix\nA lower triangular matrix is a square matrix where\nall elements above the main diagonal are zero .\nA[i][j] = 0 for all i < j\nMust be square…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…", "draft_gold_answer": "Postorder Left Subtree → Right Subtree → Node Heap A Heap is a special Complete Binary Tree where every level is completely filled except possibly the last level, and nodes are as far left as possible. Min Heap The value of each node is less than or equal to i…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Summarize the key takeaways in 3 bullet points.", "gold_answer": "he root (maximum) wi th the last element. oReduce the heap size by 1. oHeapify the root element to restor e the m ax heap. 3. The array will be sorted in ascending order. Time Complexity: •Build Heap: O(n) •Heapify (n times): O(n log n) •Overall: O(n log n)Hea…", "gold_evidence": "[p12:c19] he root (maximum) wi th the\nlast element.\noReduce the heap size by 1.\noHeapify  the root element to restor e\nthe m ax heap.\n3. The array will be sorted in ascending\norder.\nTime Complexity:\n•Build Heap: O(n)\n•Heapify (n times): O(n log n)\n•Overall: O(n log n)Heap Sort uses a Max Heap (for ascending order\nsorting).\nSteps:\n4.Build a Max Heap from the…\n[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p4:c5] lity\n•Backtracking (like maze, Sudoku)\n•Number of possible stack permutations\n= 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE फर्रे\nPage No:- 03\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…", "draft_gold_evidence": "[p12:c19] he root (maximum) wi th the\nlast element.\noReduce the heap size by 1.\noHeapify  the root element to restor e\nthe m ax heap.\n3. The array will be sorted in ascending\norder.\nTime Complexity:\n•Build Heap: O(n)\n•Heapify (n times): O(n log n)\n•Overall: O(n log n)Heap Sort uses a Max Heap (for ascending order\nsorting).\nSteps:\n4.Build a Max Heap from the…\n[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p4:c5] lity\n•Backtracking (like maze, Sudoku)\n•Number of possible stack permutations\n= 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE फर्रे\nPage No:- 03\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…", "draft_gold_answer": "he root (maximum) wi th the last element. oReduce the heap size by 1. oHeapify the root element to restor e the m ax heap. 3. The array will be sorted in ascending order. Time Complexity: •Build Heap: O(n) •Heapify (n times): O(n log n) •Overall: O(n log n)Hea…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Is there any deadline/submission instruction in the document? If not, answer 'Not found in the document.'", "gold_answer": "Search : Hash the key to find the index, then linearl y search the linked list at that index. Deletion : Hash the key, search the linked list, and remove the node if found. No Clustering : Since elements are in separate lists, primary/secondary clustering does…", "gold_evidence": "[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p8:c14] height h\nLL, RR are single rotations\nLR, RL are double rotations.\nWe check the balance factor from  bottom to top, if\nwe find any  node not following the properties then\nwe do the rotations.\ninorder(node) {\nif (node == NULL) return;\ninorder(node->left);\nvisit(node);\ninorder(node->right);\n}\nInorder: 20 10 30\npreorder(node) {\nif (node == NULL) return…", "draft_gold_evidence": "[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p8:c14] height h\nLL, RR are single rotations\nLR, RL are double rotations.\nWe check the balance factor from  bottom to top, if\nwe find any  node not following the properties then\nwe do the rotations.\ninorder(node) {\nif (node == NULL) return;\ninorder(node->left);\nvisit(node);\ninorder(node->right);\n}\nInorder: 20 10 30\npreorder(node) {\nif (node == NULL) return…", "draft_gold_answer": "Search : Hash the key to find the index, then linearl y search the linked list at that index. Deletion : Hash the key, search the linked list, and remove the node if found. No Clustering : Since elements are in separate lists, primary/secondary clustering does…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one definition stated in the notes? Quote it exactly if present; otherwise answer 'Not found in the document.'", "gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…", "gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p14:c23] y clustering\nProblem : May lead to secondary clustering\nCan fail to insert even when space exists if not\ncarefully designed\nIn double hashing h2(k) should not be 0, otherwise it becomes the linear probing.\nDeletion Problem in Open Addressing (Linear,\nQuadratic, Double Hashing)\nIn open addressing , when you delete an element,\nsimply marking the slot…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…", "draft_gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p14:c23] y clustering\nProblem : May lead to secondary clustering\nCan fail to insert even when space exists if not\ncarefully designed\nIn double hashing h2(k) should not be 0, otherwise it becomes the linear probing.\nDeletion Problem in Open Addressing (Linear,\nQuadratic, Double Hashing)\nIn open addressing , when you delete an element,\nsimply marking the slot…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…", "draft_gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the time complexity of one algorithm mentioned (as stated)? If not present, answer 'Not found in the document.'", "gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…", "gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p10:c17] will\nbe found i n the leaf nodes, so the tim e\ncomplexity to find it is O(n) .\n•The number of leaf nodes in a heap is\nceil(n/2).\n•The minimum element  in a Max Heap will\nbe found i n the leaf nodes, so the time\ncomplexity is also O(n) .\n•Heap Sort repeatedly deletes the ro ot\nelement and re-heapifies the remaini ng\nheap, s o the total time complexi…\n[p2:c1] on the 1d array.  Sparse Matrix\nA sparse matrix  is a matrix in which most of the\nelements are zero .\nIf the number of zero elements > number of non-zero\nelements, the matrix is sparse.\nLower Triangular Matrix\nA lower triangular matrix is a square matrix where\nall elements above the main diagonal are zero .\nA[i][j] = 0 for all i < j\nMust be square…\n[p13:c20] Graph Representations  Graph Traversals\nGraph traversal refers to visiting all the vertices (and\noptionally edges) of a graph in a systematic way.\n•BFS (Queue): Level -order, shortest path i n\nunweighted graph\n•DFS (Stack/Recursion): Deepest first, used i n\ncycle detection, topological sort\nBreadth -First Search (BFS)\nLevel-wise traversal\nUses a qu…", "draft_gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p10:c17] will\nbe found i n the leaf nodes, so the tim e\ncomplexity to find it is O(n) .\n•The number of leaf nodes in a heap is\nceil(n/2).\n•The minimum element  in a Max Heap will\nbe found i n the leaf nodes, so the time\ncomplexity is also O(n) .\n•Heap Sort repeatedly deletes the ro ot\nelement and re-heapifies the remaini ng\nheap, s o the total time complexi…\n[p2:c1] on the 1d array.  Sparse Matrix\nA sparse matrix  is a matrix in which most of the\nelements are zero .\nIf the number of zero elements > number of non-zero\nelements, the matrix is sparse.\nLower Triangular Matrix\nA lower triangular matrix is a square matrix where\nall elements above the main diagonal are zero .\nA[i][j] = 0 for all i < j\nMust be square…\n[p13:c20] Graph Representations  Graph Traversals\nGraph traversal refers to visiting all the vertices (and\noptionally edges) of a graph in a systematic way.\n•BFS (Queue): Level -order, shortest path i n\nunweighted graph\n•DFS (Stack/Recursion): Deepest first, used i n\ncycle detection, topological sort\nBreadth -First Search (BFS)\nLevel-wise traversal\nUses a qu…", "draft_gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 3 important keywords/terms that appear in the notes.", "gold_answer": "Search : Hash the key to find the index, then linearl y search the linked list at that index. Deletion : Hash the key, search the linked list, and remove the node if found. No Clustering : Since elements are in separate lists, primary/secondary clustering does…", "gold_evidence": "[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p3:c3] Tridiagonal matrix\nA tridiagonal matrix  is a square matrix where non-\nzero elements exist only on the main diagonal, just\nabove it , and just below it.\nA[i][j] ≠ 0 only if i == j, i == j+1, or i == j –1\nElse, A[i][j] = 0\nSum of all the element is 3n -2.\nA linked list  is a linear data structure where elements\n(called nodes ) are stored in non -con…\n[p4:c4] Implementation Methods:\n1.Using Array  (Fixed size, static memory)\n2.Using Linked List  (Dynamic size)Queue\nA Queue  is a linear data structure that follows the\nFIFO  principle:\nFirst In, First Out\nThe first element inserted is the first to be removed.\nReal-World Examples:\n•Ticket line\n•Print queue\nCPU task scheduling  Operation  Description  Time…\n[p12:c18] Graph\nA graph  is a collection of vertices (nodes)  and edges\n(connections)  that represent relationships between\npairs of objects.\nG= (V, E)\nWhere:\n•V = set of vertices\n•E = set of edges (unordered pair fo r\nundirected, ordered for directed)Deletion is mostly done at the root node  (i.e.,\nthe max in Max Heap or min in Min Heap).\nSteps:\n1.Remove th…", "draft_gold_evidence": "[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p3:c3] Tridiagonal matrix\nA tridiagonal matrix  is a square matrix where non-\nzero elements exist only on the main diagonal, just\nabove it , and just below it.\nA[i][j] ≠ 0 only if i == j, i == j+1, or i == j –1\nElse, A[i][j] = 0\nSum of all the element is 3n -2.\nA linked list  is a linear data structure where elements\n(called nodes ) are stored in non -con…\n[p4:c4] Implementation Methods:\n1.Using Array  (Fixed size, static memory)\n2.Using Linked List  (Dynamic size)Queue\nA Queue  is a linear data structure that follows the\nFIFO  principle:\nFirst In, First Out\nThe first element inserted is the first to be removed.\nReal-World Examples:\n•Ticket line\n•Print queue\nCPU task scheduling  Operation  Description  Time…\n[p12:c18] Graph\nA graph  is a collection of vertices (nodes)  and edges\n(connections)  that represent relationships between\npairs of objects.\nG= (V, E)\nWhere:\n•V = set of vertices\n•E = set of edges (unordered pair fo r\nundirected, ordered for directed)Deletion is mostly done at the root node  (i.e.,\nthe max in Max Heap or min in Min Heap).\nSteps:\n1.Remove th…", "draft_gold_answer": "Search : Hash the key to find the index, then linearl y search the linked list at that index. Deletion : Hash the key, search the linked list, and remove the node if found. No Clustering : Since elements are in separate lists, primary/secondary clustering does…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one theorem/lemma/property stated? If not present, answer 'Not found in the document.'", "gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…", "gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p14:c23] y clustering\nProblem : May lead to secondary clustering\nCan fail to insert even when space exists if not\ncarefully designed\nIn double hashing h2(k) should not be 0, otherwise it becomes the linear probing.\nDeletion Problem in Open Addressing (Linear,\nQuadratic, Double Hashing)\nIn open addressing , when you delete an element,\nsimply marking the slot…", "draft_gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p14:c23] y clustering\nProblem : May lead to secondary clustering\nCan fail to insert even when space exists if not\ncarefully designed\nIn double hashing h2(k) should not be 0, otherwise it becomes the linear probing.\nDeletion Problem in Open Addressing (Linear,\nQuadratic, Double Hashing)\nIn open addressing , when you delete an element,\nsimply marking the slot…", "draft_gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Describe one table/list mentioned (what items are compared or listed). If none, answer 'Not found in the document.'", "gold_answer": "Search : Hash the key to find the index, then linearl y search the linked list at that index. Deletion : Hash the key, search the linked list, and remove the node if found. No Clustering : Since elements are in separate lists, primary/secondary clustering does…", "gold_evidence": "[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p14:c24] 's not present, even though 24 is at\nindex 5.\n•This happens because deletion breaks t he\nprobing chain, causing search failure.\n•This may require the rehashing.\n•\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (or tail) of…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…", "draft_gold_evidence": "[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p14:c24] 's not present, even though 24 is at\nindex 5.\n•This happens because deletion breaks t he\nprobing chain, causing search failure.\n•This may require the rehashing.\n•\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (or tail) of…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…", "draft_gold_answer": "Search : Hash the key to find the index, then linearl y search the linked list at that index. Deletion : Hash the key, search the linked list, and remove the node if found. No Clustering : Since elements are in separate lists, primary/secondary clustering does…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one stated limitation/constraint? If none, answer 'Not found in the document.'", "gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…", "gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…", "draft_gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…", "draft_gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one stated advantage/benefit? If none, answer 'Not found in the document.'", "gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…", "gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…", "draft_gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…", "draft_gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Provide one short quote (1–2 sentences) from the notes that best represents the topic.", "gold_answer": "ase 1: Node has no children (Leaf Node) oSimply remove the node. oNo tree structure change. 2.Case 2: Node has one ch ild oReplace the node with its only child . oMaintain the link with the parent. 3.Case 3: Node has two children oReplace the node with its: I…", "gold_evidence": "[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p6:c10] d from any node and its\ndescendants\n•Maximum Nodes in a Binary Tree of Hei ght\n'h' = 2ℎ+1 −1\n•Minimum nodes in a Binary tree= h+1\n•The minimum possible height for  N nodes\nis ⌊𝐥𝐥𝐥𝐥𝐥𝐥𝟐𝟐N⌋\n•Total number of unlabelled binary tree wi th n\nnode = 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1\n•Total  number of labelled binary tree = 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1 ×\n𝑛𝑛!\n•Total number of the binary tree wi…\n[p4:c5] lity\n•Backtracking (like maze, Sudoku)\n•Number of possible stack permutations\n= 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE फर्रे\nPage No:- 03", "draft_gold_evidence": "[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p6:c10] d from any node and its\ndescendants\n•Maximum Nodes in a Binary Tree of Hei ght\n'h' = 2ℎ+1 −1\n•Minimum nodes in a Binary tree= h+1\n•The minimum possible height for  N nodes\nis ⌊𝐥𝐥𝐥𝐥𝐥𝐥𝟐𝟐N⌋\n•Total number of unlabelled binary tree wi th n\nnode = 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1\n•Total  number of labelled binary tree = 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1 ×\n𝑛𝑛!\n•Total number of the binary tree wi…\n[p4:c5] lity\n•Backtracking (like maze, Sudoku)\n•Number of possible stack permutations\n= 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE फर्रे\nPage No:- 03", "draft_gold_answer": "ase 1: Node has no children (Leaf Node) oSimply remove the node. oNo tree structure change. 2.Case 2: Node has one ch ild oReplace the node with its only child . oMaintain the link with the parent. 3.Case 3: Node has two children oReplace the node with its: I…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/DATA-STRUCTURE-SHORT-NOTES_compressed.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one abbreviation/acronym expanded in the notes? If none, answer 'Not found in the document.'", "gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…", "gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…", "draft_gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…", "draft_gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the main topic of these notes?", "gold_answer": "on the 1d array. Sparse Matrix A sparse matrix is a matrix in which most of the elements are zero . If the number of zero elements > number of non-zero elements, the matrix is sparse. Lower Triangular Matrix A lower triangular matrix is a square matrix where a…", "gold_evidence": "[p2:c1] on the 1d array.  Sparse Matrix\nA sparse matrix  is a matrix in which most of the\nelements are zero .\nIf the number of zero elements > number of non-zero\nelements, the matrix is sparse.\nLower Triangular Matrix\nA lower triangular matrix is a square matrix where\nall elements above the main diagonal are zero .\nA[i][j] = 0 for all i < j\nMust be square…\n[p3:c3] Tridiagonal matrix\nA tridiagonal matrix  is a square matrix where non-\nzero elements exist only on the main diagonal, just\nabove it , and just below it.\nA[i][j] ≠ 0 only if i == j, i == j+1, or i == j –1\nElse, A[i][j] = 0\nSum of all the element is 3n -2.\nA linked list  is a linear data structure where elements\n(called nodes ) are stored in non -con…\n[p6:c10] d from any node and its\ndescendants\n•Maximum Nodes in a Binary Tree of Hei ght\n'h' = 2ℎ+1 −1\n•Minimum nodes in a Binary tree= h+1\n•The minimum possible height for  N nodes\nis ⌊𝐥𝐥𝐥𝐥𝐥𝐥𝟐𝟐N⌋\n•Total number of unlabelled binary tree wi th n\nnode = 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1\n•Total  number of labelled binary tree = 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1 ×\n𝑛𝑛!\n•Total number of the binary tree wi…\n[p9:c15] Postorder\nLeft Subtree → Right Subtree → Node\nHeap\nA Heap is a special Complete Binary Tree where\nevery level is completely filled except possibly the last\nlevel, and nodes are as far left as possible.\nMin Heap\nThe value of each node is less than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| < | left tree, right tree|  Root = Minimum element\npostorder(node) {\ni…", "draft_gold_evidence": "[p2:c1] on the 1d array.  Sparse Matrix\nA sparse matrix  is a matrix in which most of the\nelements are zero .\nIf the number of zero elements > number of non-zero\nelements, the matrix is sparse.\nLower Triangular Matrix\nA lower triangular matrix is a square matrix where\nall elements above the main diagonal are zero .\nA[i][j] = 0 for all i < j\nMust be square…\n[p3:c3] Tridiagonal matrix\nA tridiagonal matrix  is a square matrix where non-\nzero elements exist only on the main diagonal, just\nabove it , and just below it.\nA[i][j] ≠ 0 only if i == j, i == j+1, or i == j –1\nElse, A[i][j] = 0\nSum of all the element is 3n -2.\nA linked list  is a linear data structure where elements\n(called nodes ) are stored in non -con…\n[p6:c10] d from any node and its\ndescendants\n•Maximum Nodes in a Binary Tree of Hei ght\n'h' = 2ℎ+1 −1\n•Minimum nodes in a Binary tree= h+1\n•The minimum possible height for  N nodes\nis ⌊𝐥𝐥𝐥𝐥𝐥𝐥𝟐𝟐N⌋\n•Total number of unlabelled binary tree wi th n\nnode = 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1\n•Total  number of labelled binary tree = 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1 ×\n𝑛𝑛!\n•Total number of the binary tree wi…\n[p9:c15] Postorder\nLeft Subtree → Right Subtree → Node\nHeap\nA Heap is a special Complete Binary Tree where\nevery level is completely filled except possibly the last\nlevel, and nodes are as far left as possible.\nMin Heap\nThe value of each node is less than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| < | left tree, right tree|  Root = Minimum element\npostorder(node) {\ni…", "draft_gold_answer": "on the 1d array. Sparse Matrix A sparse matrix is a matrix in which most of the elements are zero . If the number of zero elements > number of non-zero elements, the matrix is sparse. Lower Triangular Matrix A lower triangular matrix is a square matrix where a…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 5 key concepts covered.", "gold_answer": "'s not present, even though 24 is at index 5. •This happens because deletion breaks t he probing chain, causing search failure. •This may require the rehashing. • Separate chaining A collision resolution technique where each slot in the hash table stores a lin…", "gold_evidence": "[p14:c24] 's not present, even though 24 is at\nindex 5.\n•This happens because deletion breaks t he\nprobing chain, causing search failure.\n•This may require the rehashing.\n•\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (or tail) of…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p12:c19] he root (maximum) wi th the\nlast element.\noReduce the heap size by 1.\noHeapify  the root element to restor e\nthe m ax heap.\n3. The array will be sorted in ascending\norder.\nTime Complexity:\n•Build Heap: O(n)\n•Heapify (n times): O(n log n)\n•Overall: O(n log n)Heap Sort uses a Max Heap (for ascending order\nsorting).\nSteps:\n4.Build a Max Heap from the…\n[p13:c21] graph\nDepth -First Search (DFS)\n•Explores as deep as possible\n•Uses stack (explicit or recursion)\n•Backtracks when no unvisited neighbours\nAlgorithm:\n1.Mark current node visited\n2.Recursively visit all unvisited neighbours\nTime Complexity:\n•O (V + E)\nApplications:\n•Topological sorting (DAG)\n•Cycle detection\n•Strongly Connected Component s\n•Maze/pat…", "draft_gold_evidence": "[p14:c24] 's not present, even though 24 is at\nindex 5.\n•This happens because deletion breaks t he\nprobing chain, causing search failure.\n•This may require the rehashing.\n•\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (or tail) of…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p12:c19] he root (maximum) wi th the\nlast element.\noReduce the heap size by 1.\noHeapify  the root element to restor e\nthe m ax heap.\n3. The array will be sorted in ascending\norder.\nTime Complexity:\n•Build Heap: O(n)\n•Heapify (n times): O(n log n)\n•Overall: O(n log n)Heap Sort uses a Max Heap (for ascending order\nsorting).\nSteps:\n4.Build a Max Heap from the…\n[p13:c21] graph\nDepth -First Search (DFS)\n•Explores as deep as possible\n•Uses stack (explicit or recursion)\n•Backtracks when no unvisited neighbours\nAlgorithm:\n1.Mark current node visited\n2.Recursively visit all unvisited neighbours\nTime Complexity:\n•O (V + E)\nApplications:\n•Topological sorting (DAG)\n•Cycle detection\n•Strongly Connected Component s\n•Maze/pat…", "draft_gold_answer": "'s not present, even though 24 is at index 5. •This happens because deletion breaks t he probing chain, causing search failure. •This may require the rehashing. • Separate chaining A collision resolution technique where each slot in the hash table stores a lin…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Define two important terms exactly as stated in the notes.", "gold_answer": "ase 1: Node has no children (Leaf Node) oSimply remove the node. oNo tree structure change. 2.Case 2: Node has one ch ild oReplace the node with its only child . oMaintain the link with the parent. 3.Case 3: Node has two children oReplace the node with its: I…", "gold_evidence": "[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p6:c9] Binary tree\nK-ary Tree:\nA K-ary tree  is a tree in which every internal node ha s\neither 0 or exactly K children.\nLet:\n•N = Total number of nodes\n•L = Number of leaf nodes\n•I = Number of internal nodes\n•K = Maximum number of children per internal\nnode\nRelationship:\nEach internal node has exactly K children:\nN=K⋅ I+1\nAlso, total number of nodes is t…\n[p13:c20] Graph Representations  Graph Traversals\nGraph traversal refers to visiting all the vertices (and\noptionally edges) of a graph in a systematic way.\n•BFS (Queue): Level -order, shortest path i n\nunweighted graph\n•DFS (Stack/Recursion): Deepest first, used i n\ncycle detection, topological sort\nBreadth -First Search (BFS)\nLevel-wise traversal\nUses a qu…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…", "draft_gold_evidence": "[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p6:c9] Binary tree\nK-ary Tree:\nA K-ary tree  is a tree in which every internal node ha s\neither 0 or exactly K children.\nLet:\n•N = Total number of nodes\n•L = Number of leaf nodes\n•I = Number of internal nodes\n•K = Maximum number of children per internal\nnode\nRelationship:\nEach internal node has exactly K children:\nN=K⋅ I+1\nAlso, total number of nodes is t…\n[p13:c20] Graph Representations  Graph Traversals\nGraph traversal refers to visiting all the vertices (and\noptionally edges) of a graph in a systematic way.\n•BFS (Queue): Level -order, shortest path i n\nunweighted graph\n•DFS (Stack/Recursion): Deepest first, used i n\ncycle detection, topological sort\nBreadth -First Search (BFS)\nLevel-wise traversal\nUses a qu…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…", "draft_gold_answer": "ase 1: Node has no children (Leaf Node) oSimply remove the node. oNo tree structure change. 2.Case 2: Node has one ch ild oReplace the node with its only child . oMaintain the link with the parent. 3.Case 3: Node has two children oReplace the node with its: I…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Write one formula/equation mentioned in the notes (as written).", "gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…", "gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p2:c1] on the 1d array.  Sparse Matrix\nA sparse matrix  is a matrix in which most of the\nelements are zero .\nIf the number of zero elements > number of non-zero\nelements, the matrix is sparse.\nLower Triangular Matrix\nA lower triangular matrix is a square matrix where\nall elements above the main diagonal are zero .\nA[i][j] = 0 for all i < j\nMust be square…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…", "draft_gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p2:c1] on the 1d array.  Sparse Matrix\nA sparse matrix  is a matrix in which most of the\nelements are zero .\nIf the number of zero elements > number of non-zero\nelements, the matrix is sparse.\nLower Triangular Matrix\nA lower triangular matrix is a square matrix where\nall elements above the main diagonal are zero .\nA[i][j] = 0 for all i < j\nMust be square…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…", "draft_gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List the steps of one algorithm/procedure described in the notes.", "gold_answer": "'s not present, even though 24 is at index 5. •This happens because deletion breaks t he probing chain, causing search failure. •This may require the rehashing. • Separate chaining A collision resolution technique where each slot in the hash table stores a lin…", "gold_evidence": "[p14:c24] 's not present, even though 24 is at\nindex 5.\n•This happens because deletion breaks t he\nprobing chain, causing search failure.\n•This may require the rehashing.\n•\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (or tail) of…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p13:c20] Graph Representations  Graph Traversals\nGraph traversal refers to visiting all the vertices (and\noptionally edges) of a graph in a systematic way.\n•BFS (Queue): Level -order, shortest path i n\nunweighted graph\n•DFS (Stack/Recursion): Deepest first, used i n\ncycle detection, topological sort\nBreadth -First Search (BFS)\nLevel-wise traversal\nUses a qu…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…", "draft_gold_evidence": "[p14:c24] 's not present, even though 24 is at\nindex 5.\n•This happens because deletion breaks t he\nprobing chain, causing search failure.\n•This may require the rehashing.\n•\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (or tail) of…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p13:c20] Graph Representations  Graph Traversals\nGraph traversal refers to visiting all the vertices (and\noptionally edges) of a graph in a systematic way.\n•BFS (Queue): Level -order, shortest path i n\nunweighted graph\n•DFS (Stack/Recursion): Deepest first, used i n\ncycle detection, topological sort\nBreadth -First Search (BFS)\nLevel-wise traversal\nUses a qu…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…", "draft_gold_answer": "'s not present, even though 24 is at index 5. •This happens because deletion breaks t he probing chain, causing search failure. •This may require the rehashing. • Separate chaining A collision resolution technique where each slot in the hash table stores a lin…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Compare two related concepts/methods mentioned (give at least one difference).", "gold_answer": "ase 1: Node has no children (Leaf Node) oSimply remove the node. oNo tree structure change. 2.Case 2: Node has one ch ild oReplace the node with its only child . oMaintain the link with the parent. 3.Case 3: Node has two children oReplace the node with its: I…", "gold_evidence": "[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…", "draft_gold_evidence": "[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…", "draft_gold_answer": "ase 1: Node has no children (Leaf Node) oSimply remove the node. oNo tree structure change. 2.Case 2: Node has one ch ild oReplace the node with its only child . oMaintain the link with the parent. 3.Case 3: Node has two children oReplace the node with its: I…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List any assumptions, prerequisites, or constraints mentioned.", "gold_answer": "'s not present, even though 24 is at index 5. •This happens because deletion breaks t he probing chain, causing search failure. •This may require the rehashing. • Separate chaining A collision resolution technique where each slot in the hash table stores a lin…", "gold_evidence": "[p14:c24] 's not present, even though 24 is at\nindex 5.\n•This happens because deletion breaks t he\nprobing chain, causing search failure.\n•This may require the rehashing.\n•\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (or tail) of…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p6:c9] Binary tree\nK-ary Tree:\nA K-ary tree  is a tree in which every internal node ha s\neither 0 or exactly K children.\nLet:\n•N = Total number of nodes\n•L = Number of leaf nodes\n•I = Number of internal nodes\n•K = Maximum number of children per internal\nnode\nRelationship:\nEach internal node has exactly K children:\nN=K⋅ I+1\nAlso, total number of nodes is t…\n[p13:c21] graph\nDepth -First Search (DFS)\n•Explores as deep as possible\n•Uses stack (explicit or recursion)\n•Backtracks when no unvisited neighbours\nAlgorithm:\n1.Mark current node visited\n2.Recursively visit all unvisited neighbours\nTime Complexity:\n•O (V + E)\nApplications:\n•Topological sorting (DAG)\n•Cycle detection\n•Strongly Connected Component s\n•Maze/pat…", "draft_gold_evidence": "[p14:c24] 's not present, even though 24 is at\nindex 5.\n•This happens because deletion breaks t he\nprobing chain, causing search failure.\n•This may require the rehashing.\n•\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (or tail) of…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p6:c9] Binary tree\nK-ary Tree:\nA K-ary tree  is a tree in which every internal node ha s\neither 0 or exactly K children.\nLet:\n•N = Total number of nodes\n•L = Number of leaf nodes\n•I = Number of internal nodes\n•K = Maximum number of children per internal\nnode\nRelationship:\nEach internal node has exactly K children:\nN=K⋅ I+1\nAlso, total number of nodes is t…\n[p13:c21] graph\nDepth -First Search (DFS)\n•Explores as deep as possible\n•Uses stack (explicit or recursion)\n•Backtracks when no unvisited neighbours\nAlgorithm:\n1.Mark current node visited\n2.Recursively visit all unvisited neighbours\nTime Complexity:\n•O (V + E)\nApplications:\n•Topological sorting (DAG)\n•Cycle detection\n•Strongly Connected Component s\n•Maze/pat…", "draft_gold_answer": "'s not present, even though 24 is at index 5. •This happens because deletion breaks t he probing chain, causing search failure. •This may require the rehashing. • Separate chaining A collision resolution technique where each slot in the hash table stores a lin…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Give one example mentioned in the notes.", "gold_answer": "ase 1: Node has no children (Leaf Node) oSimply remove the node. oNo tree structure change. 2.Case 2: Node has one ch ild oReplace the node with its only child . oMaintain the link with the parent. 3.Case 3: Node has two children oReplace the node with its: I…", "gold_evidence": "[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p5:c8] the last (left to right)\nPerfect Binary\nTree  All internal nodes have 2\nchildren & all leaves are at the\nsame level\nBalanced Tree  Height ≈ log(n), e.g. AVL tree\nBinary Search\nTree (B ST) Left < root < right\nAVL Tree  Height -balanced BST\nHeap  Complete binary tree (used in\nPQ)\nB-Tree  / B+\nTreeMulti -way trees for disk -based\nsearch\nDATA STRUCTURE…", "draft_gold_evidence": "[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p5:c8] the last (left to right)\nPerfect Binary\nTree  All internal nodes have 2\nchildren & all leaves are at the\nsame level\nBalanced Tree  Height ≈ log(n), e.g. AVL tree\nBinary Search\nTree (B ST) Left < root < right\nAVL Tree  Height -balanced BST\nHeap  Complete binary tree (used in\nPQ)\nB-Tree  / B+\nTreeMulti -way trees for disk -based\nsearch\nDATA STRUCTURE…", "draft_gold_answer": "ase 1: Node has no children (Leaf Node) oSimply remove the node. oNo tree structure change. 2.Case 2: Node has one ch ild oReplace the node with its only child . oMaintain the link with the parent. 3.Case 3: Node has two children oReplace the node with its: I…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What are the advantages and limitations of the main method/topic (as stated)?", "gold_answer": "Postorder Left Subtree → Right Subtree → Node Heap A Heap is a special Complete Binary Tree where every level is completely filled except possibly the last level, and nodes are as far left as possible. Min Heap The value of each node is less than or equal to i…", "gold_evidence": "[p9:c15] Postorder\nLeft Subtree → Right Subtree → Node\nHeap\nA Heap is a special Complete Binary Tree where\nevery level is completely filled except possibly the last\nlevel, and nodes are as far left as possible.\nMin Heap\nThe value of each node is less than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| < | left tree, right tree|  Root = Minimum element\npostorder(node) {\ni…\n[p3:c3] Tridiagonal matrix\nA tridiagonal matrix  is a square matrix where non-\nzero elements exist only on the main diagonal, just\nabove it , and just below it.\nA[i][j] ≠ 0 only if i == j, i == j+1, or i == j –1\nElse, A[i][j] = 0\nSum of all the element is 3n -2.\nA linked list  is a linear data structure where elements\n(called nodes ) are stored in non -con…\n[p2:c1] on the 1d array.  Sparse Matrix\nA sparse matrix  is a matrix in which most of the\nelements are zero .\nIf the number of zero elements > number of non-zero\nelements, the matrix is sparse.\nLower Triangular Matrix\nA lower triangular matrix is a square matrix where\nall elements above the main diagonal are zero .\nA[i][j] = 0 for all i < j\nMust be square…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…", "draft_gold_evidence": "[p9:c15] Postorder\nLeft Subtree → Right Subtree → Node\nHeap\nA Heap is a special Complete Binary Tree where\nevery level is completely filled except possibly the last\nlevel, and nodes are as far left as possible.\nMin Heap\nThe value of each node is less than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| < | left tree, right tree|  Root = Minimum element\npostorder(node) {\ni…\n[p3:c3] Tridiagonal matrix\nA tridiagonal matrix  is a square matrix where non-\nzero elements exist only on the main diagonal, just\nabove it , and just below it.\nA[i][j] ≠ 0 only if i == j, i == j+1, or i == j –1\nElse, A[i][j] = 0\nSum of all the element is 3n -2.\nA linked list  is a linear data structure where elements\n(called nodes ) are stored in non -con…\n[p2:c1] on the 1d array.  Sparse Matrix\nA sparse matrix  is a matrix in which most of the\nelements are zero .\nIf the number of zero elements > number of non-zero\nelements, the matrix is sparse.\nLower Triangular Matrix\nA lower triangular matrix is a square matrix where\nall elements above the main diagonal are zero .\nA[i][j] = 0 for all i < j\nMust be square…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…", "draft_gold_answer": "Postorder Left Subtree → Right Subtree → Node Heap A Heap is a special Complete Binary Tree where every level is completely filled except possibly the last level, and nodes are as far left as possible. Min Heap The value of each node is less than or equal to i…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Summarize the key takeaways in 3 bullet points.", "gold_answer": "he root (maximum) wi th the last element. oReduce the heap size by 1. oHeapify the root element to restor e the m ax heap. 3. The array will be sorted in ascending order. Time Complexity: •Build Heap: O(n) •Heapify (n times): O(n log n) •Overall: O(n log n)Hea…", "gold_evidence": "[p12:c19] he root (maximum) wi th the\nlast element.\noReduce the heap size by 1.\noHeapify  the root element to restor e\nthe m ax heap.\n3. The array will be sorted in ascending\norder.\nTime Complexity:\n•Build Heap: O(n)\n•Heapify (n times): O(n log n)\n•Overall: O(n log n)Heap Sort uses a Max Heap (for ascending order\nsorting).\nSteps:\n4.Build a Max Heap from the…\n[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p4:c5] lity\n•Backtracking (like maze, Sudoku)\n•Number of possible stack permutations\n= 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE फर्रे\nPage No:- 03\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…", "draft_gold_evidence": "[p12:c19] he root (maximum) wi th the\nlast element.\noReduce the heap size by 1.\noHeapify  the root element to restor e\nthe m ax heap.\n3. The array will be sorted in ascending\norder.\nTime Complexity:\n•Build Heap: O(n)\n•Heapify (n times): O(n log n)\n•Overall: O(n log n)Heap Sort uses a Max Heap (for ascending order\nsorting).\nSteps:\n4.Build a Max Heap from the…\n[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p4:c5] lity\n•Backtracking (like maze, Sudoku)\n•Number of possible stack permutations\n= 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE फर्रे\nPage No:- 03\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…", "draft_gold_answer": "he root (maximum) wi th the last element. oReduce the heap size by 1. oHeapify the root element to restor e the m ax heap. 3. The array will be sorted in ascending order. Time Complexity: •Build Heap: O(n) •Heapify (n times): O(n log n) •Overall: O(n log n)Hea…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Is there any deadline/submission instruction in the document? If not, answer 'Not found in the document.'", "gold_answer": "Search : Hash the key to find the index, then linearl y search the linked list at that index. Deletion : Hash the key, search the linked list, and remove the node if found. No Clustering : Since elements are in separate lists, primary/secondary clustering does…", "gold_evidence": "[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p8:c14] height h\nLL, RR are single rotations\nLR, RL are double rotations.\nWe check the balance factor from  bottom to top, if\nwe find any  node not following the properties then\nwe do the rotations.\ninorder(node) {\nif (node == NULL) return;\ninorder(node->left);\nvisit(node);\ninorder(node->right);\n}\nInorder: 20 10 30\npreorder(node) {\nif (node == NULL) return…", "draft_gold_evidence": "[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p8:c14] height h\nLL, RR are single rotations\nLR, RL are double rotations.\nWe check the balance factor from  bottom to top, if\nwe find any  node not following the properties then\nwe do the rotations.\ninorder(node) {\nif (node == NULL) return;\ninorder(node->left);\nvisit(node);\ninorder(node->right);\n}\nInorder: 20 10 30\npreorder(node) {\nif (node == NULL) return…", "draft_gold_answer": "Search : Hash the key to find the index, then linearl y search the linked list at that index. Deletion : Hash the key, search the linked list, and remove the node if found. No Clustering : Since elements are in separate lists, primary/secondary clustering does…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one definition stated in the notes? Quote it exactly if present; otherwise answer 'Not found in the document.'", "gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…", "gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p14:c23] y clustering\nProblem : May lead to secondary clustering\nCan fail to insert even when space exists if not\ncarefully designed\nIn double hashing h2(k) should not be 0, otherwise it becomes the linear probing.\nDeletion Problem in Open Addressing (Linear,\nQuadratic, Double Hashing)\nIn open addressing , when you delete an element,\nsimply marking the slot…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…", "draft_gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p14:c23] y clustering\nProblem : May lead to secondary clustering\nCan fail to insert even when space exists if not\ncarefully designed\nIn double hashing h2(k) should not be 0, otherwise it becomes the linear probing.\nDeletion Problem in Open Addressing (Linear,\nQuadratic, Double Hashing)\nIn open addressing , when you delete an element,\nsimply marking the slot…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…", "draft_gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is the time complexity of one algorithm mentioned (as stated)? If not present, answer 'Not found in the document.'", "gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…", "gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p10:c17] will\nbe found i n the leaf nodes, so the tim e\ncomplexity to find it is O(n) .\n•The number of leaf nodes in a heap is\nceil(n/2).\n•The minimum element  in a Max Heap will\nbe found i n the leaf nodes, so the time\ncomplexity is also O(n) .\n•Heap Sort repeatedly deletes the ro ot\nelement and re-heapifies the remaini ng\nheap, s o the total time complexi…\n[p2:c1] on the 1d array.  Sparse Matrix\nA sparse matrix  is a matrix in which most of the\nelements are zero .\nIf the number of zero elements > number of non-zero\nelements, the matrix is sparse.\nLower Triangular Matrix\nA lower triangular matrix is a square matrix where\nall elements above the main diagonal are zero .\nA[i][j] = 0 for all i < j\nMust be square…\n[p13:c20] Graph Representations  Graph Traversals\nGraph traversal refers to visiting all the vertices (and\noptionally edges) of a graph in a systematic way.\n•BFS (Queue): Level -order, shortest path i n\nunweighted graph\n•DFS (Stack/Recursion): Deepest first, used i n\ncycle detection, topological sort\nBreadth -First Search (BFS)\nLevel-wise traversal\nUses a qu…", "draft_gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p10:c17] will\nbe found i n the leaf nodes, so the tim e\ncomplexity to find it is O(n) .\n•The number of leaf nodes in a heap is\nceil(n/2).\n•The minimum element  in a Max Heap will\nbe found i n the leaf nodes, so the time\ncomplexity is also O(n) .\n•Heap Sort repeatedly deletes the ro ot\nelement and re-heapifies the remaini ng\nheap, s o the total time complexi…\n[p2:c1] on the 1d array.  Sparse Matrix\nA sparse matrix  is a matrix in which most of the\nelements are zero .\nIf the number of zero elements > number of non-zero\nelements, the matrix is sparse.\nLower Triangular Matrix\nA lower triangular matrix is a square matrix where\nall elements above the main diagonal are zero .\nA[i][j] = 0 for all i < j\nMust be square…\n[p13:c20] Graph Representations  Graph Traversals\nGraph traversal refers to visiting all the vertices (and\noptionally edges) of a graph in a systematic way.\n•BFS (Queue): Level -order, shortest path i n\nunweighted graph\n•DFS (Stack/Recursion): Deepest first, used i n\ncycle detection, topological sort\nBreadth -First Search (BFS)\nLevel-wise traversal\nUses a qu…", "draft_gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "List 3 important keywords/terms that appear in the notes.", "gold_answer": "Search : Hash the key to find the index, then linearl y search the linked list at that index. Deletion : Hash the key, search the linked list, and remove the node if found. No Clustering : Since elements are in separate lists, primary/secondary clustering does…", "gold_evidence": "[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p3:c3] Tridiagonal matrix\nA tridiagonal matrix  is a square matrix where non-\nzero elements exist only on the main diagonal, just\nabove it , and just below it.\nA[i][j] ≠ 0 only if i == j, i == j+1, or i == j –1\nElse, A[i][j] = 0\nSum of all the element is 3n -2.\nA linked list  is a linear data structure where elements\n(called nodes ) are stored in non -con…\n[p4:c4] Implementation Methods:\n1.Using Array  (Fixed size, static memory)\n2.Using Linked List  (Dynamic size)Queue\nA Queue  is a linear data structure that follows the\nFIFO  principle:\nFirst In, First Out\nThe first element inserted is the first to be removed.\nReal-World Examples:\n•Ticket line\n•Print queue\nCPU task scheduling  Operation  Description  Time…\n[p12:c18] Graph\nA graph  is a collection of vertices (nodes)  and edges\n(connections)  that represent relationships between\npairs of objects.\nG= (V, E)\nWhere:\n•V = set of vertices\n•E = set of edges (unordered pair fo r\nundirected, ordered for directed)Deletion is mostly done at the root node  (i.e.,\nthe max in Max Heap or min in Min Heap).\nSteps:\n1.Remove th…", "draft_gold_evidence": "[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p3:c3] Tridiagonal matrix\nA tridiagonal matrix  is a square matrix where non-\nzero elements exist only on the main diagonal, just\nabove it , and just below it.\nA[i][j] ≠ 0 only if i == j, i == j+1, or i == j –1\nElse, A[i][j] = 0\nSum of all the element is 3n -2.\nA linked list  is a linear data structure where elements\n(called nodes ) are stored in non -con…\n[p4:c4] Implementation Methods:\n1.Using Array  (Fixed size, static memory)\n2.Using Linked List  (Dynamic size)Queue\nA Queue  is a linear data structure that follows the\nFIFO  principle:\nFirst In, First Out\nThe first element inserted is the first to be removed.\nReal-World Examples:\n•Ticket line\n•Print queue\nCPU task scheduling  Operation  Description  Time…\n[p12:c18] Graph\nA graph  is a collection of vertices (nodes)  and edges\n(connections)  that represent relationships between\npairs of objects.\nG= (V, E)\nWhere:\n•V = set of vertices\n•E = set of edges (unordered pair fo r\nundirected, ordered for directed)Deletion is mostly done at the root node  (i.e.,\nthe max in Max Heap or min in Min Heap).\nSteps:\n1.Remove th…", "draft_gold_answer": "Search : Hash the key to find the index, then linearl y search the linked list at that index. Deletion : Hash the key, search the linked list, and remove the node if found. No Clustering : Since elements are in separate lists, primary/secondary clustering does…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one theorem/lemma/property stated? If not present, answer 'Not found in the document.'", "gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…", "gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p14:c23] y clustering\nProblem : May lead to secondary clustering\nCan fail to insert even when space exists if not\ncarefully designed\nIn double hashing h2(k) should not be 0, otherwise it becomes the linear probing.\nDeletion Problem in Open Addressing (Linear,\nQuadratic, Double Hashing)\nIn open addressing , when you delete an element,\nsimply marking the slot…", "draft_gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p14:c23] y clustering\nProblem : May lead to secondary clustering\nCan fail to insert even when space exists if not\ncarefully designed\nIn double hashing h2(k) should not be 0, otherwise it becomes the linear probing.\nDeletion Problem in Open Addressing (Linear,\nQuadratic, Double Hashing)\nIn open addressing , when you delete an element,\nsimply marking the slot…", "draft_gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Describe one table/list mentioned (what items are compared or listed). If none, answer 'Not found in the document.'", "gold_answer": "Search : Hash the key to find the index, then linearl y search the linked list at that index. Deletion : Hash the key, search the linked list, and remove the node if found. No Clustering : Since elements are in separate lists, primary/secondary clustering does…", "gold_evidence": "[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p14:c24] 's not present, even though 24 is at\nindex 5.\n•This happens because deletion breaks t he\nprobing chain, causing search failure.\n•This may require the rehashing.\n•\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (or tail) of…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…", "draft_gold_evidence": "[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p14:c24] 's not present, even though 24 is at\nindex 5.\n•This happens because deletion breaks t he\nprobing chain, causing search failure.\n•This may require the rehashing.\n•\nSeparate chaining\nA collision resolution technique where each slot in\nthe hash table stores a linked list  (or chain) of\nelements.\nInsertion : Insert the element at the head (or tail) of…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…", "draft_gold_answer": "Search : Hash the key to find the index, then linearl y search the linked list at that index. Deletion : Hash the key, search the linked list, and remove the node if found. No Clustering : Since elements are in separate lists, primary/secondary clustering does…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one stated limitation/constraint? If none, answer 'Not found in the document.'", "gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…", "gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…", "draft_gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…", "draft_gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one stated advantage/benefit? If none, answer 'Not found in the document.'", "gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…", "gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…", "draft_gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…", "draft_gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "Provide one short quote (1–2 sentences) from the notes that best represents the topic.", "gold_answer": "ase 1: Node has no children (Leaf Node) oSimply remove the node. oNo tree structure change. 2.Case 2: Node has one ch ild oReplace the node with its only child . oMaintain the link with the parent. 3.Case 3: Node has two children oReplace the node with its: I…", "gold_evidence": "[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p6:c10] d from any node and its\ndescendants\n•Maximum Nodes in a Binary Tree of Hei ght\n'h' = 2ℎ+1 −1\n•Minimum nodes in a Binary tree= h+1\n•The minimum possible height for  N nodes\nis ⌊𝐥𝐥𝐥𝐥𝐥𝐥𝟐𝟐N⌋\n•Total number of unlabelled binary tree wi th n\nnode = 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1\n•Total  number of labelled binary tree = 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1 ×\n𝑛𝑛!\n•Total number of the binary tree wi…\n[p4:c5] lity\n•Backtracking (like maze, Sudoku)\n•Number of possible stack permutations\n= 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE फर्रे\nPage No:- 03", "draft_gold_evidence": "[p7:c12] ase 1: Node has no children (Leaf\nNode)\noSimply remove the node.\noNo tree structure change.\n2.Case 2: Node has one ch ild\noReplace  the node with its only child .\noMaintain the link with the parent.\n3.Case 3: Node has two children\noReplace the node with its:\nInorder Successor  (smallest in\nright subtree) or\nInorder Predecessor (largest\nin left su…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p6:c10] d from any node and its\ndescendants\n•Maximum Nodes in a Binary Tree of Hei ght\n'h' = 2ℎ+1 −1\n•Minimum nodes in a Binary tree= h+1\n•The minimum possible height for  N nodes\nis ⌊𝐥𝐥𝐥𝐥𝐥𝐥𝟐𝟐N⌋\n•Total number of unlabelled binary tree wi th n\nnode = 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1\n•Total  number of labelled binary tree = 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1 ×\n𝑛𝑛!\n•Total number of the binary tree wi…\n[p4:c5] lity\n•Backtracking (like maze, Sudoku)\n•Number of possible stack permutations\n= 2𝑛𝑛𝐶𝐶𝑛𝑛\n𝑛𝑛+1struct Stack {\nint arr [10];\nint top;\n};\narr []: stores the stack elements\ntop: points to the topmost element (initially -1)\nDATA STRUCTURE\nGATE फर्रे\nPage No:- 03", "draft_gold_answer": "ase 1: Node has no children (Leaf Node) oSimply remove the node. oNo tree structure change. 2.Case 2: Node has one ch ild oReplace the node with its only child . oMaintain the link with the parent. 3.Case 3: Node has two children oReplace the node with its: I…"}
{"doc_id": "357bcc83cb68dbdd", "pdf_path": "eval/pdfs/public/sample.pdf", "source_type": "own", "source_url": "", "license": "", "question": "What is one abbreviation/acronym expanded in the notes? If none, answer 'Not found in the document.'", "gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…", "gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…", "draft_gold_evidence": "[p10:c16] Max Heap\nThe value of each node is greater than or equal to its\nchildren.\n|𝒂𝒂𝒌𝒌| > | left tree, right tree|\nRoot = Maximum element\nProperties:\n•Implemented using arrays.\n•For node at index i:\noLeft child = 2i + 1\noRight child = 2i + 2\noParent = ( i - 1) / 2Applications :\n•Priority Queue\n•Heap Sort\n•Scheduling algorithms\n•Graph algorithms\n•Access ro…\n[p15:c25] Search : Hash the key to find the index, then\nlinearl y search the linked list at that index.\nDeletion : Hash the key, search the linked list, and\nremove the node if found.\nNo Clustering : Since elements are in separate lists,\nprimary/secondary clustering does not occur.\nLoad Factor ( λ): λ = n / m\n(n = total el ements, m = table size)\nPerformance…\n[p7:c11] Complete Binary tree\nThis is the binary tree which is filled at second last\nlevel, and the insertion happens from the left to right. For complete binary tree\n•Minimum number of nodes is 2\nℎ\n•Maximum number of nodes is = 2ℎ+1 −1\nBinary Search Tree\nLeft < root < right\nEvery structure of the n node has unique binary search tree.\ni.e. if we have 3 keys…\n[p8:c13] AVL Tree\nTree traversal Inorder\nLeft Subtree → Node → Right Subtree\nIn BST, it gives sorted order of elements.\nPreorder\nNode → Left Subtree → Right Subtree •A self-balancing binary search tree (BST)\nwhere the difference in heights of the l eft\nand r ight subtrees (called balance factor )\nof ev ery node is -1, 0, or +1.\nBalance Factor:\nBalance Facto…", "draft_gold_answer": "Max Heap The value of each node is greater than or equal to its children. |𝒂𝒂𝒌𝒌| > | left tree, right tree| Root = Maximum element Properties: •Implemented using arrays. •For node at index i: oLeft child = 2i + 1 oRight child = 2i + 2 oParent = ( i - 1) / 2App…"}
